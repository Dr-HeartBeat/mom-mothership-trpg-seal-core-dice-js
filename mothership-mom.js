// ==UserScript==
// @name         æ¯èˆ°-MOMåŠ©æ‰‹
// @author       Drå¿ƒè·³
// @version      1.0.1-beta.0
// @description  mothership RPG è§„åˆ™æ’ä»¶-å·²æ­è½½AIåŠ©æ‰‹M.O.M.ã€‚v1.0.1-beta.0
// @license      MIT

/*ä»£ç æ‹Ÿåˆè§„åˆ™è¯´æ˜ï¼š
1.å‹åŠ›æº¢å‡º20çš„æƒ…å†µï¼šè§„åˆ™åŸæ–‡ä¸­æŒ‡å‡ºï¼šFinally, the maximum Stress you can have is 20. Any Stress you take over 20 instead reduces the most relevant Stat or Save by that amount.
å› æ­¤ï¼Œåº”å½“æ˜¯æ ¹æ®è·‘å›¢å‰§æƒ…ï¼Œå†³å®šâ€œç›¸å…³çš„â€ä½•ç§å±æ€§æˆ–è±å…çš„å€¼å‡å°‘ï¼Œè€Œä¸æ˜¯è·å¾—æ£€å®šå‡å€¼ã€‚
å½“å‹åŠ›æº¢å‡ºï¼Œä¼šä½¿å¾—ç©å®¶çš„å±æ€§è±å…å€¼è¶Šæ¥è¶Šä½ï¼Œä¸å¯é€†ï¼Œæ‰€ä»¥ç©å®¶åº”å½“åƒæ–¹ç™¾è®¡é¿å…å‹åŠ›æº¢å‡ºã€‚è¿™ä¹Ÿå°±æ˜¯ä¸ºä»€ä¹ˆåŒ»ç–—ä¸­æœ‰å¾ˆæ…·æ…¨çš„å±æ€§æå‡æ–¹æ¡ˆ.
                                                                â€”â€”â€”â€”"èµšé’±å°±æ˜¯ç”¨æ¥äº«å—çš„ï¼Œèˆ¹å‘˜ï¼Œå¥½å¥½åº¦å‡å§" ä½¿ç”¨.ms leave æŒ‡ä»¤åº¦å‡
                                                                â€”â€”â€”â€”"TMDèµšåˆ°çš„é’±éƒ½è¢«åŒ»é™¢æ‹¿èµ°äº†" ä½¿ç”¨.ms recover æŒ‡ä»¤è·å¾—åŒ»ç–—
2.ä¼˜åŠ¿å’ŒåŠ£åŠ¿ï¼šåœ¨æ¯èˆ°trpgä¸­ï¼Œä¼˜åŠ¿å¹¶ä¸æ„å‘³ç€æ€»æ˜¯å–è¾ƒä½çš„å€¼ï¼Œè€Œæ˜¯å–æ›´å¥½çš„å€¼ã€‚åœ¨å±æ€§å’Œè±å…æ£€å®šä¸­ï¼Œæ”»å‡»æ£€å®šï¼ˆæ”»å‡»å±æ€§æ£€å®šï¼‰ï¼Œä¼‘æ¯è±å…ï¼ŒæƒŠææ£€å®šï¼Œä¼˜åŠ¿æ›´é«˜ï¼›è€Œåœ¨ä¼¤å®³æŠ•æ·ï¼Œä¼˜åŠ¿æ˜¯æ›´é«˜ã€‚
3.æ”»å‡»å¤§æˆåŠŸ: åŸæ–‡æœ¬å±…ç„¶æ²¡æœ‰è¯´æ˜æ”»å‡»å¤§æˆåŠŸçš„æ•ˆæœå¦‚ä½•, æ˜¯åŒå€ä¼¤å®³,è¿˜æ˜¯å¯ä»¥ä»»é€‰å‘½ä¸­ä½ç½®?æˆ‘æƒ³è¿™åº”è¯¥æ˜¯æˆ¿è§„,æœ¬æ’ä»¶æœªå®ç°.
4.æˆ¿è§„æ˜¯è·‘å›¢ç‰¹è‰²,ä¸å¯ä¸å“å°. éšç€å›ºæ¡Œæˆ¿è§„çš„ä¸æ–­ç¡®ç«‹,æœ¬æ’ä»¶ä¼šæ˜¾å¾—è¶Šæ¥è¶Šä¸çµæ´». ä½†æ˜¯æœ¬æ’ä»¶ä½œä¸ºä¸€ä¸ªçŠ¶æ€è®°å½•å™¨ä»ç„¶æ˜¯ä¸é”™çš„. ä¾‹å¦‚åœ¨è¦è¿›è¡ŒåŠ›é‡æ£€å®šçš„æ—¶å€™, è¾“å…¥.ms åŠ›é‡, å°±èƒ½æŸ¥çœ‹è‡ªå·±å½“å‰çš„çŠ¶æ€\æ­¦å™¨\è£…ç”²å¯¹è¿™æ¬¡æ£€å®šçš„å½±å“å¦‚ä½•.
5.åœ¨åŸè§„åˆ™ä¸­,åªæœ‰éƒ¨åˆ†æƒŠæè¡¨ä¸­çš„æ•ˆæœæ‰ä¼šè·å¾—"çŠ¶æ€",ä½†æ˜¯åœ¨ä»£ç å®ç°çš„æ—¶å€™,æœ‰å¾ˆå¤š"å»¶æ—¶æ€§å½±å“",åœ¨æœ¬æ’ä»¶ä¸­éƒ½è¢«è§†ä¸ºç±»ä¼¼"çŠ¶æ€"CONDITIONSè¿›è¡Œé€»è¾‘å¤„ç†.ä½†æ˜¯è¿˜æ˜¯è¦åŒºåˆ†.ä¸»è¦æ˜¯æ˜ç¡®[è®¤çŸ¥ç¢ç‰‡æ•´ç†]èƒ½å¤Ÿå»é™¤çš„æ˜¯ä»€ä¹ˆ. åœ¨PANIC_CONDITIONSä¸­åˆ—å‡ºäº†.
                                                                */
// ==/UserScript==

(() => {
    // ==========================================
    // æ¨¡å—ä¸€ï¼šå¸¸é‡ä¸æ•°æ®å®šä¹‰ (Constants & Database)
    // å­˜æ”¾æ‰€æœ‰é™æ€æ•°æ®ã€è§„åˆ™æ–‡æœ¬ã€æ˜ å°„è¡¨
    // ==========================================
    const MS_CONSTS = {
        NAME: "mothership",
        KEY: "ms",

        // å±æ€§ä¸æŠ€èƒ½æ˜ å°„è¡¨ (Attribute Map)
        // é”®åä¸ºæ ‡å‡†å±æ€§åï¼Œå€¼ä¸º[è‹±æ–‡ç¼©å†™, è‹±æ–‡å…¨ç§°, ç®€ä½“ä¸­æ–‡, ç¹ä½“ä¸­æ–‡...]
        ATTR_MAP: {
            // --- åŸºç¡€å±æ€§ ---
            "åŠ›é‡": ["str", "strength", "åŠ›é‡", "åŠ›é‡"],
            "é€Ÿåº¦": ["spd", "speed", "é€Ÿåº¦", "é€Ÿåº¦"],
            "æ™ºåŠ›": ["int", "intellect", "æ™ºåŠ›", "æ™ºåŠ›"],
            "æˆ˜æ–—": ["cbt", "combat", "æˆ˜æ–—", "æ–—æ®´", "å°„å‡»", "æˆ°é¬¥", "é¬¥æ¯†", "å°„æ“Š", "æˆ°é¬¥"],

            // --- è±å… ---
            "ç†æ™º": ["san", "sanity", "ç†æ™º", "ç†æ™º"],
            "ææƒ§": ["fear", "ææƒ§", "ææ‡¼", "ææ‡¼"],
            "èº«ä½“": ["body", "èº«ä½“", "ä½“è´¨", "con", "èº«é«”", "é«”è³ª", "èº«é«”"],

            // --- è¡ç”Ÿå±æ€§ ---
            "æŠ¤ç”²": ["ap", "armor", "æŠ¤ç”²", "è­·ç”²", "è­·ç”²"],
            "ç”Ÿå‘½å€¼": ["hp", "health", "ç”Ÿå‘½å€¼", "ç”Ÿå‘½å€¼"],
            "ç”Ÿå‘½å€¼ä¸Šé™": ["max_hp", "ç”Ÿå‘½å€¼ä¸Šé™", "ç”Ÿå‘½å€¼ä¸Šé™"],
            "æŸä¼¤": ["wounds", "æŸä¼¤", "æå‚·", "æå‚·"],
            "æŸä¼¤ä¸Šé™": ["max_wounds", "æŸä¼¤ä¸Šé™", "æå‚·ä¸Šé™", "æå‚·ä¸Šé™"],
            "å‹åŠ›": ["stress", "å‹åŠ›", "å£“åŠ›", "å£“åŠ›"],
            "å‹åŠ›ä¸‹é™": ["min_stress", "å‹åŠ›ä¸‹é™", "å£“åŠ›ä¸‹é™", "å£“åŠ›ä¸‹é™"],
            "èŒç±»": ["class", "èŒç±»", "è·æ¥­", "è·æ¥­"],


            // --- æŠ€èƒ½ (åŒ…å«ç¹ä½“åˆ«å) ---
            "è€ƒå¤å­¦": ["archaeology", "è€ƒå¤", "è€ƒå¤å­¸"],
            "è‰ºæœ¯": ["art", "è‰ºæœ¯", "è—è¡“"],
            "è¿åŠ¨": ["athletics", "ä½“èƒ½", "è¿åŠ¨", "é«”èƒ½", "é‹å‹•"],
            "æ¤ç‰©å­¦": ["botany", "æ¤ç‰©", "æ¤ç‰©å­¸"],
            "åŒ–å­¦": ["chemistry", "åŒ–å­¦", "åŒ–å­¸"],
            "è®¡ç®—æœº": ["computers", "ç”µè„‘", "è®¡ç®—æœº", "é›»è…¦", "è¨ˆç®—æ©Ÿ"],
            "åœ°è´¨å­¦": ["geology", "åœ°è´¨", "åœ°è³ª", "åœ°è³ªå­¸"],
            "å·¥ä¸šè£…å¤‡": ["industrial equipment", "å·¥ä¸š", "é‡å‹æœºæ¢°", "å·¥æ¥­", "é‡å‹æ©Ÿæ¢°"],
            "ä¸´æ—¶æ‹¼å‡‘": ["jury-rigging", "æ‹¼å‡‘", "ä¿®ç†", "æ€¥æ™º", "æ‹¼æ¹Š"],
            "è¯­è¨€å­¦": ["linguistics", "è¯­è¨€", "èªè¨€", "èªè¨€å­¸"],
            "æ•°å­¦": ["mathematics", "æ•°å­¦", "ç®—æœ¯", "æ•¸å­¸", "ç®—è¡“"],
            "å†›äº‹è®­ç»ƒ": ["military training", "å†›è®­", "å†›äº‹", "è»è¨“", "è»äº‹"],
            "å¤–ç¯é—¨é“": ["rimwise", "å¤–ç¯", "é»‘é“", "é—¨é“", "å¤–ç’°", "é–€é“"],
            "ç¥å­¦": ["theology", "ç¥å­¦", "å®—æ•™", "ç¥å­¸"],
            "é›¶é‡åŠ›": ["zero-g", "é›¶é‡", "çœŸç©º"],
            "åŠ¨ç‰©å­¦": ["zoology", "åŠ¨ç‰©", "å‹•ç‰©", "å‹•ç‰©å­¸"],
            "å°è¡Œæ˜Ÿé‡‡çŸ¿": ["asteroid mining", "é‡‡çŸ¿", "æ¡ç¤¦"],
            "ç”Ÿæ€å­¦": ["ecology", "ç”Ÿæ€", "ç”Ÿæ…‹", "ç”Ÿæ…‹å­¸"],
            "çˆ†ç‚¸ç‰©": ["explosives", "ç‚¸è¯", "çˆ†ç ´", "ç‚¸è—¥"],
            "æˆ˜åœ°åŒ»ç–—": ["field medicine", "æ€¥æ•‘", "åŒ»ç–—", "æˆ˜åœ°åŒ»", "é†«ç™‚", "æˆ°åœ°é†«"],
            "æªæ¢°": ["firearms", "æª", "æªæ¢°", "æ§", "æ§æ¢°"],
            "éª‡å…¥": ["hacking", "é»‘å®¢", "éª‡å®¢", "å…¥ä¾µ", "é§­å…¥", "é§­å®¢"],
            "è¿‘èº«ææ–—": ["hand-to-hand combat", "æ ¼æ–—", "æå‡»", "è¿‘æˆ˜", "æ ¼é¬¥", "ææ“Š", "è¿‘æˆ°"],
            "æœºæ¢°ä¿®ç†": ["mechanical repair", "æœºä¿®", "æœºæ¢°", "æ©Ÿä¿®", "æ©Ÿæ¢°"],
            "ç¥ç§˜ä¸»ä¹‰": ["mysticism", "ç¥ç§˜", "ç„å­¦", "ç¥ç§˜ä¸»ç¾©", "ç„å­¸"],
            "ç—…ç†å­¦": ["pathology", "ç—…ç†", "ç—…ç†å­¸"],
            "è¯ç†å­¦": ["pharmacology", "è¯ç†", "åˆ¶è¯", "è—¥ç†", "è£½è—¥"],
            "ç‰©ç†å­¦": ["physics", "ç‰©ç†", "ç‰©ç†å­¸"],
            "é©¾æœº": ["piloting", "é©¾é©¶", "é£è¡Œ", "é§•é§›", "é£›è¡Œ"],
            "å¿ƒç†å­¦": ["psychology", "å¿ƒç†", "å¿ƒç†å­¸"],
            "è’é‡ç”Ÿå­˜": ["wilderness survival", "ç”Ÿå­˜", "é‡å¤–"],
            "äººå·¥æ™ºèƒ½": ["artificial intelligence", "ai", "äººå·¥æ™ºèƒ½", "äººå·¥æ™ºæ…§"],
            "æŒ‡æŒ¥": ["command", "æŒ‡æŒ¥", "é¢†å¯¼", "æŒ‡æ®", "é ˜å°"],
            "ç¥ç»æœºæ¢°å­¦": ["cybernetics", "ä¹‰ä½“", "èµ›åš", "ç¥ç»æœºæ¢°", "ç¾©é«”", "è³½åš", "ç¥ç¶“æ©Ÿæ¢°"],
            "å·¥ç¨‹å­¦": ["engineering", "å·¥ç¨‹", "å·¥ç¨‹å­¸"],
            "å¤–æ˜Ÿç”Ÿç‰©å­¦": ["exobiology", "å¤–æ˜Ÿç”Ÿç‰©", "å¤–æ˜Ÿç”Ÿç‰©å­¸"],
            "è¶…ç©ºé—´": ["hyperspace", "è¶…ç©ºé—´", "è·ƒè¿", "è¶…ç©ºé–“", "èºé·"],
            "è¡Œæ˜Ÿå­¦": ["planetology", "è¡Œæ˜Ÿ", "è¡Œæ˜Ÿå­¸"],
            "æœºå™¨äººå­¦": ["robotics", "æœºå™¨äºº", "æ©Ÿå™¨äºº", "æ©Ÿå™¨äººå­¸"],
            "çŸ¥æ€§å­¦": ["sophontology", "çŸ¥æ€§", "æ™ºæ…§ç”Ÿç‰©", "çŸ¥æ€§å­¸"],
            "æ‰‹æœ¯": ["surgery", "æ‰‹æœ¯", "æ‰‹è¡“"],
            "å¼‚ç§ç§˜æ•™": ["xenoesotericism", "xeno", "å¼‚ç§", "ç§˜æ•™", "å¤–æ˜Ÿç§˜æ•™", "ç•°ç¨®", "ç•°ç¨®ç§˜æ•™",],

            // --- ç‰©å“å˜é‡ ---
            "å…´å¥‹è¯æ‘„å…¥": ["stim_intake", "å…´å¥‹å‰‚", "stimpak_doses", "èˆˆå¥®åŠ‘", "èˆˆå¥®è—¥æ”å…¥", "å…´å¥‹è¯æ‘„å…¥"],

            //----ä¸“ä¸šåè¯---
            "ä¼‘æ¯": ["ä¼‘æ¯", "rest"]
        },

        // èŒç±»IDæ˜ å°„ (Class ID Map)
        // ç”¨äº .st èŒç±»1 è¿™ç§æ•°å­—å½•å…¥çš„è§£æ
        CLASS_ID_MAP: {
            "0": "æœªè®¾ç½®èŒç±»",
            "1": "é™†æˆ˜é˜Ÿå‘˜",
            "2": "ä»¿ç”Ÿäºº",
            "3": "ç§‘å­¦å®¶",
            "4": "æŠ€å·¥"
        },

        // èŒç±»è¯¦ç»†å®šä¹‰ (Classes)
        // åŒ…å«åç§°ã€åˆ›ä¼¤ååº”(trait)ã€å±æ€§åŠ æˆæè¿°(desc)å’Œåˆ«å
        CLASSES: {
            "æœªè®¾ç½®èŒç±»": {
                id: 0,
                name: "æœªè®¾ç½®èŒç±» (class Undefined)",
                trait: "æœªè®¾ç½®èŒç±»",
                desc: "æœªè®¾ç½®èŒç±»",
                aliases: []
            },
            "é™†æˆ˜é˜Ÿå‘˜": {
                id: 1,
                name: "é™†æˆ˜é˜Ÿå‘˜ (Marine)",
                trait: "ã€åˆ›ä¼¤ååº”ã€‘åªè¦ä½ é™·å…¥æƒŠæï¼Œæ‰€æœ‰è¿‘è·å‹æ–¹ç©å®¶éƒ½å¿…é¡»è¿›è¡Œä¸€æ¬¡ææƒ§è±å…ã€‚",
                desc: "å±æ€§åŠ æˆ: æˆ˜æ–—+10, èº«ä½“+10, ææƒ§+20, æŸä¼¤ä¸Šé™+1",
                aliases: ["marine", "é™†æˆ˜é˜Ÿ", "é™†æˆ˜é˜Ÿå‘˜", "é™¸æˆ°éšŠ", "æµ·è»é™¸æˆ°éšŠ", "1"]
            },
            "ä»¿ç”Ÿäºº": {
                id: 2,
                name: "ä»¿ç”Ÿäºº (Android)",
                trait: "ã€åˆ›ä¼¤ååº”ã€‘è¿‘è·å‹æ–¹ç©å®¶è¿›è¡Œçš„ææƒ§è±å…å¸¦æœ‰åŠ£åŠ¿ã€‚",
                desc: "å±æ€§åŠ æˆ: æ™ºåŠ›+20, ææƒ§+60, æŸä¼¤ä¸Šé™+1, æŸé¡¹å±æ€§-10",
                aliases: ["android", "ä»¿ç”Ÿäºº", "å®‰å“", "æ©Ÿå™¨äºº", "2"]
            },
            "ç§‘å­¦å®¶": {
                id: 3,
                name: "ç§‘å­¦å®¶ (Scientist)",
                trait: "ã€åˆ›ä¼¤ååº”ã€‘åªè¦ä½ ç†æ™ºè±å…å¤±è´¥ï¼Œæ‰€æœ‰è¿‘è·å‹æ–¹ç©å®¶è·å¾— 1 å‹åŠ›ã€‚",
                desc: "å±æ€§åŠ æˆ: æ™ºåŠ›+10, ç†æ™º+30, æŸé¡¹å±æ€§+5",
                aliases: ["scientist", "ç§‘å­¦å®¶", "ç§‘å­¸å®¶", "3"]
            },
            "æŠ€å·¥": {
                id: 4,
                name: "æŠ€å·¥ (Teamster)",
                trait: "ã€åˆ›ä¼¤ååº”ã€‘æ¯å›æ¸¸æˆä¸€æ¬¡ï¼Œä½ å¯ä»¥åœ¨æŸæ¬¡æƒŠææ£€å®šä¸­å¸¦æœ‰ä¼˜åŠ¿ã€‚",
                desc: "å±æ€§åŠ æˆ: æ‰€æœ‰å±æ€§+5, æ‰€æœ‰è±å…+10",
                aliases: ["teamster", "æŠ€å·¥", "è“é¢†", "å·¥äºº", "4"]
            }
        },

        // çŠ¶æ€å®šä¹‰åº“ (Conditions)
        // åŒ…å«ï¼šæƒŠæçŠ¶æ€ã€åŒ»ç–—å‰¯ä½œç”¨ã€å¸¸è§æŸä¼¤çŠ¶æ€
        // summary: ç®€è¿° (.ms list ç”¨)
        // detail: è¯¦è¿° (.ms list çŠ¶æ€å æˆ– æƒŠæç»“æœç”¨)
        PANIC_CONDITIONS: [
            "æ‡¦å¼±", "ææƒ§ç—‡", "æ¢¦é­‡", "å¤±å»è‡ªä¿¡", "æ³„æ°”", "å¤§éš¾ä¸´å¤´", "ä½œç¥Ÿ", "æ²¦é™·"
        ],
        CONDITIONS: {
            // -- æƒŠæçŠ¶æ€ --
            "è‚¾ä¸Šè…ºç´ æ¿€å¢": {
                summary: "è·å¾—ä¼˜åŠ¿é™ä½å‹åŠ›",
                detail: "ä¹‹å 2d10 åˆ†é’Ÿå†…æ‰€æœ‰æŠ•éª°å¸¦æœ‰ [ + ]",
                modifiers: [
                    { target: "all", type: "adv" }
                ]
            },
            "ä¸çŸ¥æ‰€æª": {
                summary: "æ‰€æœ‰æŠ•éª° [-]",
                detail: "ä¹‹å 1d10 åˆ†é’Ÿå†…æ‰€æœ‰æŠ•éª°å¸¦æœ‰ [ - ]ã€‚",
                modifiers: [
                    { target: "all", type: "dis" }
                ]
            },
            "æ‡¦å¼±": {
                summary: "[çŠ¶æ€]éœ€ææƒ§è±å…æ‰èƒ½æš´åŠ›",
                detail: "å¿…é¡»é€šè¿‡ä¸€æ¬¡ææƒ§è±å…æ‰èƒ½å‚ä¸æš´åŠ›è¡Œä¸ºï¼Œå¦åˆ™å°±ä¼šé€ƒè·‘ã€‚",
                special: "FORCE_SAVE_VIOLENCE"
            },
            "ææƒ§ç—‡": {
                summary: "[çŠ¶æ€]é‡ææƒ§æºéœ€è±å…å¦åˆ™+å‹åŠ›",
                detail: "åœ¨é­é‡ææƒ§æºæ—¶å¾—è¦é€šè¿‡ä¸€æ¬¡ææƒ§è±å… [ - ]ï¼Œå¦åˆ™è·å¾— 1d5 å‹åŠ›ã€‚",
                // modifiers: [
                // { target: "ææƒ§", type: "dis" },
                // { target: "fear", type: "dis" }
                //ææƒ§æºåº”å½“æ˜¯æŒ‡è§’è‰²å®³æ€•çš„æŸæ ·ä¸œè¥¿ï¼Œåº”è¯¥åªæœ‰é¢å¯¹è¿™ä¸ªä¸œè¥¿çš„æ—¶å€™æ‰éœ€è¦åŠ£åŠ¿ææƒ§è±å…
                // ]
            },
            "æ¢¦é­‡": {
                summary: "[çŠ¶æ€]ä¼‘æ¯è±å… [-]",
                detail: "éš¾ä»¥å®‰ç¡ï¼Œä¼‘æ¯è±å…å¸¦æœ‰ [ - ]ã€‚",
                modifiers: [
                    { target: "ä¼‘æ¯", type: "dis" },
                    { target: "rest", type: "dis" },
                ]
            },
            "å¤±å»è‡ªä¿¡": {
                summary: "[çŠ¶æ€]å¤±å»ä¸€é¡¹æŠ€èƒ½å¥–åŠ±",
                detail: "é€‰æ‹©ä¸€é¡¹æŠ€èƒ½ï¼Œå¤±å»æ­¤æŠ€èƒ½çš„å¥–åŠ±ã€‚",
                special: "DISABLE_SKILL_BONUS"
            },
            "æ³„æ°”": {
                summary: "[çŠ¶æ€]é˜Ÿå‹å¤±è´¥ä½ +å‹åŠ›",
                detail: "åªè¦æœ‰è¿‘è·ä¹˜å‘˜è±å…å¤±è´¥ï¼Œè·å¾— 1 å‹åŠ›ã€‚",
                special: "STRESS_ON_ALLY_FAIL"
            },
            "å¤§éš¾ä¸´å¤´": {
                summary: "[çŠ¶æ€]å…³é”®æˆåŠŸå˜å¤±è´¥",
                detail: "æ„Ÿè§‰è‡ªå·±å—åˆ°è¯…å’’ï¼Œå„è¿ç¼ èº«ã€‚æ‰€æœ‰å…³é”®æˆåŠŸå˜æˆå…³é”®å¤±è´¥ã€‚",
                special: "DOOM_CRIT_INVERT", trigger: "check",
            },
            "å¤šç–‘": {
                summary: "æ–°äººåŠ å…¥éœ€ææƒ§è±å…",
                detail: "ä¹‹åä¸€å‘¨å†…ï¼Œæ¯å½“æœ‰äººåŠ å…¥ä½ çš„å›¢ä½“ï¼ˆå³ä½¿ä»–ä»¬åªç¦»å¼€äº†å¾ˆçŸ­çš„æ—¶é—´ï¼‰ï¼Œé€šè¿‡ä¸€æ¬¡ææƒ§è±å…ï¼Œå¦åˆ™è·å¾— 1 å‹åŠ›ã€‚",
                special: "TRIGGER_SAVE_ON_JOIN"
            },
            "ä½œç¥Ÿ": {
                summary: "[çŠ¶æ€]å¤œé—´é­é‡å¹»è±¡",
                detail: "æœ‰äº›ä¸œè¥¿å¼€å§‹ä¼šåœ¨æ™šä¸Šé€ è®¿ï¼ŒåŒ…æ‹¬æ¢¦ä¸­æˆ–è§†çº¿è¾¹ç¼˜ï¼Œå¾ˆå¿«å¯¹æ–¹å°±ä¼šå¼€å§‹æå‡ºè¦æ±‚ã€‚",
                special: "NARRATIVE_VISIONS"
            },
            "ä½œæ­»": {
                summary: "é‡é™Œç”Ÿäººéœ€ç†æ™ºè±å…å¦åˆ™æ”»å‡»",
                detail: "ä¹‹å 24 å°æ—¶é‡Œï¼Œåªè¦é­é‡é™Œç”Ÿäººæˆ–æ˜¯å·²çŸ¥æ•Œäººï¼Œä½ å¿…é¡»é€šè¿‡ä¸€æ¬¡ç†æ™ºè±å…ï¼Œå¦åˆ™ç«‹åˆ»å‘èµ·æ”»å‡»ã€‚",
                special: "FORCE_SANITY_OR_ATTACK"
            },
            "ç´§å¼ ç—‡": {
                summary: "ä¸€æ®µæ—¶é—´æ¯«æ— ååº”",
                detail: "2d10 åˆ†é’Ÿé‡Œå˜å¾—æ¯«æ— ååº”ï¼Œå‘†è‹¥æœ¨é¸¡ã€‚",
                special: "UNRESPONSIVE"
            },
            "ç‹‚æš´": {
                summary: "ä¸€æ®µæ—¶é—´ä¼¤å®³æŠ•æ·æœ‰ä¼˜åŠ¿ï¼Œæ‰€æœ‰äººå‹åŠ›",
                detail: "ä¹‹å 1d10 å°æ—¶å†…ï¼Œæ‰€æœ‰ä¼¤å®³æŠ•éª°å¸¦æœ‰ [ + ]ã€‚æ‰€æœ‰ä¹˜ç»„è·å¾— 1 å‹åŠ›ã€‚",
                special: "DAMAGE_ADV", trigger: "damage",
            },
            "æ²¦é™·": {
                summary: "[çŠ¶æ€]æƒŠææ£€å®š [-]",
                detail: "æƒŠææ£€å®šå¸¦æœ‰ [-] ã€‚",
                modifiers: [
                    { target: "æƒŠæ", type: "dis" },
                    { target: "panic", type: "dis" }
                ]
            },
            "å¿ƒè„ç—…å‘/çŸ­è·¯": {
                summary: "æ‰€æœ‰æŠ•éª° [-]",
                detail: "1d10 å°æ—¶å†…æ‰€æœ‰æŠ•éª°å¸¦æœ‰ [ - ]ã€‚",
                modifiers: [
                    { target: "all", type: "dis" }
                ]
            },

            // -- åŒ»ç–—å‰¯ä½œç”¨ --
            //å‰¯ä½œç”¨æ˜¯æŒ‡å¿…ç„¶ä¼šå‡ºç°çš„æ•ˆæœ, ä¾‹å¦‚æ‰‹æœ¯ç¼åˆåä¼¤å£ç–¼ç—›. åé—ç—‡æ˜¯æŒ‡å¶å‘çš„å¼‚å¸¸çš„è´Ÿé¢çŠ¶å†µ. è¿™ä¸¤ä¸ªåè¯æ—¶ç°å®çŸ¥è¯†ä¸æ˜¯è§„åˆ™ä¹¦å†…å®¹.
            "è®¤çŸ¥ç¢ç‰‡æ•´ç†å‰¯ä½œç”¨": { summary: "[å‰¯ä½œç”¨] æ™º&ç†&ææ£€å®š [-]", detail: "å¤§è„‘æ­£åœ¨ä»æ‰‹æœ¯ä¸­æ¢å¤ã€‚æ™ºåŠ›æ£€å®šã€ç†æ™ºè±å…å’Œææƒ§è±å…åœ¨ 4 å‘¨å†…å¸¦æœ‰ [-]ã€‚", aliases: ["è®¤çŸ¥ç¢ç‰‡æ•´ç†å‰¯ä½œç”¨", "èªçŸ¥é‡å»º"], modifiers: [{ target: "æ™ºåŠ›", type: "dis" }, { target: "ç†æ™º", type: "dis" }, { target: "ææƒ§", type: "dis" }] },
            "å®Œå…¨å¤±å¿†": { summary: "è®¤çŸ¥ç¢ç‰‡æ•´ç†[åé—ç—‡],å™äº‹æ€§ä½œç”¨", detail: "æ‰‹æœ¯ä¸¥é‡å¤±è¯¯ï¼Œå¯¼è‡´å®Œå…¨å¤±å¿†ã€‚", aliases: ["å¤±å¿†", "å¤±æ†¶", "å®Œå…¨å¤±å¿†", "å®Œå…¨å¤±æ†¶"] },
            "æŒ‰æ‘©å‰¯ä½œç”¨": { summary: "[å‰¯ä½œç”¨] è¡ŒåŠ¨ [-]", detail: "æ·±å±‚ç»„ç»‡æåº¦é…¸ç—›ã€‚æ‰€æœ‰è¡ŒåŠ¨åœ¨ 24 å°æ—¶å†…å¸¦æœ‰ [-]ã€‚", aliases: ["æŒ‰æ‘©å‰¯ä½œç”¨", "æŒ‰æ‘©å¾Œéºç—‡"], modifiers: [{ target: "all", type: "dis" }] },
            "æ²‰æµ¸æˆç˜¾": { summary: `[åé—ç—‡]ç†æ™º-1d5(å‡å€¼ä¸ºLvæ•°)`, detail: "æ²‰æµ¸åœ¨è™šæ‹Ÿä¸–ç•Œæ— æ³•è‡ªæ‹”ï¼Œä¸ºæœŸ 1d10 å¤©ï¼Œå¤±å» 1d5 ç†æ™ºè±å…ã€‚", aliases: ["æ²‰æµ¸æˆç˜¾", "æ²‰æµ¸æˆç™®"] },
            "äººé€ è‚‰æ³¨å°„å‰¯ä½œç”¨": { summary: "æ‰€æœ‰æŠ•éª° [-]", detail: "èº«ä½“æ­£åœ¨ä»ä¾µå…¥æ€§æ‰‹æœ¯ä¸­æ¢å¤ã€‚æ‰€æœ‰æŠ•éª°åœ¨ 2 å‘¨å†…å¸¦æœ‰ [-]ï¼Œä¸”é¢å¤–éœ€è¦ 4 å‘¨è°ƒç†ã€‚", aliases: ["æ‰‹æœ¯åº·å¤", "æ‰‹è¡“åº·å¾©", "æ³¨å°„åº·å¤æœŸ"], modifiers: [{ target: "all", type: "dis" }] },
            "å¿ƒç†æ‰‹æœ¯å‰¯ä½œç”¨": { summary: "æ‰€æœ‰æŠ•éª° [-]", detail: "å¿ƒç†å±éšœæ­£åœ¨é‡å»ºã€‚æ‰€æœ‰æŠ•éª°åœ¨ 4 å‘¨å†…éƒ½ä¼šå¸¦æœ‰ [-]ã€‚", aliases: ["å¿ƒç†é‡å¡‘", "å¿ƒç†æ‰‹è¡“åº·å¾©æœŸ"], modifiers: [{ target: "all", type: "dis" }] },

            // -- å¸¸è§æŸä¼¤çŠ¶æ€ (é˜²æ­¢ .ms list æ˜¾ç¤ºæœªçŸ¥) --
            "æ°”å–˜åå": {
                summary: "[æŸä¼¤]æ‰€æœ‰[-]",
                detail: "åœ¨é¡ºè¿‡æ°”å‰éƒ½å¸¦æœ‰[ - ]",
                aliases: ["æ°”å–˜åå"],
                modifiers: [{ target: "all", type: "dis" }]
            },
            "è„šè¸æ‰­ä¼¤": {
                summary: "[æŸä¼¤]é€Ÿåº¦ [-]",
                detail: "é€Ÿåº¦æ£€å®šå¸¦æœ‰ [ - ]ã€‚",
                aliases: ["è„šè¸æ‰­ä¼¤", "è…³è¸æ‰­å‚·"],
                modifiers: [{ target: "é€Ÿåº¦", type: "dis" }]
            },
            "è„‘éœ‡è¡": {
                summary: "[æŸä¼¤]å¿ƒæ™º [-]",
                detail: "å¿ƒæ™ºç±»ä»»åŠ¡å¸¦æœ‰ [ - ]ã€‚",
                aliases: ["è„‘éœ‡è¡", "è…¦éœ‡ç›ª"],
                modifiers: [{ target: "æ™ºåŠ›", type: "dis" }]
            },
            "è…¿éƒ¨æŠ˜æ–­": {
                summary: "[æŸä¼¤]é€Ÿåº¦ [-]",
                detail: "è…¿éƒ¨æˆ–æ˜¯è„šæŠ˜æ–­ï¼Œé€Ÿåº¦æ£€å®šå¸¦æœ‰ [ - ]ã€‚",
                aliases: ["è…¿éƒ¨æŠ˜æ–­", "è…¿éƒ¨æŠ˜æ–·"],
                modifiers: [{ target: "é€Ÿåº¦", type: "dis" }]
            },
            "è‡‚éƒ¨æŠ˜æ–­": {
                summary: "[æŸä¼¤]åŠ¨æ‰‹ [-]",
                detail: "è‡‚éƒ¨æˆ–æ˜¯æ‰‹æŠ˜æ–­ï¼ŒåŠ¨æ‰‹ç±»ä»»åŠ¡å¸¦æœ‰ [ - ]ã€‚",
                aliases: ["è‡‚éƒ¨æŠ˜æ–­", "è‡‚éƒ¨æŠ˜æ–·", "æ‰‹æŠ˜æ–­"],
                modifiers: [{ target: "åŠ›é‡", type: "dis" }, { target: "æˆ˜æ–—", type: "dis" }]
            },
            "é”éª¨æŠ˜æ–­": {
                summary: "[æŸä¼¤]åŠ›é‡ [-]",
                detail: "é”éª¨æŠ˜æ–­ï¼ŒåŠ›é‡æ£€å®šå¸¦æœ‰ [ - ]ã€‚",
                aliases: ["é”éª¨æŠ˜æ–­", "é–éª¨æŠ˜æ–·"],
                modifiers: [{ target: "åŠ›é‡", type: "dis" }]
            },
            "èƒŒéƒ¨æŠ˜æ–­": {
                summary: "[æŸä¼¤]æ‰€æœ‰ [-], æ­»äº¡è±å…",
                detail: "èƒŒéƒ¨æŠ˜æ–­ã€‚æ‰€æœ‰æŠ•éª°å¸¦æœ‰ [ - ] ",
                aliases: ["è‡´å‘½åˆ›ä¼¤", "è‡´å‘½å‰µå‚·", "èƒŒéƒ¨æŠ˜æ–­"],
                modifiers: [{ target: "all", type: "dis" }]
            },
            "é¢…éª¨å¼€è£‚": {
                summary: "[æŸä¼¤]æ‰€æœ‰ [-], æ­»äº¡è±å…",
                detail: "é¢…éª¨å¼€è£‚ã€‚æ‰€æœ‰æŠ•éª°å¸¦æœ‰ [ - ] ",
                aliases: ["èƒŒéƒ¨æŠ˜æ–­"],
                modifiers: [{ target: "all", type: "dis" }]
            },
            "è¡€è’™çœ¼ç›": {
                summary: "[æŸä¼¤]è§†è§‰ [-]",
                detail: "æ“¦å¹²å‡€å‰å¸¦æœ‰ [ - ]ã€‚",
                aliases: ["è¡€è’™çœ¼ç›", "è¡€è’™çœ¼"],
                modifiers: [{ target: "all", type: "dis" }]
            },
            "æ’•è£‚ä¼¤": { summary: "å™äº‹æ€§[æŸä¼¤]", detail: "å™äº‹æ€§æ•ˆæœ,æ˜æ–‡è§„å®šçš„æ¸¸æˆæœºåˆ¶æ•ˆæœå·²ç»“ç®—", },
            "é‡åº¦å‰²ä¼¤": { summary: "å™äº‹æ€§[æŸä¼¤]", detail: "å™äº‹æ€§æ•ˆæœ,æ˜æ–‡è§„å®šçš„æ¸¸æˆæœºåˆ¶æ•ˆæœå·²ç»“ç®—", },
            "æ‰‹æŒ‡/è„šè¶¾ç è½": { summary: "å™äº‹æ€§[æŸä¼¤]", detail: "å™äº‹æ€§æ•ˆæœ,æ˜æ–‡è§„å®šçš„æ¸¸æˆæœºåˆ¶æ•ˆæœå·²ç»“ç®—", },
            "æ‰‹/è„šç è½": { summary: "å™äº‹æ€§[æŸä¼¤]", detail: "å™äº‹æ€§æ•ˆæœ,æ˜æ–‡è§„å®šçš„æ¸¸æˆæœºåˆ¶æ•ˆæœå·²ç»“ç®—", },
            "è‚¢ä½“ç è½": { summary: "å™äº‹æ€§[æŸä¼¤]", detail: "å™äº‹æ€§æ•ˆæœ,æ˜æ–‡è§„å®šçš„æ¸¸æˆæœºåˆ¶æ•ˆæœå·²ç»“ç®—", },
            "ä¸»åŠ¨è„‰å‰²ä¼¤": { summary: "å™äº‹æ€§[æŸä¼¤]", detail: "å™äº‹æ€§æ•ˆæœ,æ˜æ–‡è§„å®šçš„æ¸¸æˆæœºåˆ¶æ•ˆæœå·²ç»“ç®—", },
            "å–‰å’™å‰²å¼€æˆ–å¿ƒè„åˆºç©¿": { summary: "å™äº‹æ€§[æŸä¼¤]", detail: "å™äº‹æ€§æ•ˆæœ,æ˜æ–‡è§„å®šçš„æ¸¸æˆæœºåˆ¶æ•ˆæœå·²ç»“ç®—", },
            "è‚‹éª¨æŠ˜æ–­": { summary: "å™äº‹æ€§[æŸä¼¤]", detail: "å™äº‹æ€§æ•ˆæœ,æ˜æ–‡è§„å®šçš„æ¸¸æˆæœºåˆ¶æ•ˆæœå·²ç»“ç®—", },
            "è‚¢ä½“æ–­è£‚": { summary: "å™äº‹æ€§[æŸä¼¤]", detail: "å™äº‹æ€§æ•ˆæœ,æ˜æ–‡è§„å®šçš„æ¸¸æˆæœºåˆ¶æ•ˆæœå·²ç»“ç®—", },
            "å†…å‡ºè¡€": { summary: "å™äº‹æ€§[æŸä¼¤]", detail: "å™äº‹æ€§æ•ˆæœ,æ˜æ–‡è§„å®šçš„æ¸¸æˆæœºåˆ¶æ•ˆæœå·²ç»“ç®—", },
            "å­å¼¹åµŒå…¥éœ€è¦æ‰‹æœ¯": { summary: "å™äº‹æ€§[æŸä¼¤]", detail: "å™äº‹æ€§æ•ˆæœ,æ˜æ–‡è§„å®šçš„æ¸¸æˆæœºåˆ¶æ•ˆæœå·²ç»“ç®—", },
            "å¼€æ´æ€§èƒ¸éƒ¨æŸä¼¤": { summary: "å™äº‹æ€§[æŸä¼¤]", detail: "å™äº‹æ€§æ•ˆæœ,æ˜æ–‡è§„å®šçš„æ¸¸æˆæœºåˆ¶æ•ˆæœå·²ç»“ç®—", },
            "å¯æ€•ä¼¤ç—•": { summary: "å™äº‹æ€§[æŸä¼¤]", detail: "å™äº‹æ€§æ•ˆæœ,æ˜æ–‡è§„å®šçš„æ¸¸æˆæœºåˆ¶æ•ˆæœå·²ç»“ç®—", },
            "å¼¹ç‰‡ä¼¤/å¤§é¢ç§¯çƒ§ä¼¤": { summary: "å™äº‹æ€§[æŸä¼¤]", detail: "å™äº‹æ€§æ•ˆæœ,æ˜æ–‡è§„å®šçš„æ¸¸æˆæœºåˆ¶æ•ˆæœå·²ç»“ç®—", },
            "3 çº§çƒ§ä¼¤": { summary: "å™äº‹æ€§[æŸä¼¤]", detail: "å™äº‹æ€§æ•ˆæœ,æ˜æ–‡è§„å®šçš„æ¸¸æˆæœºåˆ¶æ•ˆæœå·²ç»“ç®—", },
            "é‡åº¦çƒ§ä¼¤": { summary: "å™äº‹æ€§[æŸä¼¤]", detail: "å™äº‹æ€§æ•ˆæœ,æ˜æ–‡è§„å®šçš„æ¸¸æˆæœºåˆ¶æ•ˆæœå·²ç»“ç®—", },
            "è‚¢ä½“ç€ç«": { summary: "[æŸä¼¤]æ¯è½® 2d10 ä¼¤å®³", detail: "è‚¢ä½“ç€ç«,æ¯è½® 2d10 ä¼¤å®³,è¯·è‡ªè¡Œç»“ç®—", },
            "èº«ä½“ç€ç«": { summary: "[æŸä¼¤]æ¯è½® 3d10 ä¼¤å®³", detail: "èº«ä½“ç€ç«,æ¯è½® 3d10 ä¼¤å®³,è¯·è‡ªè¡Œç»“ç®—", },
            "å‘•å": { summary: "[æŸä¼¤]ä¸‹ä¸ªè¡ŒåŠ¨ [ - ]", detail: "å‘•å,ä¸‹ä¸ªè¡ŒåŠ¨å¸¦æœ‰ [ - ]ã€‚", modifiers: [{ target: "all", type: "dis" }] },
            "æŒ‡éƒ¨æŸæ¯": { summary: "å™äº‹æ€§[æŸä¼¤]", detail: "å™äº‹æ€§æ•ˆæœ,æ˜æ–‡è§„å®šçš„æ¸¸æˆæœºåˆ¶æ•ˆæœå·²ç»“ç®—", },
            "çœ¼ç›æŒ–å‡º ": { summary: "å™äº‹æ€§[æŸä¼¤]", detail: "å™äº‹æ€§æ•ˆæœ,æ˜æ–‡è§„å®šçš„æ¸¸æˆæœºåˆ¶æ•ˆæœå·²ç»“ç®—", },
            "è¡€è‚‰æ’•è½": { summary: "å™äº‹æ€§[æŸä¼¤]", detail: "å™äº‹æ€§æ•ˆæœ,æ˜æ–‡è§„å®šçš„æ¸¸æˆæœºåˆ¶æ•ˆæœå·²ç»“ç®—", },
            "è‚¢ä½“ç è½": { summary: "å™äº‹æ€§[æŸä¼¤]", detail: "å™äº‹æ€§æ•ˆæœ,æ˜æ–‡è§„å®šçš„æ¸¸æˆæœºåˆ¶æ•ˆæœå·²ç»“ç®—", },
            "åˆºç©¿": { summary: "å™äº‹æ€§[æŸä¼¤]", detail: "å™äº‹æ€§æ•ˆæœ,æ˜æ–‡è§„å®šçš„æ¸¸æˆæœºåˆ¶æ•ˆæœå·²ç»“ç®—", },
            "è‚ è„æ»¡åœ°": { summary: "å™äº‹æ€§[æŸä¼¤]", detail: "å™äº‹æ€§æ•ˆæœ,æ˜æ–‡è§„å®šçš„æ¸¸æˆæœºåˆ¶æ•ˆæœå·²ç»“ç®—", },
            "å¤´éƒ¨çˆ†ç‚¸": { summary: "å™äº‹æ€§[æŸä¼¤]", detail: "å™äº‹æ€§æ•ˆæœ,æ˜æ–‡è§„å®šçš„æ¸¸æˆæœºåˆ¶æ•ˆæœå·²ç»“ç®—", },
            "çƒ§ç„¦": {
                summary: "ä¸‹ä¸ªè¡ŒåŠ¨ [-]",
                detail: "ä¸‹ä¸ªè¡ŒåŠ¨å¸¦æœ‰ [ - ],è®°å¾—ä½¿ç”¨ğŸ‘‰.ms cond rm çƒ§ç„¦ğŸ‘ˆç§»é™¤æ­¤å½±å“å“¦!",
                aliases: ["çƒ§ç„¦", "ç‡’ç„¦"],
                modifiers: [{ target: "all", type: "dis" }]
            },
            "è…°éƒ¨ä»¥ä¸‹ç˜«ç—ª": {
                summary: "æ— æ³•ç§»åŠ¨",
                detail: "è…°éƒ¨ä»¥ä¸‹ç˜«ç—ªã€‚",
                aliases: ["ç˜«ç—ª", "ç™±ç˜“", "è…°éƒ¨ä»¥ä¸‹ç˜«ç—ª"],
                modifiers: [{ target: "é€Ÿåº¦", type: "dis" }]//æ ¹æ®ç”»é£æ£æ‘©çš„
            },


            // ç”Ÿå­˜çŠ¶æ€ (Survival Conditions)
            // åŒ…å«ç¯å¢ƒã€ç”Ÿç†éœ€æ±‚ç­‰ã€‚
            // SURVIVAL_CONDITIONS: {
            "æœ‰æ¯’å¤§æ°”": { summary: "æ¯è½®èº«ä½“è±å…ï¼Œå¤±è´¥å—ä¼¤å®³", desc: "è§’è‰²æ¯å›åˆä¼šé­å— 1d10 ä¼¤å®³ï¼Œé€šè¿‡èº«ä½“è±å…å‡åŠã€‚å±æ¯æˆ–è¿‡æ»¤è£…å¤‡å¯å…ç–«ã€‚", stackable: false, aliases: ["æœ‰æ¯’å¤§æ°”", "æœ‰æ¯’å¤§æ°£", "æ¯’æ°”", "æ¯’æ°£"] },
            "è…èš€æ€§å¤§æ°”": { summary: "æŒç»­ä¼¤å®³ï¼Œéœ€è£…å¤‡é˜²æŠ¤", desc: "1 ä¼¤å®³/æ¯è½®ï¼ˆè½»è…èš€æ€§ï¼‰åˆ° 10 ä¼¤å®³/æ¯è½®ï¼ˆé«˜è…èš€æ€§ï¼‰ï¼Œä¸ä¸€è€Œè¶³ã€‚è‹¥æ˜¯åœ¨æ­¤ä¹‹ä¸Šï¼Œåˆ™æ²¡æœ‰ä¸“é—¨çš„è£…å¤‡å’ŒæŠ¤ç”²å°±æ ¹æœ¬æ— æ³•å®‰å…¨å‰è¡Œã€‚", stackable: false, aliases: ["è…èš€æ€§å¤§æ°”", "è…èš€", "è…è•"] },
            "å‡ºè¡€": { summary: "æ¯å±‚é€ æˆ 1 ä¼¤å®³/è½®,Lvä¸ºå±‚æ•°", desc: "[å‡ºè¡€]åœæ­¢ä¹‹å‰æ¯è½®éƒ½ä¼šé­å— 1 ä¼¤å®³ã€‚[å‡ºè¡€]ä¼šå åŠ ã€‚è‹¥æ˜¯è§’è‰²æ¯è½®é­å— 1 å‡ºè¡€ä¼¤å®³ï¼Œå¹¶ä¸”åˆè·å¾—[å‡ºè¡€]+1ï¼Œç°åœ¨å…¶æ¯è½®éƒ½ä¼šé­å—2ä¼¤å®³ã€‚æ­¤å¤–ï¼Œå‡ºè¡€ä¼¤å®³æ— è§†æŠ¤ç”²å’Œä¼¤å®³å‡å…ã€‚", stackable: true, aliases: ["å‡ºè¡€"] },
            "çŠ¯ä½æ¸©": { summary: "å±æ€§æ£€å®š [-]ï¼Œéœ€æ²»ç–—", desc: "ä½æ¸©ä¼‘çœ è‹é†’åçš„ç—‡çŠ¶,ä¸€å‘¨å†…çš„æ‰€æœ‰æŠ•éª°éƒ½ä¼šå¸¦æœ‰ [ - ]ã€‚ã€‚å¯ä½¿ç”¨å…´å¥‹è¯(.ms use stim)æ²»ç–—æˆ–å‡çº§ä½æ¸©å®¤ã€‚", stackable: false, aliases: ["çŠ¯ä½æ¸©", "å¤±æ¸©", "å†»ç»“", "çŠ¯ä½æº«", "å¤±æº«", "å‡çµ"] },
            "ç–²æƒ«": { summary: "é•¿æ—¶é—´æ´»åŠ¨ï¼Œæ£€å®š [-]", desc: "æ´»åŠ¨ 12 ä¸ªå°æ—¶åï¼Œæ¯å°æ—¶è¿›è¡Œä¸€æ¬¡èº«ä½“è±å…æ¥è®°å½•ç–²æƒ«ç¨‹åº¦ã€‚è‹¥æ˜¯å¤±è´¥å°±ä¼šè·å¾— 1 å‹åŠ›å¹¶é­å— 1 ä¼¤å®³ã€‚ç–²æƒ« 24 å°æ—¶åï¼Œæ‰€æœ‰æŠ•éª°éƒ½ä¼šå¸¦æœ‰åŠ£åŠ¿ï¼Œç›´åˆ°è§’è‰²èƒ½ä¼‘æ¯ 8 å°æ—¶ä¸ºæ­¢ã€‚", stackable: false, aliases: ["ç–²æƒ«", "ç–²æ†Š"] },
            "é£Ÿç‰©": { summary: "24hæœªè¿›é£Ÿæ£€å®š [-]", desc: "äººç±»å¯ä»¥åœ¨æ²¡æœ‰è¿›é£Ÿçš„æƒ…å†µä¸‹ç”Ÿå­˜å¤§çº¦ 3 å‘¨ã€‚åœ¨ 24 å°æ—¶æ²¡æœ‰è¿›é£Ÿåï¼Œæ‰€æœ‰æŠ•éª°éƒ½å¸¦æœ‰åŠ£åŠ¿ã€‚", stackable: false, aliases: ["é£Ÿç‰©", "é¥¥é¥¿", "é£¢é¤“"] },
            "æ°´": { summary: "ç¼ºæ°´æ˜è¿·æˆ–æ£€å®š [-]", desc: "ä½ æ¯å¤©éƒ½éœ€è¦ 1 å‡æ°´ã€‚ ç„¶è€Œï¼Œè¿™ç§æƒ…å†µä¸‹ä»»ä½•å‰§çƒˆæ´»åŠ¨ï¼ˆè­¬å¦‚å¥”è·‘ã€ æˆ˜æ–—ã€è¿›è¡Œæœºæ¢°ä¿®ç†ï¼‰ éƒ½ä¼šè¿«ä½¿ä½ è¦é€šè¿‡ä¸€æ¬¡ èº«ä½“è±å…ï¼Œå¦åˆ™å°±ä¼šæ˜è¿·ã€‚è‹¥æ˜¯æ°´æºç¨€ç¼ºï¼Œè€Œä½ åˆè¦ä¸¥æ ¼è®°å½•æ—¶ï¼Œæ‰€æœ‰æŠ•éª°éƒ½ä¼šå¸¦æœ‰åŠ£åŠ¿ã€‚", stackable: false, aliases: ["æ°´", "è„±æ°´", "è„«æ°´"] },
            "æ°§æ°”": { summary: "è€—å°½åå­˜æ´» 1d5 åˆ†é’Ÿ", desc: "ä½ èƒ½åœ¨æ²¡æœ‰æ°§æ°”çš„æƒ…å†µä¸‹åšæŒ 15 ç§’ï¼Œæ¥ç€æ˜è¿·è¿‡å»ï¼Œå­˜æ´» 1d5 åˆ†é’Ÿåæ­»äº¡. è‹¥æ˜¯æ•´è‰˜èˆ¹çš„æ‰€æœ‰ç»´ç”Ÿç³»ç»Ÿç¦»çº¿ï¼ŒæŠ• 1d10ï¼Œç„¶å å°†ç»“æœä¹˜ä»¥æ­è½½ä¹˜ç»„ä¸Šé™ï¼Œå¾—å‡ºå‰©ä½™çš„æ°§æ°”ä¾› ç»™. è¯¦è§è§„åˆ™ä¹¦33.1", stackable: false, aliases: ["æ°§æ°”", "ç¼ºæ°§", "çª’æ¯", "æ°§æ°£"] },
            "è½»åº¦è¾å°„-1": { summary: "é•¿æœŸå‰¯ä½œç”¨", desc: "ç­‰çº§ 1-è½»åº¦ æ™®é€šå¸¸è§çš„è¾å°„ã€å®‡å®™å°„çº¿  ä¼¤å®³éå³æ—¶ï¼Œå¯èƒ½æœ‰é•¿æœŸå‰¯ä½œç”¨ï¼ˆç™Œç—‡ç­‰ï¼‰ã€‚", stackable: false, aliases: ["è½»åº¦è¾å°„", "è¾å°„1", "è¼»å°„1"] },
            "é‡åº¦è¾å°„-2": { summary: "æ¯è½®å±æ€§/è±å… -1", desc: "ç­‰çº§ 2-é‡åº¦ æœªå±è”½ååº”å †/æ›²é€Ÿæ ¸å¿ƒ æ¯è½®æ‰€æœ‰å±æ€§å’Œè±å…-1ã€‚ ", stackable: false, aliases: ["é‡åº¦è¾å°„", "è¾å°„2", "è¼»å°„2"] },
            "è‡´å‘½è¾å°„-3": { summary: "èº«ä½“è±å…æˆ– 1d5 å¤©æ­»äº¡", desc: "ç­‰çº§ 3-è‡´å‘½ æ ¸å­æ­¦å™¨ï¼Œç›´æ¥æ“ä½œæ›²é€Ÿæ ¸å¿ƒæ¯è½®ï¼šé€šè¿‡èº«ä½“è±å…ï¼Œå¦åˆ™é­å—è‡´å‘½å‰‚é‡ï¼ˆ1d5 å¤©å†…æ­»äº¡ï¼‰ã€‚", stackable: false, aliases: ["è‡´å‘½è¾å°„", "è¾å°„3", "è¼»å°„3"] },
            "æç«¯å¯’å†·": { summary: "æ¯å°æ—¶èº«ä½“è±å…", desc: "å¤„äºé›¶åº¦ä»¥ä¸‹æ—¶ï¼Œç©¿ç€ä¸å½“çš„äººå‘˜ä¼šåœ¨ 10 åˆ° 30 åˆ†é’Ÿå†…é­å—å¤±æ¸©å’Œå†»ä¼¤ã€‚ä½ éƒ½è¦æ¯å°æ—¶é€šè¿‡ä¸€æ¬¡èº«ä½“è±å…ï¼Œå¦åˆ™å°±ä¼šé­å—æç«¯å¯’å†·çš„å½±å“ã€‚ä¸ºäº†ç”Ÿå­˜ï¼Œä½ å¿…é¡»è®©ä½“æ¸©æ¢å¤æ­£å¸¸ã€‚å¤±æ¸©ä¼šåœ¨ 30 åˆ†é’Ÿ ä¹ƒè‡³ 6 å°æ—¶å†…è¦äºº æ€§å‘½ã€‚", stackable: false, aliases: ["ä½æ¸©", "ä½æº«", "å¯’å†·"] },
            "æç«¯ç‚çƒ­": { summary: "æ¯å°æ—¶èº«ä½“è±å…", desc: "100ÂºF/40ÂºC ä»¥ä¸Šçš„æç«¯ç‚çƒ­ä¼šå¯¼è‡´ä¸­æš‘ï¼Œå¹¶åœ¨æ•°å°æ—¶å†…è¦äººæ€§å‘½ã€‚ä½ éƒ½è¦æ¯å°æ—¶é€šè¿‡ä¸€æ¬¡èº«ä½“è±å…ï¼Œå¦åˆ™å°±ä¼šé­å—æç«¯ç‚çƒ­çš„å½±å“ã€‚å—å®³è€…å¿…é¡»ç«‹åˆ»è½¬ç§»åˆ°å‡‰çˆ½çš„åœ°æ–¹æ¥é™ä½ä½“æ¸©", stackable: false, aliases: ["é«˜æ¸©", "é«˜æº«", "ç‚çƒ­"] },
            "å…´å¥‹è¯è¿‡é‡": { summary: "è‹¥æ‘„å…¥>1d10åˆ™æ­»äº¡è±å…", desc: "è¯ç‰©æ‘„å…¥è¿‡å¤šã€‚å¦‚æœæ‘„å…¥é‡ > 1d10ï¼Œè§¦å‘æ­»äº¡è±å…ã€‚", stackable: true, aliases: ["å…´å¥‹è¯è¿‡é‡", "è¯ç‰©è¿‡é‡", "èˆˆå¥®è—¥éé‡", "è—¥ç‰©éé‡"] },
            "å…´å¥‹": { summary: "æ‰€æœ‰æŠ•éª° [+]", desc: "{duration}å†…æ‰€æœ‰æŠ•éª°å¸¦æœ‰ [+]", rollInit: "1d10åˆ†é’Ÿ", stackable: false, aliases: ["å…´å¥‹", "èˆˆå¥®"], modifiers: [{ target: "all", type: "adv" }] },
        },

        // ç‰©å“åº“ (Items)
        ITEMS: {
            "stim": {
                name: "å…´å¥‹è¯",
                desc: "æ¶ˆé™¤[çŠ¯ä½æ¸©]å’Œ[ç–²æƒ«]ï¼›HP+1d10ï¼›å‹åŠ›-1ï¼›æŠ•éª°[+]æŒç»­1d10åˆ†é’Ÿã€‚è‹¥24hå†…ä½¿ç”¨é‡è¶…è¿‡1d10åˆ™æ­»äº¡è±å…ã€‚",
                aliases: ["stim", "stimpak", "å…´å¥‹è¯", "å…´å¥‹å‰‚", "èˆˆå¥®è—¥", "èˆˆå¥®åŠ‘"],
                use: (mctx) => {
                    const intakeVar = seal.vars.intGet(mctx, "å…´å¥‹è¯æ‘„å…¥");
                    const oldIntake = intakeVar[1] ? intakeVar[0] : 0;
                    const newIntake = oldIntake + 1;
                    seal.vars.intSet(mctx, "å…´å¥‹è¯æ‘„å…¥", newIntake);
                    MSRules.manageCondition(mctx, "remove", "çŠ¯ä½æ¸©");
                    MSRules.manageCondition(mctx, "remove", "å¤±æº«");
                    MSRules.manageCondition(mctx, "remove", "ç–²æƒ«");
                    const stressRes = MSRules.updateStress(mctx, -1, "ä½¿ç”¨å…´å¥‹è¯");
                    const heal = Math.floor(Math.random() * 10) + 1;
                    const hp = seal.vars.intGet(mctx, "ç”Ÿå‘½å€¼")[0];
                    const maxHp = seal.vars.intGet(mctx, "ç”Ÿå‘½å€¼ä¸Šé™")[0] || 10;
                    let newHp = hp + heal;
                    if (newHp > maxHp) newHp = maxHp;
                    seal.vars.intSet(mctx, "ç”Ÿå‘½å€¼", newHp);
                    const dur = Math.floor(Math.random() * 10) + 1;
                    MSRules.manageCondition(mctx, "add", "å…´å¥‹", { duration: `${dur}åˆ†é’Ÿ` });
                    const checkRoll = Math.floor(Math.random() * 10) + 1;
                    let overdoseWarning = "";
                    if (checkRoll < newIntake) {
                        overdoseWarning = `\nğŸ’€ã€è¯ç‰©è¿‡é‡ã€‘1d10(${checkRoll}) < æ‘„å…¥é‡(${newIntake})ï¼\nâ—è¯·ç«‹å³è¿›è¡Œæ­»äº¡è±å…ï¼`;
                        MSRules.manageCondition(mctx, "add", "å…´å¥‹è¯è¿‡é‡", newIntake);
                    }
                    let msg = `ä½¿ç”¨äº†å…´å¥‹è¯ (æ‘„å…¥é‡: ${oldIntake} -> ${newIntake})ã€‚\n`;
                    msg += `> å·²ç§»é™¤ã€çŠ¯ä½æ¸©/ç–²æƒ«ã€‘ï¼Œæ·»åŠ ã€å…´å¥‹ã€‘çŠ¶æ€ã€‚\n`;
                    msg += `> å‹åŠ› -1 (å½“å‰: ${stressRes.newVal})ï¼Œç”Ÿå‘½ +${heal} (å½“å‰: ${newHp}/${maxHp})\n`;
                    msg += `>[å…´å¥‹]å»¶æ—¶æ€§å½±å“æŒç»­æ—¶é—´ ${dur}åˆ†é’Ÿ`;
                    msg += `> è€å—æ€§æ£€æµ‹: 1d10=${checkRoll}${overdoseWarning}`;
                    return msg;
                }
            }
        },

        // åŒ»ç–—æŠ¤ç†ç³»ç»Ÿ (Medical Care)
        // åŒ…å«ï¼šè´¹ç”¨ã€è€—æ—¶ã€æè¿°ã€æ•ˆæœå®ç°å‡½æ•°
        MEDICAL_CARE: {
            "äººé€ å¥åº·é¡¾é—®": {
                name: "äººé€ å¥åº·é¡¾é—®",
                cost: "150cr", time: "1å°æ—¶",
                desc: "æ¢å¤ 1 ç†æ™ºè±å…ã€‚1% æ¦‚ç‡è·å¾—éšæœºçŠ¶æ€ã€‚",
                aliases: ["ai", "consultant", "å¥åº·é¡¾é—®", "é¡¾é—®", "é¡§å•", "äººé€ å¥åº·é¡§å•", "å¥åº·é¡§å•", "äººé€ å¥åº·é¡¾é—®"],
                apply: (mctx) => {
                    const oldVal = seal.vars.intGet(mctx, "ç†æ™º")[0];
                    seal.vars.intSet(mctx, "ç†æ™º", oldVal + 1);
                    let msg = `ç†æ™ºè±å… +1 (å½“å‰: ${oldVal + 1})ã€‚`;
                    const roll = Math.floor(Math.random() * 100) + 1;
                    // const roll=1;
                    msg += `\nğŸ² é£é™©æŠ•éª°(1d100): ${roll}`;
                    if (roll === 1) {

                        const randIdx = Math.floor(Math.random() * MS_CONSTS.PANIC_CONDITIONS.length);
                        const randCondName = MS_CONSTS.PANIC_CONDITIONS[randIdx];
                        MSRules.manageCondition(mctx, "add", randCondName);
                        msg += `ğŸ¤•è·å¾—çŠ¶æ€ã€${randCondName}ã€‘,æ•ˆæœ${MS_CONSTS.CONDITIONS[randCondName].summary}\n`;
                        return { msg, hasSideEffect: true };

                    } else msg += ` (å®‰å…¨)`;
                    return { msg, hasSideEffect: false };
                }
            },
            "è®¤çŸ¥ç¢ç‰‡æ•´ç†": {
                name: "è®¤çŸ¥ç¢ç‰‡æ•´ç†",
                cost: "100kcr", time: "24å°æ—¶",
                desc: "ç§»é™¤ä¸€é¡¹çŠ¶æ€ã€‚è·å¾—çŠ¶æ€[è®¤çŸ¥ç¢ç‰‡æ•´ç†å‰¯ä½œç”¨](æ™º&ç†&æ4å‘¨[-])ã€‚1%æ¦‚ç‡[å®Œå…¨å¤±å¿†]ã€‚",
                aliases: ["ç¢ç‰‡", "defrag", "ç¢ç‰‡æ•´ç†", "èªçŸ¥ç¢ç‰‡æ•´ç†", "æ•´ç†", "è®¤çŸ¥ç¢ç‰‡", "èªçŸ¥ç¢ç‰‡", "è®¤çŸ¥ç¢ç‰‡æ•´ç†"],
                apply: (mctx) => {
                    MSRules.manageCondition(mctx, "add", "è®¤çŸ¥ç¢ç‰‡æ•´ç†å‰¯ä½œç”¨", { duration: "4å‘¨" });
                    let msg = `ğŸ¤• è·å¾—: ã€è®¤çŸ¥ç¢ç‰‡æ•´ç†å‰¯ä½œç”¨ã€‘(æ™ºåŠ›/ç†æ™º/ææƒ§ 4å‘¨å†…[-])ã€‚\nâœ… æ²»ç–—å®Œæˆã€‚è¯·ç©å®¶æ‰‹åŠ¨ç§»é™¤ä¸€é¡¹æŒ‡å®š[çŠ¶æ€](åªèƒ½ç§»é™¤å¸¦æœ‰'[çŠ¶æ€]'çš„å»¶æ—¶æ€§å½±å“) ğŸ‘‰.ms cond rm <åç§°>ã€‚`;

                    const roll = Math.floor(Math.random() * 100) + 1;
                    // const roll=1;
                    msg += `\nğŸ² é£é™©æŠ•éª°(1d100): ${roll}`;
                    if (roll === 1) {
                        MSRules.manageCondition(mctx, "add", "å®Œå…¨å¤±å¿†");
                        msg += `\nğŸ’€ [å‰¯ä½œç”¨] æ‰‹æœ¯ä¸¥é‡å¤±è¯¯! è·å¾—çŠ¶æ€ã€å®Œå…¨å¤±å¿†ã€‘ã€‚`;
                        return { msg, hasSideEffect: true };

                    } else msg += ` (æœªå¤±å¿†)`;
                    return { msg, hasSideEffect: false };
                }
            },
            "æ·±å±‚ç»„ç»‡çº³ç±³å‡èƒ¶æŒ‰æ‘©": {
                name: "æ·±å±‚ç»„ç»‡çº³ç±³å‡èƒ¶æŒ‰æ‘©",
                cost: "24kcr", time: "1å°æ—¶",
                desc: "å‹åŠ›ä¸‹é™é™ä½ 1ã€‚è·å¾—çŠ¶æ€[æŒ‰æ‘©å‰¯ä½œç”¨](24hè¡ŒåŠ¨[-])ã€‚",
                aliases: ["nm", "massage", "æŒ‰æ‘©", "æ·±å±‚æŒ‰æ‘©", "æ·±å±¤çµ„ç¹”ç´ç±³å‡è† æŒ‰æ‘©", "ç´ç±³å‡è† æŒ‰æ‘©", "æ·±å±‚ç»„ç»‡", "æ·±å±¤çµ„ç¹”", "æ·±å±‚ç»„ç»‡çº³ç±³å‡èƒ¶æŒ‰æ‘©"],
                apply: (mctx) => {
                    const oldMin = seal.vars.intGet(mctx, "å‹åŠ›ä¸‹é™")[0];
                    const newMin = Math.max(0, oldMin - 1);
                    seal.vars.intSet(mctx, "å‹åŠ›ä¸‹é™", newMin);
                    MSRules.manageCondition(mctx, "add", "æŒ‰æ‘©å‰¯ä½œç”¨");
                    return { msg: `å‹åŠ›ä¸‹é™ -1 (å½“å‰: ${newMin})ã€‚\nğŸ¤• è·å¾—çŠ¶æ€: ã€æŒ‰æ‘©å‰¯ä½œç”¨ã€‘(24hå†…è¡ŒåŠ¨[-])`, hasSideEffect: false };
                }
            },
            "æ²‰æµ¸æ¶ˆé£ç–—æ³•": {
                name: "æ²‰æµ¸æ¶ˆé£ç–—æ³•",
                cost: "1kcr", time: "4å°æ—¶",
                desc: "æ¢å¤ 1d10 æˆ˜æ–— æˆ– 1d10 ææƒ§è±å…ã€‚1% æ¦‚ç‡[æ²‰æµ¸æˆç˜¾]ã€‚",
                aliases: ["vr", "hobby", "æ¶ˆé£", "ç–—æ³•", "æ²‰æµ¸", "æ²‰æµ¸æ¶ˆé£ç™‚æ³•", "æ¶ˆé£ç™‚æ³•", "æ²‰æµ¸æ¶ˆé£ç–—æ³•"],
                apply: (mctx) => {
                    const val = Math.floor(Math.random() * 10) + 1;
                    let msg = `ğŸ² æ¢å¤é‡æŠ•æ·(1d10): ${val}ã€‚\nâœ… æ²»ç–—å®Œæˆã€‚è¯·ç©å®¶æ‰‹åŠ¨å°†æ­¤æ•°å€¼åŠ åˆ°ã€æˆ˜æ–—ã€‘æˆ–ã€ææƒ§ã€‘è±å…ä¸Š ğŸ‘‰.st æˆ˜æ–—+${val}ã€‚`;

                    const roll = Math.floor(Math.random() * 100) + 1;
                    // const roll=1;
                    msg += `\nğŸ² é£é™©æŠ•éª°(1d100): ${roll}`;
                    if (roll === 1) {
                        const sanLoss = Math.floor(Math.random() * 5) + 1;
                        const days = Math.floor(Math.random() * 10) + 1;
                        seal.vars.intSet(mctx, "ç†æ™º", seal.vars.intGet(mctx, "ç†æ™º")[0] - sanLoss);
                        MSRules.manageCondition(mctx, "add", "æ²‰æµ¸æˆç˜¾", { duration: `${days}å¤©`, val: sanLoss });
                        msg += `\nâš ï¸ [å‰¯ä½œç”¨] æ— æ³•è‡ªæ‹”! è·å¾—çŠ¶æ€ã€æ²‰æµ¸æˆç˜¾ã€‘(æŒç»­${days}å¤©, ç†æ™º-${sanLoss})ã€‚`;
                        msg += `å»ºè®®æŒ‡ä»¤ğŸ‘‰.st ç†æ™º-${sanLoss}`
                        return { msg, hasSideEffect: true };

                    } else msg += ` (å®‰å…¨)`;
                    return { msg, hasSideEffect: false };
                }
            },
            "åŒ»ç–—èˆ±": {
                name: "åŒ»ç–—èˆ±",
                cost: "6kcr", time: "1å‘¨",
                desc: "æ¢å¤ 1 ä¸ª[æŸä¼¤]ã€‚å¯ä»¥å°†å»¶æ—¶æ€§å½±å“å½“ä¸­çš„ä¸€ä¸ª[æŸä¼¤]ç§»é™¤",
                aliases: ["pod", "åŒ»ç–—", "medpod", "åŒ»ç–—èˆ±", "é†«ç™‚è‰™", "åŒ»ç–—ä»“"],
                apply: (mctx) => {
                    const w = seal.vars.intGet(mctx, "æŸä¼¤")[0];
                    if (w > 0) {
                        seal.vars.intSet(mctx, "æŸä¼¤", w - 1);
                        return { msg: `æŸä¼¤ -1 (å½“å‰: ${w - 1})ã€‚`, hasSideEffect: false };
                    }
                    return { msg: "å½“å‰æ— æŸä¼¤ã€‚", hasSideEffect: false };
                }
            },
            "äººé€ è‚‰æ³¨å°„": {
                name: "äººé€ è‚‰æ³¨å°„",
                cost: "18kcr", time: "8å°æ—¶",
                desc: "æ¢å¤ 2d10 [é€Ÿåº¦/åŠ›é‡/èº«ä½“] æˆ– æ¢å¤æ‰€æœ‰æŸä¼¤ã€‚è·å¾—çŠ¶æ€[äººé€ è‚‰æ³¨å°„å‰¯ä½œç”¨](2å‘¨[-] + 4å‘¨è°ƒç†)ã€‚",
                aliases: ["è‚‰", "æ³¨å°„", "injection", "äººé€ è‚‰", "äººé€ è‚‰æ³¨å°„",],
                apply: (mctx) => {
                    const val = Math.floor(Math.random() * 10) + 1 + Math.floor(Math.random() * 10) + 1;
                    MSRules.manageCondition(mctx, "add", "äººé€ è‚‰æ³¨å°„å‰¯ä½œç”¨", { duration: `2å‘¨` });
                    return { msg: `ğŸ² æ¢å¤é‡æŠ•æ·(2d10): ${val}ã€‚\nğŸ¤• è·å¾—çŠ¶æ€: ã€äººé€ è‚‰æ³¨å°„å‰¯ä½œç”¨ã€‘(2å‘¨[-] + 4å‘¨è°ƒç†)ã€‚\nâœ… æ²»ç–—å®Œæˆã€‚è¯·ç©å®¶æ‰‹åŠ¨é€‰æ‹©ä¸€é¡¹æ‰§è¡Œ:\n1. æ¢å¤ ${val} ç‚¹ [é€Ÿåº¦/åŠ›é‡/èº«ä½“]ğŸ‘‰.ms st [å±æ€§]+${val}\n2. æ¢å¤æ‰€æœ‰æŸä¼¤ğŸ‘‰.ms st æŸä¼¤0`, hasSideEffect: false };
                }
            },
            "å¿ƒç†æ‰‹æœ¯": {
                name: "å¿ƒç†æ‰‹æœ¯",
                cost: "28kcr", time: "8å°æ—¶",
                desc: "æ™ºåŠ›/ç†æ™º/ææƒ§æ¢å¤è‡³ä¸Šé™ï¼Œæˆ–å‹åŠ›ä¸‹é™é™è‡³2ã€‚è·å¾—çŠ¶æ€[å¿ƒç†æ‰‹æœ¯å‰¯ä½œç”¨](4å‘¨[-])ã€‚",
                aliases: ["å¿ƒ", "å¿ƒç†æ‰‹æœ¯", "psychosurgery", "å¿ƒç†æ‰‹è¡“", "æ‰‹æœ¯", "æ‰‹è¡“", "å¿ƒé‡Œæ‰‹æœ¯"],
                apply: (mctx) => {
                    MSRules.manageCondition(mctx, "add", "å¿ƒç†æ‰‹æœ¯å‰¯ä½œç”¨", { duration: `4å‘¨` });
                    return { msg: `ğŸ¤• è·å¾—çŠ¶æ€: ã€å¿ƒç†æ‰‹æœ¯å‰¯ä½œç”¨ã€‘(4å‘¨[-])ã€‚\nâœ… æ²»ç–—å®Œæˆã€‚è¯·ç©å®¶æ‰‹åŠ¨é€‰æ‹©ä¸€é¡¹æ‰§è¡Œ:\n1. å°† [æ™ºåŠ›/ç†æ™º/ææƒ§] æ¢å¤è‡³ä¸Šé™ğŸ‘‰.ms st [å±æ€§][æ¢å¤åˆ°çš„å€¼]\n2. å°† [å‹åŠ›ä¸‹é™] é‡ç½®ä¸º 2ğŸ‘‰.ms st å‹åŠ›ä¸‹é™2`, hasSideEffect: false };
                }
            }
        },

        // æƒŠæè¡¨ (å®Œæ•´æ–‡æœ¬)
        PANIC_TABLE: {
            1: {
                desc: "ã€è‚¾ä¸Šè…ºç´ æ¿€å¢ã€‘ä¹‹å {duration} å†…æ‰€æœ‰æŠ•éª°å¸¦æœ‰ [ + ]ï¼Œå‹åŠ›å‡å°‘ 1d5ã€‚",
                effects: [
                    { type: "condition_add", key: "è‚¾ä¸Šè…ºç´ æ¿€å¢", duration: "2d10 åˆ†é’Ÿ" },
                    { type: "resource", key: "å‹åŠ›", op: "sub", val: "1d5" }
                ]
            },
            2: {
                desc: "ã€ç´§å¼ ã€‘è·å¾— 1 å‹åŠ›ã€‚",
                effects: [
                    { type: "resource", key: "å‹åŠ›", op: "add", val: 1 }
                ]
            },
            3: {
                desc: "ã€ç¥ç»è´¨ã€‘è·å¾— 1 å‹åŠ›ï¼Œæ‰€æœ‰è¿‘è·ä¹˜ç»„è·å¾— 2 å‹åŠ›ã€‚",
                effects: [
                    { type: "resource", key: "å‹åŠ›", op: "add", val: 1 }
                    // é˜Ÿå‹å‹åŠ›çš„è°ƒæ•´é€šå¸¸ç”± GM åè°ƒæˆ–å¹¿æ’­æ¶ˆæ¯æç¤ºï¼Œæ­¤å¤„ä»…å¤„ç†è§¦å‘è€…
                ]
            },
            4: {
                desc: "ã€ä¸çŸ¥æ‰€æªã€‘ä¹‹å {duration} å†…æ‰€æœ‰æŠ•éª°å¸¦æœ‰ [ - ]ï¼Œå‹åŠ›ä¸‹é™æå‡ 1ã€‚",
                effects: [
                    { type: "condition_add", key: "ä¸çŸ¥æ‰€æª", duration: "1d10 åˆ†é’Ÿ" },
                    { type: "resource", key: "å‹åŠ›ä¸‹é™", op: "add", val: 1 }
                ]
            },
            5: {
                desc: "ã€æ‡¦å¼±ã€‘è·å¾—ä¸€é¡¹æ–°çŠ¶æ€ï¼š{condition}ã€‚",
                effects: [
                    { type: "condition_add", key: "æ‡¦å¼±" }
                ]
            },
            6: {
                desc: "ã€å—æƒŠã€‘è·å¾—ä¸€é¡¹æ–°çŠ¶æ€ï¼š{condition}ã€‚",
                effects: [
                    { type: "condition_add", key: "ææƒ§ç—‡" }
                ]
            },
            7: {
                desc: "ã€æ¢¦é­‡ã€‘è·å¾—ä¸€é¡¹æ–°çŠ¶æ€ï¼š{condition}ã€‚",
                effects: [
                    { type: "condition_add", key: "æ¢¦é­‡" }
                ]
            },
            8: {
                desc: "ã€å¤±å»è‡ªä¿¡ã€‘è·å¾—ä¸€é¡¹æ–°çŠ¶æ€ï¼š{condition}ã€‚",
                effects: [
                    { type: "condition_add", key: "å¤±å»è‡ªä¿¡" }
                ]
            },
            9: {
                desc: "ã€æ³„æ°”ã€‘è·å¾—ä¸€é¡¹æ–°çŠ¶æ€ï¼š{condition}ã€‚",
                effects: [
                    { type: "condition_add", key: "æ³„æ°”" }
                ]
            },
            10: {
                desc: "ã€å¤§éš¾ä¸´å¤´ã€‘è·å¾—ä¸€é¡¹æ–°çŠ¶æ€ï¼š{condition}ã€‚",
                effects: [
                    { type: "condition_add", key: "å¤§éš¾ä¸´å¤´" }
                ]
            },
            11: {
                desc: "ã€å¤šç–‘ã€‘è·å¾—ä¸€é¡¹æ–°çŠ¶æ€ï¼š{condition}ã€‚",
                effects: [
                    { type: "condition_add", key: "å¤šç–‘", duration: "ä¸€å‘¨" }
                ]
            },
            12: {
                desc: "ã€ä½œç¥Ÿã€‘è·å¾—ä¸€é¡¹æ–°çŠ¶æ€ï¼š{condition}ã€‚",
                effects: [
                    { type: "condition_add", key: "ä½œç¥Ÿ" }
                ]
            },
            13: {
                desc: "ã€ä½œæ­»ã€‘è·å¾—ä¸€é¡¹æ–°çŠ¶æ€ï¼š{condition}ã€‚",
                effects: [
                    { type: "condition_add", key: "ä½œæ­»", duration: "24å°æ—¶" }
                ]
            },
            14: {
                desc: "ã€é¢„çŸ¥å¼‚è±¡ã€‘è§’è‰²ç«‹åˆ»ä½“éªŒä¸€æ¬¡å…³äºå°†ä¸´ææ€–æˆ–æ˜¯å¯æ€–äº‹ä»¶çš„æ¿€çƒˆå¹»è§‰/å¼‚è±¡ã€‚å‹åŠ›ä¸‹é™æå‡ +2ã€‚",
                effects: [
                    { type: "resource", key: "å‹åŠ›ä¸‹é™", op: "add", val: 2 }
                ]
            },
            15: {
                desc: "ã€ç´§å¼ ç—‡ã€‘{duration} é‡Œå˜å¾—æ¯«æ— ååº”ï¼Œå‘†è‹¥æœ¨é¸¡ã€‚å‡å°‘ 1d10 å‹åŠ›ã€‚",
                effects: [
                    { type: "condition_add", key: "ç´§å¼ ç—‡", duration: "2d10 åˆ†é’Ÿ" },
                    { type: "resource", key: "å‹åŠ›", op: "sub", val: "1d10" }
                ]
            },
            16: {
                desc: "ã€ç‹‚æš´ã€‘ä¹‹å {duration} å†…ï¼Œæ‰€æœ‰ä¼¤å®³æŠ•éª°å¸¦æœ‰ [ + ]ã€‚æ‰€æœ‰ä¹˜ç»„è·å¾— 1 å‹åŠ›ã€‚",
                effects: [
                    { type: "condition_add", key: "ç‹‚æš´", duration: "1d10 å°æ—¶" },
                    { type: "resource", key: "å‹åŠ›", op: "add", val: 1 }
                ]
            },
            17: {
                desc: "ã€æ²¦é™·ã€‘è·å¾—ä¸€é¡¹æ–°çŠ¶æ€ï¼š{condition}ã€‚",
                effects: [
                    { type: "condition_add", key: "æ²¦é™·" }
                ]
            },
            18: {
                desc: "ã€å¤åˆé—®é¢˜ã€‘æŒ‰ç…§æ­¤è¡¨æŠ•éª°ä¸¤æ¬¡ã€‚å‹åŠ›ä¸‹é™æå‡ 1ã€‚",
                effects: [
                    { type: "resource", key: "å‹åŠ›ä¸‹é™", op: "add", val: 1 },
                    { type: "function", name: "ROLL_TWICE_PANIC" }
                ]
            },
            19: {
                desc: "ã€å¿ƒè„ç—…å‘/çŸ­è·¯ã€‘æŸä¼¤ä¸Šé™é™ä½1ã€‚{duration} å†…æ‰€æœ‰æŠ•éª°å¸¦æœ‰ [ - ]ã€‚å‹åŠ›ä¸‹é™æå‡ 1ã€‚",
                effects: [
                    { type: "resource", key: "å‹åŠ›ä¸‹é™", op: "add", val: 1 },
                    { type: "resource", key: "æŸä¼¤ä¸Šé™", op: "sub", val: 1 },
                    { type: "condition_add", key: "å¿ƒè„ç—…å‘/çŸ­è·¯", duration: "1d10 å°æ—¶" }
                ]
            },
            20: {
                desc: "ã€é€€åœºã€‘æŠ•ä¸ªæ–°è§’è‰²æ¥å‚åŠ æ¸¸æˆã€‚",
                effects: []
            }
        },

        // æŸä¼¤è¡¨ (Wound Table)
        // ç»“æ„å‡çº§ï¼šå¢åŠ  sev (ä¸¥é‡åº¦), death (æ˜¯å¦æ­»äº¡è±å…), delay (æ˜¯å¦å»¶è¿Ÿè±å…)
        WOUND_TABLE: {
            "blunt": {
                name: "é’å‡»",
                aliases: ["é’å‡»", "blunt", "b", "éˆæ“Š","é’"],
                table: [
                    { sev: "çš®è‚‰æŸä¼¤", desc: "å‡»å€’ã€‚", cond: "å‡»å€’", effects: [{ type: "condition_add", key: "å‡»å€’" }] },
                    { sev: "è½»åº¦åˆ›ä¼¤", desc: "æ°”å–˜ååï¼Œåœ¨é¡ºè¿‡æ°”å‰éƒ½å¸¦æœ‰ [-]ã€‚", cond: "æ°”å–˜åå", effects: [{ type: "condition_add", key: "æ°”å–˜åå" }] },
                    { sev: "è½»åº¦åˆ›ä¼¤", desc: "è„šè¸æ‰­ä¼¤ï¼Œé€Ÿåº¦æ£€å®šå¸¦æœ‰ [-]ã€‚", cond: "è„šè¸æ‰­ä¼¤", effects: [{ type: "condition_add", key: "è„šè¸æ‰­ä¼¤" }] },
                    { sev: "è½»åº¦åˆ›ä¼¤", desc: "è„‘éœ‡è¡ï¼Œå¿ƒæ™ºç±»ä»»åŠ¡å¸¦æœ‰ [-]ã€‚", cond: "è„‘éœ‡è¡", effects: [{ type: "condition_add", key: "è„‘éœ‡è¡" }] },
                    { sev: "è½»åº¦åˆ›ä¼¤", desc: "è…¿éƒ¨æˆ–æ˜¯è„šæŠ˜æ–­ï¼Œé€Ÿåº¦æ£€å®šå¸¦æœ‰ [-]ã€‚", cond: "è…¿éƒ¨æŠ˜æ–­", effects: [{ type: "condition_add", key: "è…¿éƒ¨æŠ˜æ–­" }] },
                    { sev: "é‡åº¦åˆ›ä¼¤", desc: "è‡‚éƒ¨æˆ–æ˜¯æ‰‹æŠ˜æ–­ï¼ŒåŠ¨æ‰‹ç±»ä»»åŠ¡å¸¦æœ‰ [-]ã€‚", cond: "è‡‚éƒ¨æŠ˜æ–­", effects: [{ type: "condition_add", key: "è‡‚éƒ¨æŠ˜æ–­" }] },
                    { sev: "é‡åº¦åˆ›ä¼¤", desc: "é”éª¨æŠ˜æ–­ï¼ŒåŠ›é‡æ£€å®šå¸¦æœ‰ [-]ã€‚", cond: "é”éª¨æŠ˜æ–­", effects: [{ type: "condition_add", key: "é”éª¨æŠ˜æ–­" }] },
                    { sev: "è‡´å‘½åˆ›ä¼¤", desc: "èƒŒéƒ¨æŠ˜æ–­ï¼Œæ‰€æœ‰æŠ•éª°å¸¦æœ‰ [-]ã€‚", death: true, delay: true, cond: "èƒŒéƒ¨æŠ˜æ–­", effects: [{ type: "death_check", delay: true }, { type: "condition_add", key: "èƒŒéƒ¨æŠ˜æ–­" }] },
                    { sev: "è‡´å‘½åˆ›ä¼¤", desc: "é¢…éª¨å¼€è£‚ï¼Œæ‰€æœ‰æŠ•éª°å¸¦æœ‰ [-]ã€‚", death: true, delay: true, cond: "é¢…éª¨å¼€è£‚", effects: [{ type: "death_check", delay: true }, { type: "condition_add", key: "é¢…éª¨å¼€è£‚" }] },
                    { sev: "è‡´æ­»åˆ›ä¼¤", desc: "è„Šæ¤æˆ–è„–å­æŠ˜æ–­ã€‚", death: true, delay: false, effects: [{ type: "death_check", delay: false }] }
                ]
            },
            "bleeding": {
                name: "å‡ºè¡€",
                aliases: ["å‡ºè¡€", "bleeding", "cut", "c","è¡€"],
                table: [
                    { sev: "çš®è‚‰æŸä¼¤", desc: "æŒæœ‰ç‰©å“æ‰è½ã€‚", effects: [] },
                    { sev: "è½»åº¦åˆ›ä¼¤", desc: "å¤±è¡€ï¼Œè¿‘è·äººå‘˜è·å¾— 1 å‹åŠ›ã€‚", apply: "é˜Ÿå‹å‹åŠ›+1", effects: [] },
                    { sev: "è½»åº¦åˆ›ä¼¤", desc: "è¡€è’™çœ¼ç›ï¼Œæ“¦å¹²å‡€å‰å¸¦æœ‰ [-]ã€‚", cond: "è¡€è’™çœ¼ç›", effects: [{ type: "condition_add", key: "è¡€è’™çœ¼ç›" }] },
                    { sev: "è½»åº¦åˆ›ä¼¤", desc: "æ’•è£‚ä¼¤ã€‚å‡ºè¡€+1ã€‚", val: 1, effects: [{ type: "condition_add", key: "å‡ºè¡€", val: 1 }, { type: "condition_add", key: "æ’•è£‚ä¼¤", }] },
                    { sev: "è½»åº¦åˆ›ä¼¤", desc: "é‡åº¦å‰²ä¼¤ã€‚å‡ºè¡€+2ã€‚", val: 2, effects: [{ type: "condition_add", key: "å‡ºè¡€", val: 2 }, { type: "condition_add", key: "é‡åº¦å‰²ä¼¤", }] },
                    { sev: "é‡åº¦åˆ›ä¼¤", desc: "æ‰‹æŒ‡/è„šè¶¾ç è½ã€‚å‡ºè¡€+3ã€‚", val: 3, effects: [{ type: "condition_add", key: "å‡ºè¡€", val: 3 }, { type: "condition_add", key: "æ‰‹æŒ‡/è„šè¶¾ç è½", }] },
                    { sev: "é‡åº¦åˆ›ä¼¤", desc: "æ‰‹/è„šç è½ã€‚å‡ºè¡€+4ã€‚", val: 4, effects: [{ type: "condition_add", key: "å‡ºè¡€", val: 4 }, { type: "condition_add", key: "æ‰‹/è„šç è½", }] },
                    { sev: "è‡´å‘½åˆ›ä¼¤", desc: "è‚¢ä½“ç è½ã€‚å‡ºè¡€+5ã€‚", val: 5, death: true, delay: true, effects: [{ type: "condition_add", key: "å‡ºè¡€", val: 5 }, { type: "death_check", delay: true }, { type: "condition_add", key: "è‚¢ä½“ç è½", }] },
                    { sev: "è‡´å‘½åˆ›ä¼¤", desc: "ä¸»åŠ¨è„‰å‰²ä¼¤ã€‚å‡ºè¡€+6ã€‚", val: 6, death: true, delay: true, effects: [{ type: "condition_add", key: "å‡ºè¡€", val: 6 }, { type: "death_check", delay: true }, { type: "condition_add", key: "ä¸»åŠ¨è„‰å‰²ä¼¤", }] },
                    { sev: "è‡´æ­»åˆ›ä¼¤", desc: "å–‰å’™å‰²å¼€æˆ–å¿ƒè„åˆºç©¿ã€‚", death: true, delay: false, effects: [{ type: "death_check", delay: false }, { type: "condition_add", key: "å–‰å’™å‰²å¼€æˆ–å¿ƒè„åˆºç©¿", }] }
                ]
            },
            "gunshot": {
                name: "æªå‡»",
                aliases: ["æªå‡»", "gunshot", "gun", "g", "æ§æ“Š","æª"],
                table: [
                    { sev: "çš®è‚‰æŸä¼¤", desc: "æ“¦ä¼¤ï¼Œå‡»å€’ã€‚", cond: "å‡»å€’", effects: [{ type: "condition_add", key: "å‡»å€’" }] },
                    { sev: "è½»åº¦åˆ›ä¼¤", desc: "å‡ºè¡€+1ã€‚", bleed: 1, effects: [{ type: "condition_add", key: "å‡ºè¡€", val: 1 }] },
                    { sev: "è½»åº¦åˆ›ä¼¤", desc: "è‚‹éª¨æŠ˜æ–­ã€‚", effects: [{ type: "condition_add", key: "è‚‹éª¨æŠ˜æ–­", }] },
                    { sev: "è½»åº¦åˆ›ä¼¤", desc: "è‚¢ä½“æ–­è£‚ã€‚", effects: [{ type: "condition_add", key: "è‚¢ä½“æ–­è£‚", }] },
                    { sev: "è½»åº¦åˆ›ä¼¤", desc: "å†…å‡ºè¡€ã€‚å‡ºè¡€+2ã€‚", bleed: 2, effects: [{ type: "condition_add", key: "å†…å‡ºè¡€", }, { type: "condition_add", key: "å‡ºè¡€", val: 2 }] },
                    { sev: "é‡åº¦åˆ›ä¼¤", desc: "å­å¼¹åµŒå…¥ï¼Œéœ€è¦æ‰‹æœ¯ã€‚", effects: [{ type: "condition_add", key: "å­å¼¹åµŒå…¥éœ€è¦æ‰‹æœ¯", }] },
                    {
                        sev: "é‡åº¦åˆ›ä¼¤", desc: "è„–é¢ˆä¸­æªã€‚éœ€è¦æ¤çš®ï¼Œèº«ä½“è±å…-2d10ã€‚", stat_loss: "èº«ä½“ -2d10", effects: [
                            { type: "condition_add", key: "è„–é¢ˆä¸­æª", }
                        ]
                    },
                    { sev: "è‡´å‘½åˆ›ä¼¤", desc: "é‡åº¦å¤±è¡€ã€‚å‡ºè¡€+4ã€‚", bleed: 4, death: true, delay: true, effects: [{ type: "condition_add", key: "é‡åº¦å¤±è¡€", }, { type: "condition_add", key: "å‡ºè¡€", val: 4 }, { type: "death_check", delay: true }] },
                    { sev: "è‡´å‘½åˆ›ä¼¤", desc: "å¼€æ´æ€§èƒ¸éƒ¨æŸä¼¤ã€‚å‡ºè¡€+5ã€‚", bleed: 5, death: true, delay: true, effects: [{ type: "condition_add", key: "å‡ºè¡€", val: 5 }, { type: "death_check", delay: true }, { type: "condition_add", key: "å¼€æ´æ€§èƒ¸éƒ¨æŸä¼¤", }] },
                    { sev: "è‡´æ­»åˆ›ä¼¤", desc: "å¤´éƒ¨ä¸­æªã€‚", death: true, delay: false, effects: [{ type: "death_check", delay: false }, { type: "condition_add", key: "å¤´éƒ¨ä¸­æª", }] }
                ]
            },
            "fire": {
                name: "ç«ç„°",
                aliases: ["ç«ç„°", "çˆ†ç‚¸", "fire", "f", "e", "explosive","ç«"],
                table: [
                    { sev: "çš®è‚‰æŸä¼¤", desc: "å¤´å‘ç‡ƒçƒ§ï¼›è·å¾— 1d5 å‹åŠ›ã€‚", stress: "1d5", effects: [{ type: "resource", key: "å‹åŠ›", op: "add", val: "1d5" }] },
                    { sev: "è½»åº¦åˆ›ä¼¤", desc: "å¯æ€•ä¼¤ç—•ï¼Œå‹åŠ›ä¸‹é™+1ã€‚", min_stress: 1, effects: [{ type: "resource", key: "å‹åŠ›ä¸‹é™", op: "add", val: 1 }, { type: "condition_add", key: "å¯æ€•ä¼¤ç—•", }] },
                    { sev: "è½»åº¦åˆ›ä¼¤", desc: "çƒ§ç„¦ï¼Œä¸‹ä¸ªè¡ŒåŠ¨å¸¦æœ‰ [-]ã€‚", cond: "çƒ§ç„¦", effects: [{ type: "condition_add", key: "çƒ§ç„¦" }] },
                    { sev: "è½»åº¦åˆ›ä¼¤", desc: "å¼¹ç‰‡ä¼¤/å¤§é¢ç§¯çƒ§ä¼¤ã€‚", effects: [{ type: "condition_add", key: "å¼¹ç‰‡ä¼¤/å¤§é¢ç§¯çƒ§ä¼¤", }] },
                    { sev: "è½»åº¦åˆ›ä¼¤", desc: "3 çº§çƒ§ä¼¤ã€‚", effects: [{ type: "condition_add", key: "3çº§çƒ§ä¼¤", }] },
                    {
                        sev: "é‡åº¦åˆ›ä¼¤", desc: "é‡åº¦çƒ§ä¼¤ï¼Œèº«ä½“è±å…-2d10ã€‚", stat_loss: "èº«ä½“ -2d10", effects: [
                            { type: "resource", key: "èº«ä½“", op: "sub", val: "2d10" }, { type: "condition_add", key: "é‡åº¦çƒ§ä¼¤", }
                        ]
                    },
                    {
                        sev: "é‡åº¦åˆ›ä¼¤", desc: "éœ€è¦æ¤çš®ï¼Œèº«ä½“è±å…-2d10ã€‚", stat_loss: "èº«ä½“ -2d10", effects: [
                            { type: "resource", key: "èº«ä½“", op: "sub", val: "2d10" }, { type: "condition_add", key: "éœ€è¦æ¤çš®", }
                        ]
                    },
                    { sev: "è‡´å‘½åˆ›ä¼¤", desc: "è‚¢ä½“ç€ç«ï¼Œæ¯è½® 2d10 ä¼¤å®³ã€‚", death: true, delay: true, cond: "è‚¢ä½“ç€ç«", effects: [{ type: "death_check", delay: true }, { type: "condition_add", key: "è‚¢ä½“ç€ç«" }] },
                    { sev: "è‡´å‘½åˆ›ä¼¤", desc: "èº«ä½“ç€ç«ï¼Œæ¯è½® 3d10 ä¼¤å®³ã€‚", death: true, delay: true, cond: "èº«ä½“ç€ç«", effects: [{ type: "death_check", delay: true }, { type: "condition_add", key: "èº«ä½“ç€ç«" }] },
                    { sev: "è‡´æ­»åˆ›ä¼¤", desc: "è£¹æ»¡ç†Šç†Šçƒˆç„°ã€‚", death: true, delay: false, effects: [{ type: "death_check", delay: false }, { type: "condition_add", key: "è£¹æ»¡ç†Šç†Šçƒˆç„°", }] }
                ]
            },
            "gore": {
                name: "æƒ¨çƒˆ",
                aliases: ["æƒ¨çƒˆ", "åºå¤§", "gore", "massive", "m", "æ…˜çƒˆ", "é¾å¤§","å¤§","æƒ¨"],
                table: [
                    { sev: "çš®è‚‰æŸä¼¤", desc: "å‘•åï¼Œä¸‹ä¸ªè¡ŒåŠ¨ [-]ã€‚", cond: "å‘•å", effects: [{ type: "condition_add", key: "å‘•å" }] },
                    { sev: "è½»åº¦åˆ›ä¼¤", desc: "å¯æ€•ä¼¤ç—•ï¼Œå‹åŠ›ä¸‹é™+1ã€‚", min_stress: 1, effects: [{ type: "resource", key: "å‹åŠ›ä¸‹é™", op: "add", val: 1 }, { type: "condition_add", key: "å¯æ€•ä¼¤ç—•", }] },
                    { sev: "è½»åº¦åˆ›ä¼¤", desc: "æŒ‡éƒ¨æŸæ¯ã€‚", effects: [{ type: "condition_add", key: "æŒ‡éƒ¨æŸæ¯", }] },
                    { sev: "è½»åº¦åˆ›ä¼¤", desc: "çœ¼ç›æŒ–å‡ºã€‚", effects: [{ type: "condition_add", key: "çœ¼ç›æŒ–å‡º", }] },
                    {
                        sev: "è½»åº¦åˆ›ä¼¤", desc: "è¡€è‚‰æ’•è½ï¼Œ-1d10 åŠ›é‡ã€‚", stat_loss: "åŠ›é‡ -1d10", effects: [
                            { type: "resource", key: "åŠ›é‡", op: "sub", val: "1d10" }, { type: "condition_add", key: "è¡€è‚‰æ’•è½", }
                        ]
                    },
                    { sev: "é‡åº¦åˆ›ä¼¤", desc: "è…°éƒ¨ä»¥ä¸‹ç˜«ç—ªã€‚", cond: "ç˜«ç—ª", effects: [{ type: "condition_add", key: "è…°éƒ¨ä»¥ä¸‹ç˜«ç—ª" }] },
                    { sev: "é‡åº¦åˆ›ä¼¤", desc: "è‚¢ä½“ç è½ã€‚å‡ºè¡€+5ã€‚", bleed: 5, effects: [{ type: "condition_add", key: "å‡ºè¡€", val: 5 }, { type: "condition_add", key: "è‚¢ä½“ç è½", }] },
                    { sev: "è‡´å‘½åˆ›ä¼¤", desc: "åˆºç©¿ã€‚å‡ºè¡€+6ã€‚", bleed: 6, death: true, delay: true, effects: [{ type: "condition_add", key: "å‡ºè¡€", val: 6 }, { type: "death_check", delay: true }, { type: "condition_add", key: "åˆºç©¿", }] },
                    { sev: "è‡´å‘½åˆ›ä¼¤", desc: "è‚ è„æ»¡åœ°ã€‚å‡ºè¡€+7ã€‚", bleed: 7, death: true, delay: true, effects: [{ type: "condition_add", key: "å‡ºè¡€", val: 7 }, { type: "death_check", delay: true }, { type: "condition_add", key: "è‚ è‚æ»¡åœ°", }] },
                    { sev: "è‡´æ­»åˆ›ä¼¤", desc: "å¤´éƒ¨çˆ†ç‚¸ï¼Œæ— é¡»æ­»äº¡è±å…ï¼Œä½ å·²ç»æ­»äº†ã€‚", dead: true, effects: [{ type: "death" }, { type: "condition_add", key: "å¤´éƒ¨çˆ†ç‚¸", }] }
                ]
            }
        },

        // ä¼‘å‡è¡¨
        SHORE_LEAVE: {
            "X": { name: "X-çº§æ˜Ÿæ¸¯", costDice: "1d100", costMult: 10000, convert: "2d10", adv: true },
            "C": { name: "C-çº§æ˜Ÿæ¸¯", costDice: "2d10", costMult: 100, convert: "1d5" },
            "B": { name: "B-çº§æ˜Ÿæ¸¯", costDice: "2d10", costMult: 1000, convert: "1d10" },
            "A": { name: "A-çº§æ˜Ÿæ¸¯", costDice: "2d10", costMult: 10000, convert: "2d10" },
            "S": { name: "S-çº§æ˜Ÿæ¸¯", costDice: "2d10", costMult: 100000, convert: "all" }
        },
        // æ­»äº¡è¡¨ (Death Table) - è§„åˆ™ 29.2
        DEATH_TABLE: {
            0: "ã€å¥‡è¿¹å­˜æ´»ã€‘ä½ å¤±å»æ„è¯†ã€‚ä½ ä¼šåœ¨ 2d10 åˆ†é’Ÿå†…é†’æ¥ï¼Œç”Ÿå‘½å€¼ä¸Šé™æ°¸ä¹… -1d5ã€‚",
            1: "ã€å‚å±ã€‘ä½ å¤±å»æ„è¯†ï¼Œç”Ÿå‘½å‚å±ã€‚è‹¥æ˜¯ä¸åŠ å¹²é¢„ï¼Œä½ ä¼šåœ¨ 1d5 è½®å†…æ­»äº¡ã€‚",
            2: "ã€å‚å±ã€‘ä½ å¤±å»æ„è¯†ï¼Œç”Ÿå‘½å‚å±ã€‚è‹¥æ˜¯ä¸åŠ å¹²é¢„ï¼Œä½ ä¼šåœ¨ 1d5 è½®å†…æ­»äº¡ã€‚",
            3: "ã€æ˜è¿·ã€‘ä½ é™·å…¥æ˜è¿·ã€‚åªæœ‰éå¸¸è§„æ‰‹æ®µæ‰èƒ½è®©ä½ æ¢å¤æ¸…é†’ã€‚",
            4: "ã€æ˜è¿·ã€‘ä½ é™·å…¥æ˜è¿·ã€‚åªæœ‰éå¸¸è§„æ‰‹æ®µæ‰èƒ½è®©ä½ æ¢å¤æ¸…é†’ã€‚",
            // 5-9 é»˜è®¤ä¸ºæ­»äº¡
            default: "ã€æ­»äº¡ã€‘ä½ å·²ç»æ­»äº†ã€‚è¯·å¿½ç•¥å…¶ä»–æ­»äº¡è±å…æç¤º,æŠ•ä¸ªæ–°è§’è‰²æ¥å‚åŠ æ¸¸æˆã€‚"
        },
        // æ©ä½“ç±»å‹é¢„è®¾ (å…³é”®å­—æ˜ å°„)
        // ç©å®¶è¾“å…¥ .ms hit ... cover:soft æ—¶è°ƒç”¨
        // è‹±æ–‡åŸæ–‡çš„è–„å¼±æ©ä½“æ˜¯insignificant cover, insignificantè¿™ä¸ªå•è¯ä¸å¤Ÿç›´è§‚,æ•…æ”¹ç§°soft.
        COVER_DB: {
            "soft": { name: "è–„å¼±æ©ä½“", ap: 5, dr: 0, aliases: ["soft", "è–„å¼±", "door", "table", "body", "é—¨", "æ¡Œå­", "å°¸ä½“", "insignificant","è–„å¼±æ©ä½“"] },
            "light": { name: "è½»å‹æ©ä½“", ap: 10, dr: 0, aliases: ["light", "è½»å‹", "tree", "wall", "bulkhead", "æ ‘", "å¢™", "èˆ±å£", "æœ¨é—¨","è½»å‹æ©ä½“"] },
            "heavy": { name: "é‡å‹æ©ä½“", ap: 20, dr: 5, aliases: ["heavy", "é‡å‹", "ship", "airlock", "pillar", "é£èˆ¹", "æ°”é—¸", "æŸ±å­", "æ°´æ³¥å¢™", "æ°´æ³¥æŸ±","é‡å‹æ©ä½“"] },
            "ruin": { name: "åºŸå¢Ÿ,è¢«æ‘§æ¯çš„é‡å‹æ©ä½“", ap: 0, dr: 5, aliases: ["ruin", "åºŸå¢Ÿ", "æ®‹éª¸","è¢«æ‘§æ¯çš„é‡å‹æ©ä½“"] }
        },
        // è·ç¦»å®šä¹‰
        RANGES: {
            "adjacent": { name: "é‚»æ¥", key: "adjacent" },
            "close": { name: "è¿‘è·", key: "close" },
            "long": { name: "è¿œè·", key: "long" },
            "extreme": { name: "æè·", key: "extreme" }
        },
        // [å¡«å……] æŠ¤ç”²æ•°æ®åº“ (æ ¹æ®è§„åˆ™ä¹¦å†…å®¹)
        ARMOR_DB: {
            "æ ‡å‡†ä¹˜ç»„åˆ¶æœ": { ap: 1, dr: 0, cost: "100cr", aliases: ["æ ‡å‡†ä¹˜ç»„åˆ¶æœ", "crew", "uniform", "æ ‡å‡†", "åˆ¶æœ"], desc: "åŸºæœ¬æœè£…ã€‚" },
            "çœŸç©ºæœ": { ap: 3, dr: 0, cost: "10kcr", modifiers: [{ target: "é€Ÿåº¦", type: "dis" }], aliases: ["çœŸç©ºæœ", "vac", "suit", "çœŸç©º"], desc: "12å°æ—¶æ°§æ°”, é˜²è¾å°„ã€‚ç©¿å­”åå¤±å‹ã€‚é€Ÿåº¦[-]" },
            "é˜²å±æœ": { ap: 5, dr: 0, cost: "4kcr", aliases: ["é˜²å±æœ", "hazard", "é˜²å±"], desc: "ç¯å¢ƒé˜²æŠ¤ï¼Œé˜²è…èš€ã€‚" },
            "æ ‡å‡†ä½œæˆ˜æœ": { ap: 7, dr: 0, cost: "-", aliases: ["standard", "battle", "æ ‡å‡†ä½œæˆ˜"], desc: "è½»å‹æ’æ¿æŠ¤ç”²ã€‚" },
            "å…ˆè¿›ä½œæˆ˜æœ": { ap: 10, dr: 3, cost: "12kcr", modifiers: [{ target: "é€Ÿåº¦", type: "dis" }, { target: "åŠ›é‡", type: "adv" }], aliases: ["å…ˆè¿›ä½œæˆ˜æœ", "advanced", "å…ˆè¿›ä½œæˆ˜"], desc: "é™†æˆ˜é˜Ÿé‡ç”²ï¼Œå¤–éª¨éª¼ç»‡ç‰©ã€‚é€Ÿåº¦[-] åŠ›é‡[+]" }

        },
        // [å¡«å……] æ­¦å™¨æ•°æ®åº“ (æ ¹æ®ç”¨æˆ·æä¾›è¡¨æ ¼)
        // é€»è¾‘çº¦å®š: 
        // 1. type ä¸­åŒ…å« [+] ä»£è¡¨è¯¥æŸä¼¤ç±»å‹æ·éª°ä¼˜åŠ¿
        // 2. range_mods å®šä¹‰ç‰¹å®šè·ç¦»çš„ä¿®æ­£ (adv/dis/unusable)
        // 3. range_dmg å®šä¹‰ç‰¹å®šè·ç¦»çš„ä¼¤å®³è¦†ç›– (å¦‚éœ°å¼¹æª)
        WEAPON_DB: {
            "å¾’æ‰‹": {
                dmg: "str/10",
                type: "é’å‡»",
                cost: 0,
                ammo: 0,
                dmg_mod: null,
                range_mods: { "close": "unusable", "long": "unusable", "extreme": "unusable" },
                aliases: ["å¾’æ‰‹", "unarmed", "fist", "æ‹³"],
                special: { target: "", utility: "" }
            },
            "è·³å¸®æ–§": {
                dmg: "2d10",
                type: "æƒ¨çƒˆ[+]",
                cost: 150,
                ammo: 0,
                dmg_mod: "adv",
                range_mods: { "close": "unusable", "long": "unusable", "extreme": "unusable" },
                aliases: ["è·³å¸®æ–§", "axe", "boarding", "æ–§"],
                special: { target: "", utility: "" }
            },
            "æ’¬æ£": {
                dmg: "1d5",
                type: "é’å‡»[+]",
                cost: 25,
                ammo: 0,
                dmg_mod: "adv",
                range_mods: { "close": "unusable", "long": "unusable", "extreme": "unusable" },
                aliases: ["æ’¬æ£", "crowbar"],
                special: {
                    target: "",
                    utility: "å°±æ‰“å¼€å¡ä½çš„æ°”é—¸ã€ä¸¾èµ·é‡ç‰©ç­‰åŠ›é‡æ£€å®šèµ‹äºˆ [+]ã€‚"
                }
            },
            "éœ‡æ…‘ç”µæ£’": {
                dmg: "1d5",
                type: "é’å‡»",
                cost: 150,
                ammo: 0,
                dmg_mod: null,
                range_mods: { "close": "unusable", "long": "unusable", "extreme": "unusable" },
                aliases: ["éœ‡æ…‘ç”µæ£’", "baton", "ç”µæ£’"],
                special: {
                    target: "èº«ä½“è±å…ï¼Œå¤±è´¥éœ‡æ…‘ 1 è½®ã€‚",
                    utility: ""
                }
            },
            "æ‰‹æŒç„Šæª": {
                dmg: "1d10",
                type: "å‡ºè¡€",
                cost: 250,
                ammo: 0,
                dmg_mod: null,
                range_mods: { "close": "unusable", "long": "unusable", "extreme": "unusable" },
                aliases: ["æ‰‹æŒç„Šæª", "welder", "ç„Šæª"],
                special: {
                    target: "",
                    utility: "å¯ä»¥åˆ‡å¼€æ°”é—¸é—¨ã€‚"
                }
            },
            "æ‰‹æœ¯åˆ€": {
                dmg: "1d5",
                type: "å‡ºè¡€[+]",
                cost: 50,
                ammo: 0,
                dmg_mod: "adv",
                range_mods: { "close": "unusable", "long": "unusable", "extreme": "unusable" },
                aliases: ["æ‰‹æœ¯åˆ€", "scalpel", "åˆ€"],
                special: { target: "", utility: "" }
            },
            "å…±æŒ¯ç åˆ€": {
                dmg: "3d10",
                type: "å‡ºè¡€+æƒ¨çƒˆ",
                tags: ["AA"],
                cost: 1000,
                ammo: 0,
                dmg_mod: null,
                range_mods: { "close": "unusable", "long": "unusable", "extreme": "unusable" },
                aliases: ["å…±æŒ¯ç åˆ€", "machete", "ç åˆ€"],
                special: {
                    target: "é€ æˆæŸä¼¤æ—¶ï¼ŒåŒæ—¶æ ¹æ®å‡ºè¡€å’Œæƒ¨çƒˆåˆ—æŠ•éª°ã€‚(éœ€è¦ä½¿ç”¨ä¸¤æ¬¡æŒ‡ä»¤æŠ½å– æŒ‡ä»¤å»ºè®®(.ms wound å‡ºè¡€,  .ms w æƒ¨çƒˆ))",
                    utility: ""
                }
            },
            "æˆ˜æ–—éœ°å¼¹æª": {
                dmg: "4d10",
                type: "æªå‡»",
                cost: 1400,
                ammo: 4,
                dmg_mod: null,
                // å·²ç§»é™¤ adjacent: dis
                range_dmg: { "long": "1d10", "extreme": "1d10" },
                range_mods: {},
                aliases: ["æˆ˜æ–—éœ°å¼¹æª", "shotgun", "å–·å­", "éœ°å¼¹"],
                special: {
                    target: "è¿œè·åŠæ›´è¿œèŒƒå›´ 1d10 ä¼¤å®³ã€‚ï¼ˆæœªæŒ‡ä»¤è‡ªåŠ¨åŒ–å®ç°ï¼‰",
                    utility: ""
                }
            },
            "å–·ç«å™¨": {
                dmg: "2d10",
                type: "ç«ç„°&çˆ†ç‚¸[+]",
                cost: 4000,
                ammo: 4,
                dmg_mod: "adv",
                // å·²ç§»é™¤ adjacent: dis (è¡¨æ ¼æœªæ˜ç¡®æŒ‡æ˜é‚»æ¥åŠ£åŠ¿)
                range_mods: { "long": "unusable", "extreme": "unusable" },
                aliases: ["å–·ç«å™¨", "flamer", "å–·ç«"],
                special: {
                    target: "é€šè¿‡èº«ä½“è±å… [-] å¦åˆ™å°±ä¼šç€ç«ï¼ˆæ¯è½® 2d10 ä¼¤å®³ï¼‰ã€‚",
                    utility: ""
                }
            },
            "æ³¡æ²«æª": {
                dmg: "1",
                type: "é’å‡»",
                cost: 500,
                ammo: 3,
                dmg_mod: null,
                // å·²ç§»é™¤ adjacent: dis
                range_mods: { "long": "unusable", "extreme": "unusable" },
                aliases: ["æ³¡æ²«æª", "foam", "æ³¡æ²«"],
                special: {
                    target: "èº«ä½“è±å…ï¼Œå¤±è´¥å°±ä¼šåŠ¨å¼¹ä¸å¾—ï¼Œè¿›è¡ŒåŠ›é‡æ£€å®š [-] æ‰èƒ½é€ƒè„±ã€‚",
                    utility: ""
                }
            },
            "å°„é’‰æª": {
                dmg: "1d5",
                type: "å‡ºè¡€",
                cost: 150,
                ammo: 32,
                dmg_mod: null,
                // å·²ç§»é™¤ adjacent: dis
                range_mods: { "long": "dis", "extreme": "unusable" },
                aliases: ["å°„é’‰æª", "nail", "å°„é’‰"],
                special: { target: "", utility: "" }
            },
            "è½¬è½®æ‰‹æª": {
                dmg: "1d10+1",
                type: "æªå‡»",
                cost: 750,
                ammo: 6,
                dmg_mod: null,
                // å·²ç§»é™¤ adjacent: dis
                range_mods: { "long": "dis", "extreme": "unusable" },
                aliases: ["è½¬è½®æ‰‹æª", "revolver", "å·¦è½®"],
                special: { target: "", utility: "" }
            },
            "é’©ç´¢æª": {
                dmg: "1d10",
                type: "å‡ºè¡€[+]",
                cost: 350,
                ammo: 1,
                dmg_mod: "adv",
                // å·²ç§»é™¤ adjacent: dis
                range_mods: { "long": "dis", "extreme": "unusable" },
                aliases: ["é’©ç´¢æª", "harpoon", "é’©ç´¢"],
                special: {
                    target: "ç§»é™¤æ—¶é€ æˆ 2d10 ä¼¤å®³ã€‚èº«ä½“è±å…ï¼Œè‹¥æ˜¯å¤±è´¥å°±ä¼šè¢«ç¼ ä½ã€‚",
                    utility: "100 ç±³ç»†ä¸ã€‚"
                }
            },
            "é•‡é™æ‰‹æª": {
                dmg: "1d5",
                type: "é’å‡»",
                cost: 250,
                ammo: 6,
                dmg_mod: null,
                // å·²ç§»é™¤ adjacent: dis
                range_mods: { "long": "dis", "extreme": "unusable" },
                aliases: ["é•‡é™æ‰‹æª", "tranq", "é•‡é™"],
                special: {
                    target: "è‹¥æ˜¯é€ æˆä¼¤å®³ï¼šæ•Œäººå¿…é¡»é€šè¿‡èº«ä½“è±å…ï¼Œå¤±è´¥å°±ä¼šå¤±å»æ„è¯† 1d10 è½®ã€‚",
                    utility: ""
                }
            },
            "ç ´ç‰‡æ‰‹é›·": {
                dmg: "3d10",
                type: "ç«ç„°&çˆ†ç‚¸",
                cost: 400,
                ammo: 1, // æ¶ˆè€—å“
                dmg_mod: null,
                range_mods: { "long": "dis", "extreme": "unusable" },
                aliases: ["ç ´ç‰‡æ‰‹é›·", "grenade", "æ‰‹é›·"],
                special: {
                    target: "è‹¥æ˜¯å‘½ä¸­ï¼Œæ‰€æœ‰é‚»æ¥æ•Œäººçš„å¯¹è±¡éƒ½ä¼šé­å—ä¼¤å®³ã€‚",
                    utility: ""
                }
            },
            "ä¿¡å·æª": {
                dmg: "1d5",
                type: "ç«ç„°&çˆ†ç‚¸[-]",
                cost: 25,
                ammo: 2,
                dmg_mod: "dis",
                // å·²ç§»é™¤ adjacent: dis (è¡¨æ ¼æœªæ˜ç¡®æŒ‡æ˜)
                range_mods: {},
                aliases: ["ä¿¡å·æª", "flare", "ä¿¡å·"],
                special: {
                    target: "",
                    utility: "ä¸åˆ†æ˜¼å¤œéƒ½èƒ½ä»è¿œè·èŒƒå›´å¯ä»¥çœ‹åˆ°é«˜äº®çš„ä¿¡å·ç«å…‰ã€‚"
                }
            },
            "é€šç”¨æœºæª": {
                dmg: "4d10",
                type: "æªå‡»[+]",
                cost: 4500,
                ammo: 5,
                dmg_mod: "adv",
                modifiers: [{ target: "speed", type: "dis" }], // æ²‰é‡
                // å·²ç§»é™¤ adjacent: dis å’Œ close: dis (è¡¨æ ¼ä»…æåŠæ²‰é‡ï¼ŒæœªæåŠè¿‘æˆ˜åŠ£åŠ¿)
                range_mods: {},
                aliases: ["é€šç”¨æœºæª", "gpmg", "æœºæª"],
                special: {
                    target: "åŒæ‰‹ï¼Œæ²‰é‡ï¼Œå¯ä»¥æ“çºµæªç®¡ç»•è¿‡è§’è½å¼€ç«ã€‚",
                    utility: ""
                }
            },
            "æ¿€å…‰åˆ‡å‰²å™¨": {
                dmg: "1d100",
                type: "å‡ºè¡€[+]|æƒ¨çƒˆ[+]",
                tags: ["AA"],
                cost: 1200,
                ammo: 6,
                dmg_mod: "adv",
                modifiers: [{ target: "speed", type: "dis" }], // æ²‰é‡
                // å·²ç§»é™¤ adjacent: dis
                range_mods: {},
                aliases: ["æ¿€å…‰åˆ‡å‰²å™¨", "laser", "åˆ‡å‰²å™¨"],
                special: {
                    target: "åŒæ‰‹ï¼Œæ²‰é‡ï¼Œæ¯æ¬¡å°„å‡»éƒ½è¦é—´éš”ä¸€è½®ã€‚è£…å¡«ï¼š1 å°æ—¶ï¼ˆä¾›èƒ½ï¼‰ï¼›6 å°æ—¶ï¼ˆå¤ªé˜³èƒ½ï¼‰ã€‚",
                    utility: ""
                }
            },
            "è„‰å†²æ­¥æª": {
                dmg: "3d10",
                type: "æªå‡»",
                cost: 2400,
                ammo: 5,
                dmg_mod: null,
                // å·²ç§»é™¤ adjacent: dis
                range_mods: {},
                aliases: ["è„‰å†²æ­¥æª", "pulse", "è„‰å†²"],
                special: { target: "", utility: "" }
            },
            "å†²é”‹æª": {
                dmg: "2d10",
                type: "æªå‡»",
                cost: 1000,
                ammo: 5,
                dmg_mod: null,
                // å·²ç§»é™¤ adjacent: dis
                range_mods: {},
                aliases: ["å†²é”‹æª", "smg", "å†²é”‹"],
                special: {
                    target: "å¯ä»¥å•æ‰‹å¼€ç«ã€‚",
                    utility: ""
                }
            },
            "æ™ºèƒ½æ­¥æª": {
                dmg: "4d10",
                type: "æªå‡»[+]",
                tags: ["AA"],
                cost: 5000,
                ammo: 3,
                dmg_mod: "adv",
                // ç‰¹æ®Š: è¡¨æ ¼æ˜ç¡®è¯´æ˜"åœ¨è¿‘è·èŒƒå›´å†…å¼€ç«...å¸¦æœ‰[-]"ï¼Œå› æ­¤ä¿ç•™ close å’Œ adjacent çš„ dis
                range_mods: { "adjacent": "dis", "close": "dis" },
                aliases: ["æ™ºèƒ½æ­¥æª", "smart", "æ™ºèƒ½"],
                special: {
                    target: "åœ¨è¿‘è·èŒƒå›´å†…å¼€ç«ï¼Œæˆ˜æ–—æ£€å®šå¸¦æœ‰ [-]ã€‚",
                    utility: ""
                }
            }
        }

    };

    const msTemplate = {
        "name": "mothership",
        "fullName": "æ¯èˆ°(mothership) RPG",
        "authors": ["Drå¿ƒè·³"],
        "version": "1.0.1-beta",
        "updatedTime": "20260115",
        "templateVer": "1.0.1-beta",
        "setConfig": {
            "diceSides": 100,
            "enableTip": `M.O.M.ç³»ç»Ÿå·²æ¿€æ´»...æ­£åœ¨æ‰«æç”Ÿç‰©ç»„ä»¶...æ£€æµ‹åˆ°æ¹¿ä»¶æ¥å…¥\nğŸ¥°æˆ‘æ˜¯æ‚¨çš„è´´å¿ƒAIåŠ©æ‰‹,\n\tæ¯èˆ°ä»»åŠ¡è¡ŒåŠ¨ç›‘æ§ç»ˆç«¯ (Mission Operations Monitor,M.O.M.)\næ‚¨å¯ä»¥ç§°å‘¼æˆ‘ä¸ºå¦ˆå’ªæˆ–è€… MğŸ’ŸM,ä¸­é—´è¿™é¢—ğŸ’Ÿæ˜¯å…¬å¸ç»™æ‚¨çš„çˆ±ğŸ¥°ã€‚\nä¸ºé˜²æ­¢æŒ‡ä»¤å†²çª, æœ¬æ’ä»¶æ‰€æœ‰æŒ‡ä»¤éƒ½ä»¥'.ms 'ä½œä¸ºå…¥å£\nå»ºè®®ä½¿ç”¨ .ms me æŸ¥çœ‹æ‚¨çš„å½“å‰çŠ¶æ€\néå¸¸å»ºè®®æ‚¨ä½¿ç”¨.ms st å‹åŠ›+1æ¥è¿›è¡Œå½•å¡å’Œå±æ€§å€¼å˜åŠ¨\nä½¿ç”¨.msæ¥æŸ¥çœ‹å¸®åŠ©\n\t\t\t"ç¥æ‚¨å¥½è¿â¤æ‚¨ä¼šéœ€è¦çš„"`,
            "keys": ["ms", "mothership", "æ¯èˆ°"],
            "relatedExt": ["ms", "coc7"]
        },
        "nameTemplate": {
            "ms": {
                "template": "{$tç©å®¶_RAW} HP{ç”Ÿå‘½å€¼}/{ç”Ÿå‘½å€¼ä¸Šé™} æŸä¼¤{æŸä¼¤}/{æŸä¼¤ä¸Šé™} å‹åŠ›{å‹åŠ›}(ä¸‹é™{å‹åŠ›ä¸‹é™})",
                "helpText": "æ¯èˆ°è§’è‰²çŠ¶æ€"
            }
        },
        "attrConfig": {
            "top": ["åŠ›é‡", "é€Ÿåº¦", "æ™ºåŠ›", "æˆ˜æ–—", "ç†æ™º", "ææƒ§", "èº«ä½“", "æŠ¤ç”²", "ä¼¤å®³å‡å…", "ç”Ÿå‘½å€¼", "ç”Ÿå‘½å€¼ä¸Šé™", "æŸä¼¤", "æŸä¼¤ä¸Šé™", "å‹åŠ›", "å‹åŠ›ä¸‹é™", "å…´å¥‹è¯æ‘„å…¥", "èŒç±»"],
            "showAs": {
                "ç”Ÿå‘½å€¼": "{ç”Ÿå‘½å€¼}/{ç”Ÿå‘½å€¼ä¸Šé™}",
                "æŸä¼¤": "{æŸä¼¤}/{æŸä¼¤ä¸Šé™}",
                "å‹åŠ›": "{å‹åŠ›}(ä¸‹é™{å‹åŠ›ä¸‹é™})",
                "æŠ¤ç”²": "AP{æŠ¤ç”²}/DR{ä¼¤å®³å‡å…}", // [ä¿®æ”¹] æ˜¾ç¤º DR"
                "å…´å¥‹è¯æ‘„å…¥": "{å…´å¥‹è¯æ‘„å…¥}å‰‚",
                "èŒç±»": "{èŒç±»}"
            }
        },
        "defaults": {
            "ç”Ÿå‘½å€¼": 10, "ç”Ÿå‘½å€¼ä¸Šé™": 10,
            "å‹åŠ›": 20, "å‹åŠ›ä¸‹é™": 2,
            "æŸä¼¤": 0, "æŸä¼¤ä¸Šé™": 2,
            "åŠ›é‡": 30, "é€Ÿåº¦": 30, "æ™ºåŠ›": 30, "æˆ˜æ–—": 30,
            "ç†æ™º": 30, "ææƒ§": 30, "èº«ä½“": 30,
            "æŠ¤ç”²": 0, "ä¼¤å®³å‡å…": 0, // [æ–°å¢] DR å±æ€§
            "å…´å¥‹è¯æ‘„å…¥": 0,
            "èŒç±»": 1,//é»˜è®¤èŒç±»
        },
        "alias": MS_CONSTS.ATTR_MAP,

    };

    // è°ƒè¯•æ—¥å¿—ï¼šå¦‚æœä½ åœ¨æ§åˆ¶å°çœ‹åˆ°è¿™ä¸ªé•¿åº¦å¤§äº0ï¼Œè¯´æ˜æ³¨å…¥æˆåŠŸäº†
    // console.log("æ¯èˆ°æ’ä»¶: å·²åŠ¨æ€æ³¨å†Œåˆ«åæ•°é‡ " + Object.keys(msTemplate.alias).length);

    /**
       * ==========================================
       * æ¨¡å—ä¸‰ï¼šæ ¸å¿ƒè§„åˆ™é€»è¾‘ (Logic Layer)
       * ==========================================
       */
    class MSRules {
        // åœ¨ MSRules ç±»ä¸­æ·»åŠ æˆ–ä¿®æ”¹

        /**
         * [æ ¸å¿ƒé‡æ„] ç»¼
         * åˆæ£€å®šå‚æ•°è®¡ç®—å™¨
         * @param {number} baseVal åŸºç¡€å±æ€§å€¼ (å¦‚ åŠ›é‡30)
         * @param {Object} parseResult ç”¨æˆ·è¾“å…¥çš„è§£æç»“æœ (æ¥è‡ª parseExpression)
         * @param {Array} ruleModifiers è§„åˆ™å±‚é¢çš„ä¿®æ­£æ•°ç»„
         * * ruleModifiers æ ¼å¼ç¤ºä¾‹: 
         * [
         * { val: -10, desc: "å—ä¼¤" }, 
         * { mode: "dis", desc: "è·ç¦»" },
         * { mode: "adv", desc: "èŒä¸šç‰¹æ€§" }
         * ]
         */
        static computeCheckParams(baseVal, parseResult, ruleModifiers = []) {
            let finalTarget = baseVal + parseResult.totalValue; // åŠ ä¸Šç”¨æˆ·çš„ä¿®æ­£(å¦‚ +10)
            let advCounter = 0;
            let logParts = []; // ç”¨äºç”Ÿæˆ "è·ç¦»åŠ£åŠ¿, èŒä¸šä¼˜åŠ¿" è¿™æ ·çš„æç¤ºå­—ç¬¦ä¸²

            // 1. å¤„ç†ç”¨æˆ·è¾“å…¥çš„ä¼˜åŠ£åŠ¿
            if (parseResult.mode === "adv") advCounter++;
            if (parseResult.mode === "dis") advCounter--;

            // 2. å¤„ç†è§„åˆ™å±‚é¢çš„ä¿®æ­£
            for (let mod of ruleModifiers) {
                if (mod.val) {
                    finalTarget += mod.val;
                    logParts.push(`${mod.desc}(${mod.val > 0 ? '+' : ''}${mod.val})`);
                }
                if (mod.mode === "adv") {
                    advCounter++;
                    logParts.push(`${mod.desc}ä¼˜åŠ¿`);
                }
                if (mod.mode === "dis") {
                    advCounter--;
                    logParts.push(`${mod.desc}åŠ£åŠ¿`);
                }
            }

            // 3. åˆ¤å®šæœ€ç»ˆæ¨¡å¼
            let finalMode = "normal";
            if (advCounter > 0) finalMode = "adv";
            else if (advCounter < 0) finalMode = "dis";

            return {
                target: finalTarget,
                mode: finalMode,
                rawCounter: advCounter, // ç”¨äºè°ƒè¯•æˆ–æ˜¾ç¤ºæŠµæ¶ˆæƒ…å†µ
                modDetail: logParts.join(", ")
            };
        }
        static mergeModes(modeA, modeB) {
            if (modeA === "normal") return modeB;
            if (modeB === "normal") return modeA;
            if (modeA === modeB) return modeA; // adv + adv = adv
            return "normal"; // adv + dis = normal
        }
        // --- [æ–°å¢] è·å–å½“å‰è£…å¤‡çš„è¾…åŠ©å‡½æ•° ---
        static getEquippedArmor(mctx) {
            const name = seal.vars.strGet(mctx, "ms_equipped_armor")[0];
            if (!name) return null;
            // åœ¨ DB ä¸­æŸ¥æ‰¾ (æ”¯æŒåˆ«åé€»è¾‘å¯åœ¨æ­¤æ‰©å±•)
            return MS_CONSTS.ARMOR_DB[name] || null;
        }

        // [æ–°å¢] æ­¦å™¨åº“ç®¡ç†
        static manageArsenal(mctx, action, payload) {
            const key = "ms_weapon_arsenal";
            let list = [];
            try {
                const stored = seal.vars.strGet(mctx, key)[0];
                // ä¿®å¤ï¼šå¦‚æœé»˜è®¤å€¼è¢«è®¾ä¸º0å¯¼è‡´è·å–åˆ°"0"ï¼Œæˆ–è€…è§£æç»“æœä¸æ˜¯æ•°ç»„ï¼Œå¼ºåˆ¶é‡ç½®
                const parsed = JSON.parse(stored || "[]");
                if (Array.isArray(parsed)) {
                    list = parsed;
                }
            } catch (e) { list = []; }

            if (action === "get") return list;

            if (action === "add") {
                // ç®€å•å»é‡ï¼Œæˆ–è€…å…è®¸é‡å¤æŒæœ‰å¤šæŠŠåŒåæ­¦å™¨ï¼Ÿå»ºè®®å…è®¸ï¼Œå› ä¸ºå¯èƒ½ä¸€æŠŠæ²¡å­å¼¹äº†æ¢å¦ä¸€æŠŠ
                list.push(payload);
                seal.vars.strSet(mctx, key, JSON.stringify(list));
                return true;
            }

            if (action === "remove") {
                // payload å¯ä»¥æ˜¯ç´¢å¼•(1-based) æˆ– åç§°
                if (/^\d+$/.test(payload)) {
                    const idx = parseInt(payload) - 1;
                    if (idx >= 0 && idx < list.length) {
                        list.splice(idx, 1);
                        seal.vars.strSet(mctx, key, JSON.stringify(list));
                        return true;
                    }
                } else {
                    const idx = list.indexOf(payload);
                    if (idx !== -1) {
                        list.splice(idx, 1);
                        seal.vars.strSet(mctx, key, JSON.stringify(list));
                        return true;
                    }
                }
                return false;
            }

            if (action === "clear") {
                seal.vars.strSet(mctx, key, "[]");
                return true;
            }
        }

        // [æ–°å¢] æ”»å‡»æ­¦å™¨è§£æé€»è¾‘
        // arg: ç”¨æˆ·è¾“å…¥çš„å‚æ•° (å¯èƒ½æ˜¯ "2", "shotgun", æˆ– undefined)
        static resolveAttackWeapon(mctx, arg) {
            const list = this.manageArsenal(mctx, "get");
            let weaponName = "å¾’æ‰‹"; // é»˜è®¤ fallback

            if (!arg) {
                // æƒ…å†µ1: æ— å‚æ•° -> é»˜è®¤ä½¿ç”¨ç¬¬ä¸€æŠŠï¼Œæ²¡æœ‰åˆ™å¾’æ‰‹
                if (list.length > 0) weaponName = list[0];
            } else if (/^\d+$/.test(arg)) {
                // æƒ…å†µ2: æ•°å­— -> å°è¯•æŒ‰ç´¢å¼•å– (1-based)
                const idx = parseInt(arg) - 1;
                if (idx >= 0 && idx < list.length) weaponName = list[idx];
                // å¦‚æœç´¢å¼•è¶Šç•Œï¼Œä¿æŒé»˜è®¤ "å¾’æ‰‹" è¿˜æ˜¯æŠ¥é”™ï¼Ÿè¿™é‡Œæš‚å®šå›è½åˆ°å¾’æ‰‹æˆ–ä¿æŒåŸæ ·
                // ä¹Ÿå¯ä»¥é€‰æ‹©: if (idx valid) name = list[idx] else return null (è¡¨ç¤ºæ— æ•ˆé€‰æ‹©)
            } else {
                // æƒ…å†µ3: å­—ç¬¦ä¸² -> è§†ä¸ºä¸´æ—¶è¦†ç›– (æŸ¥DB)
                // æ£€æŸ¥æ˜¯å¦åœ¨ DB ä¸­
                let found = false;
                // ä¼˜å…ˆç²¾ç¡®åŒ¹é…
                if (MS_CONSTS.WEAPON_DB[arg]) {
                    weaponName = arg;
                    found = true;
                }
                // å…¶æ¬¡åˆ«ååŒ¹é…
                if (!found) {
                    for (let k in MS_CONSTS.WEAPON_DB) {
                        if (MS_CONSTS.WEAPON_DB[k].aliases.includes(arg)) {
                            weaponName = k;
                            found = true;
                            break;
                        }
                    }
                }
                // å¦‚æœ DB é‡Œä¹Ÿæ²¡æ‰¾åˆ°ï¼Œå¯èƒ½ç”¨æˆ·è¾“å…¥äº†é”™è¯¯çš„æŒ‡ä»¤ï¼Œæˆ–è€…å°±æ˜¯æƒ³ç”¨è¿™ä¸ªåå­—
                // å»ºè®®ï¼šå¦‚æœæ²¡æ‰¾åˆ°ï¼Œä¿æŒ "å¾’æ‰‹" æˆ–è€…è¿”å› null è®©ä¸Šå±‚æŠ¥é”™
                if (!found) return null;
            }

            return MS_CONSTS.WEAPON_DB[weaponName] || MS_CONSTS.WEAPON_DB["å¾’æ‰‹"];
        }
        // ç¡®ä¿è§’è‰²å¡æœ‰é»˜è®¤å€¼
        static ensureDefaults(mctx) {
            for (let key in msTemplate.defaults) {
                const val = seal.vars.intGet(mctx, key)
                const sVal = seal.vars.strGet(mctx, key);
                if (!val[1] && !sVal[1]) {
                    if (typeof msTemplate.defaults[key] === 'string')
                        seal.vars.strSet(mctx, key, msTemplate.defaults[key]);
                    else
                        seal.vars.intSet(mctx, key, msTemplate.defaults[key]);
                }
            }
        }

        // èŒç±»æ ‡å‡†åŒ– (å…¼å®¹æ•°å­—IDä¸æ–‡æœ¬)
        static normalizeClass(mctx) {
            let currentClass = seal.vars.strGet(mctx, "èŒç±»")[0];
            if (!currentClass) {
                const val = seal.vars.intGet(mctx, "èŒç±»");
                if (val[1]) currentClass = val[0].toString();
                else return "æ— ";
            }
            if (MS_CONSTS.CLASS_ID_MAP[currentClass]) {
                return MS_CONSTS.CLASS_ID_MAP[currentClass];
            }
            return currentClass;
        }

        /**
         * V1.0.1-beta æ ¸å¿ƒæ›´æ–°ï¼šè§£ææŸä¼¤å¯¹è±¡å¹¶åº”ç”¨æ•ˆæœ
         * @param {Object} woundObj æŸä¼¤æ¡ç›®å¯¹è±¡
         */
        static applyWoundEffect(mctx, woundObj) {
            if (woundObj.effects) {
                const engineRes = MSEffectEngine.process(mctx, woundObj.effects);
                return "\n" + engineRes.logs.join("\n");
            }
            return "";
        }

        // è·å–åˆ›ä¼¤ååº”æç¤º (Trauma Response)
        static getTraumaWarning(mctx, checkType, isSuccess) {
            const currentClass = this.normalizeClass(mctx);
            if (currentClass.includes("ç§‘å­¦å®¶") && checkType.includes("ç†æ™º") && !isSuccess) {
                return `\nâš ï¸ ã€ç§‘å­¦å®¶åˆ›ä¼¤ååº”ã€‘ ç†æ™ºè±å…å¤±è´¥! æ‰€æœ‰è¿‘è·å‹æ–¹å‹åŠ›+1ã€‚`;
            }
            const standardAttr = MSRules.resolveAlias(checkType);
            if (currentClass.includes("ä»¿ç”Ÿäºº") && standardAttr === "ææƒ§" || standardAttr === "rest") {
                return `\nğŸ¤– ã€ä»¿ç”Ÿäººåˆ›ä¼¤ååº”æç¤ºã€‘ ä½ çš„å­˜åœ¨è®©å‘¨å›´ä¸å®‰ã€‚è¿‘è·å‹æ–¹ç©å®¶è¿›è¡Œçš„ææƒ§è±å…å¸¦æœ‰åŠ£åŠ¿ã€‚`;
            }
            return "";
        }

        // è‡ªåŠ¨è§£ææŸä¼¤æ–‡æœ¬å¹¶åº”ç”¨çŠ¶æ€
        // static applyWoundEffect(mctx, woundText) {
        //   let log = "";

        //   // 1. å‡ºè¡€æ£€æµ‹
        //   const bleedMatch = woundText.match(/å‡ºè¡€\s*\+?(\d+)/);
        //   if (bleedMatch) {
        //     const amount = parseInt(bleedMatch[1]);
        //     this.manageCondition(mctx, "add", "å‡ºè¡€", amount);
        //     log += `\nğŸ©¸ è·å¾—çŠ¶æ€: ã€å‡ºè¡€ã€‘(å±‚æ•° +${amount})`;
        //   }

        //   // 2. çŠ¶æ€æ£€æµ‹ (åŸºäºé¢„è®¾è¡¨åŒ¹é…)
        //   let foundCond = false;
        //   // ä¼˜å…ˆåŒ¹é… CONDITIONS ä¸­çš„å…·ä½“ä¼¤æƒ… (å¦‚ "è…¿éƒ¨æŠ˜æ–­")
        //   for (let k in MS_CONSTS.CONDITIONS) {
        //       // æ£€æŸ¥æŸä¼¤æ–‡æœ¬æ˜¯å¦åŒ…å«çŠ¶æ€åï¼Œæˆ–çŠ¶æ€åˆ«å
        //       let match = false;
        //       if (woundText.includes(k)) match = true;
        //       else {
        //           const def = MS_CONSTS.CONDITIONS[k];
        //           if (def.aliases) {
        //               for (let alias of def.aliases) {
        //                   if (woundText.includes(alias)) { match = true; break; }
        //               }
        //           }
        //       }

        //       if (match) {
        //           this.manageCondition(mctx, "add", k);
        //           log += `\nğŸ¤• è·å¾—çŠ¶æ€: ã€${k}ã€‘`;
        //           foundCond = true;
        //           break; // é€šå¸¸ä¸€æ¬¡æŸä¼¤åªå¯¹åº”ä¸€ä¸ªä¸»è¦çŠ¶æ€
        //       }
        //   }

        //   // 3. å…œåº•ï¼šå¦‚æœæ²¡åŒ¹é…åˆ°ä½†æœ‰åŠ£åŠ¿æè¿°ï¼Œæ·»åŠ é€šç”¨æè¿°
        //   if (!foundCond && (woundText.includes("[ - ]") || woundText.includes("åŠ£åŠ¿"))) {
        //      // æå–ã€ã€‘å†…çš„å†…å®¹ä½œä¸ºçŠ¶æ€åï¼Œæˆ–è€…ä½¿ç”¨ "ä¸¥é‡è´Ÿä¼¤"
        //      const match = woundText.match(/ã€(.*?)ã€‘/);
        //      const condName = match ? match[1] : "ä¸¥é‡è´Ÿä¼¤";
        //      this.manageCondition(mctx, "add", condName);
        //      log += `\nğŸ¤• è·å¾—çŠ¶æ€: ã€${condName}ã€‘`;
        //   }

        //   // 4. æ­»äº¡è±å…æç¤º
        //   if (!woundText.includes("ä½ å·²ç»æ­»äº†") && woundText.includes("æ­»äº¡è±å…") ) {
        //     log += `\nğŸ’€â— å¿…é¡»ç«‹å³è¿›è¡Œã€æ­»äº¡è±å…ã€‘!`;
        //   }

        //   return log;
        // }

        // ä¼¤å®³ç»“ç®—é€»è¾‘ (HP/Wound Conversion)
        // ==========================================
        // ä¿®æ”¹ 1: MSRules.resolveDamage (å¢åŠ  forceWoundRoll å‚æ•°)
        //æµç¨‹: Cover DR -> Cover AP -> Armor DR -> Armor AP -> HP (Cascade)
        // ==========================================
        static resolveDamage(mctx, damageAmount, typeStr, options = {}, /*forceWoundRoll = null*/) {
            const { coverKey, isAA, forceWoundRoll, dryRun, manualMode = "normal" } = options;
            // [Refactor] ä½¿ç”¨ Inbound Pipeline
            const ctx = MSDamageSystem.createInboundContext(mctx, damageAmount, typeStr, options);
            const resCtx = MSDamageSystem.processInbound(ctx);

            let log = `âš¡ ã€åŸå§‹ä¼¤å®³ã€‘: ${damageAmount}`;
            if (resCtx.logs.length > 0) log += "\n" + resCtx.logs.join("\n");
            let currentDmg = resCtx.effectiveDamage;
            if (currentDmg <= 0) return log + "\nâœ¨ ã€ä¼¤å®³å·²å®Œå…¨æŠµæ¶ˆã€‚ã€‘";



            // === é˜¶æ®µ 3: è‚‰ä½“ç»“ç®— (HP Cascade) ===
            // å¤ç”¨ä¹‹å‰çš„çº§è”æ‰£è¡€é€»è¾‘ï¼Œä½†å°† damageAmount æ›¿æ¢ä¸º currentDmg
            // ä¸ºäº†ä»£ç å¤ç”¨ï¼Œæˆ‘ä»¬å°†é‚£éƒ¨åˆ†é€»è¾‘å°è£…æˆ–ç›´æ¥åœ¨æ­¤å±•å¼€ã€‚æ­¤å¤„å±•å¼€ï¼š
            const hp = seal.vars.intGet(mctx, "ç”Ÿå‘½å€¼")[0];
            const maxHp = seal.vars.intGet(mctx, "ç”Ÿå‘½å€¼ä¸Šé™")[0] || 10;
            const wounds = seal.vars.intGet(mctx, "æŸä¼¤")[0];
            const maxWounds = seal.vars.intGet(mctx, "æŸä¼¤ä¸Šé™")[0] || 2;

            // ç¡®å®šæŸä¼¤ç±»å‹å¯¹è±¡ (å¾ªç¯ä¸­å¤šæ¬¡ä½¿ç”¨)
            let woundTypeObj = null;
            let typeKey = typeStr ? typeStr.toLowerCase() : "";
            for (let k in MS_CONSTS.WOUND_TABLE) {
                if (MS_CONSTS.WOUND_TABLE[k].aliases.includes(typeKey)) {
                    woundTypeObj = MS_CONSTS.WOUND_TABLE[k];
                    break;
                }
            }
            // é»˜è®¤å›è½
            if (!woundTypeObj) woundTypeObj = MS_CONSTS.WOUND_TABLE["blunt"];
            log += `ğŸ©¸ ã€è‚‰ä½“æ‰¿å—ã€‘: ${currentDmg} ç‚¹ä¼¤å®³(ç±»å‹: ${woundTypeObj.name})ã€‚\n`;
            let remainingDmg = currentDmg;
            let isDead = false;

            // === çº§è”ä¼¤å®³å¾ªç¯ ===
            while (remainingDmg > 0) {
                const hp = seal.vars.intGet(mctx, "ç”Ÿå‘½å€¼")[0];
                const wounds = seal.vars.intGet(mctx, "æŸä¼¤")[0];

                // 1. æ£€æŸ¥æ˜¯å¦å·²ç»å½»åº•æ­»äº¡/è¾¾åˆ°ä¸Šé™ï¼Œä¸å†å¤„ç†åç»­ä¼¤å®³
                if (wounds >= maxWounds) {
                    log += `\nğŸ›‘ ã€æŸä¼¤å·²è¾¾ä¸Šé™ã€‘(${maxWounds})ï¼Œæ— æ³•æ‰¿å—æ›´å¤šä¼¤å®³ï¼`;
                    // è¿™é‡Œä¸breakï¼Œå› ä¸ºè¦åœ¨ä¸‹é¢è§¦å‘æ­»äº¡è±å…æç¤ºï¼Œæˆ–è€…ç›´æ¥åœ¨è¿™é‡Œæ ‡è®°
                    isDead = true;
                    break;
                }

                // 2. ä¼¤å®³ç»“ç®—åˆ†æ”¯
                if (remainingDmg < hp) {
                    // æƒ…å†µ A: ä¼¤å®³ä¸è¶³ä»¥æ¸…ç©ºå½“å‰ HP
                    const newHp = hp - remainingDmg;
                    seal.vars.intSet(mctx, "ç”Ÿå‘½å€¼", newHp);
                    log += `â¤ï¸ HP: ${hp} - ${remainingDmg} â” ${newHp}\n`;
                    remainingDmg = 0; // ä¼¤å®³è€—å°½ï¼Œå¾ªç¯ç»“æŸ
                } else {
                    // æƒ…å†µ B: ä¼¤å®³ >= HP (HPå½’é›¶ï¼Œäº§ç”ŸæŸä¼¤)
                    const absorbed = hp; // å½“å‰HPæŠµæ¶ˆäº†å¤šå°‘ä¼¤å®³
                    remainingDmg -= absorbed; // è®¡ç®—å‰©ä½™ä¼¤å®³
                    const newWounds = wounds + 1;
                    seal.vars.intSet(mctx, "æŸä¼¤", newWounds);
                    log += `\nğŸ’” ã€æ‰¿å— ${absorbed}ã€‘ï¼ŒHPå½’é›¶! æŸä¼¤ +1 (${newWounds}/${maxWounds})`;
                    // report += `ğŸ’” æ‰¿å— ${absorbed} ä¼¤å®³ï¼ŒHPå½’é›¶! è·å¾— 1 æŸä¼¤ (${newWounds}/${maxWounds})\n`;

                    // è§¦å‘æŸä¼¤åˆ¤å®š (Rolling on Wound Table)
                    // æ³¨æ„ï¼šå¦‚æœæ˜¯å¤šæ¬¡æŸä¼¤ï¼Œæ¯æ¬¡éƒ½ä¼šæŠ•ä¸€æ¬¡è¡¨
                    // [æ–°å¢] æŸä¼¤è¡¨ä¼˜åŠ£åŠ¿å¤„ç†
                    let condMode = "normal";
                    const conditions = this.manageCondition(mctx, "get");
                    let advCount = 0;
                    let modLogs = [];

                    conditions.forEach(c => {
                        const def = MS_CONSTS.CONDITIONS[c.name];
                        if (def && def.modifiers) {
                            def.modifiers.forEach(m => {
                                if (["wound", "æŸä¼¤", "all"].includes(m.target)) {
                                    if (m.type === "adv") { advCount++; modLogs.push(`${c.name}[+]`); }
                                    if (m.type === "dis") { advCount--; modLogs.push(`${c.name}[-]`); }
                                }
                            });
                        }
                    });

                    if (advCount > 0) condMode = "adv";
                    if (advCount < 0) condMode = "dis";
                    
                    if (manualMode === "adv") modLogs.push("æŒ‡ä»¤[+]");
                    if (manualMode === "dis") modLogs.push("æŒ‡ä»¤[-]");

                    const mode = this.mergeModes(condMode, manualMode);

                    let roll = 0;
                    let rollDetail = "";

                    if (forceWoundRoll !== null) {
                        roll = forceWoundRoll;
                        rollDetail = `${forceWoundRoll} (å›ºå®š)`;
                    } else {
                        const r1 = Math.floor(Math.random() * 10);
                        const r2 = Math.floor(Math.random() * 10);
                        
                        if (mode === "adv") {
                            roll = Math.min(r1, r2);
                            rollDetail = `[${r1}, ${r2}] å–ä½(ä¼˜åŠ¿) -> ${roll}`;
                        } else if (mode === "dis") {
                            roll = Math.max(r1, r2);
                            rollDetail = `[${r1}, ${r2}] å–é«˜(åŠ£åŠ¿) -> ${roll}`;
                        } else {
                            roll = r1;
                            rollDetail = `${r1}`;
                        }
                    }

                    const entry = woundTypeObj.table[roll];

                    // [å…¼å®¹æ€§] å¤„ç†æ—§ç‰ˆçº¯æ–‡æœ¬æˆ–æ–°ç‰ˆå¯¹è±¡
                    const entryDesc = (typeof entry === 'string') ? entry : `[${entry.sev}] ${entry.desc}`;
                    log += `\n  ğŸ² æŸä¼¤è¡¨(1d10): ${rollDetail}`;
                    if (modLogs.length > 0) log += `\n  ğŸ”§ ä¿®æ­£: ${modLogs.join(", ")}`;
                    log += `\n  ğŸ“ ç»“æœ: ${entryDesc}`;
                    if (typeof entry !== 'string') {
                        log += this.applyWoundEffect(mctx, entry);
                        if (entry.dead) { isDead = true; break; }
                    }




                    if (newWounds < maxWounds) {
                        seal.vars.intSet(mctx, "ç”Ÿå‘½å€¼", maxHp);
                        log += `\n  ğŸ”„ ã€HPé‡ç½®ä¸ºä¸Šé™ã€‘ ${maxHp} (å‰©ä½™ä¼¤å®³: ${remainingDmg})\n`;
                    } else {
                        seal.vars.intSet(mctx, "ç”Ÿå‘½å€¼", 0);
                        isDead = true;
                    }

                    // é‡ç½® HP ä¸ºä¸Šé™ï¼Œå‡†å¤‡ä¸‹ä¸€è½®æŠµæ‰£ (å¦‚æœæœ‰å‰©ä½™ä¼¤å®³)
                    // è§„åˆ™: "Reset your Health to its Maximum, minus any carryover damage"
                    // åœ¨å¾ªç¯é€»è¾‘ä¸­ï¼Œæˆ‘ä»¬å…ˆé‡ç½®å› Maxï¼Œä¸‹ä¸€è½®å¾ªç¯ä¼šè‡ªåŠ¨å‡å» remainingDmg
                    // if (newWounds < maxWounds) {
                    //   seal.vars.intSet(mctx, "ç”Ÿå‘½å€¼", maxHp);
                    //   report += `  ğŸ”„ HP é‡ç½®ä¸ºä¸Šé™ ${maxHp} (å‰©ä½™ä¼¤å®³: ${remainingDmg})\n`;
                    // } else {
                    //   // åˆšå¥½è¾¾åˆ°ä¸Šé™ï¼ŒHP è®¾ä¸º 0 è¿˜æ˜¯ Max? 
                    //   // é€šå¸¸æ»¡æŸä¼¤æ„å‘³ç€æ¿’æ­»æˆ–æ­»äº¡ï¼Œè®¾ä¸º 0 æ›´ç›´è§‚ï¼Œæˆ–è€…ä¿æŒå½’é›¶çŠ¶æ€
                    //   seal.vars.intSet(mctx, "ç”Ÿå‘½å€¼", 0);
                    //   isDead = true; // è¾¾åˆ°ä¸Šé™ï¼Œæ ‡è®°ä¸ºè§¦å‘æ­»äº¡è±å…
                    // }
                }
            }

            // === æœ€ç»ˆçŠ¶æ€æ£€æŸ¥ ===
            if (isDead) {
                log += `\nğŸ’€â— ã€æ¿’æ­»/æ­»äº¡ã€‘ æŸä¼¤å·²è¾¾ä¸Šé™æˆ–é­å—è‡´å‘½ä¼¤ï¼\nğŸ‘‰ è¯·ç«‹å³è¿›è¡Œæ­»äº¡è±å…: .ms death`;
            } else {
                const finalHp = seal.vars.intGet(mctx, "ç”Ÿå‘½å€¼")[0];
                log += `ğŸ ã€ç»“ç®—å®Œæ¯•ã€‘ã€‚å½“å‰ HP: ${finalHp}/${maxHp}`;
            }

            return log;

        }

        // æ£€å®šç»“æœç»“ç®— (å«é€šç”¨å‰¯ä½œç”¨)
        static resolveCheck(mctx, checkResult, checkType = "normal") {
            let extraMsg = "";

            // [æ–°å¢] æ˜¾ç¤ºç‰¹æ®Šæ•ˆæœæ—¥å¿—
            if (checkResult.specialLogs && checkResult.specialLogs.length > 0) {
                extraMsg += "\n" + checkResult.specialLogs.join("\n");
            }

            // 1. å¤±è´¥åŠ å‹åŠ›
            if (!checkResult.isSuccess) {
                const r = this.updateStress(mctx, 1, "æ£€å®šå¤±è´¥");
                extraMsg += `\nâŒ ã€å¤±è´¥!ã€‘ å‹åŠ› +1 (å½“å‰: ${r.newVal})${r.msg}`;
            } else {
                extraMsg += `\nâœ… ã€æˆåŠŸ!ã€‘`;
            }

            // 2. å…³é”®æˆåŠŸ/å¤±è´¥
            if (checkResult.crit === "crit_success") {
                extraMsg = `\nâœ¨â—âœ… ã€å…³é”®æˆåŠŸ!ã€‘ (è‡ªåŠ¨æˆåŠŸ)`;
            } else if (checkResult.crit === "crit_fail") {
                extraMsg = `\nâ›”â— ã€å…³é”®å¤±è´¥!ã€‘ è§¦å‘æƒŠæ!`;
                const stress = seal.vars.intGet(mctx, "å‹åŠ›")[0];
                const pr = this.panicCheck(mctx, stress, true);
                let panicResult = "";
                if (pr.isPanic) {
                    panicResult = `ğŸ˜± ã€æƒŠæ!ã€‘\nğŸ“œ æ•ˆæœ: ${pr.desc}`;
                    if (pr.logs && pr.logs.length > 0) panicResult += `\n${pr.logs.join("\n")}`;
                    if (pr.traumaMsg) panicResult += pr.traumaMsg;
                } else {
                    panicResult = `ğŸ˜Œ ã€å®‰å…¨ã€‘ (æ£€å®šå€¼ > å‹åŠ›)`;
                }
                extraMsg += `\nğŸ² æƒŠææ£€å®š(å‹${stress}): 1d20=${pr.rollDetail} â” ${panicResult}`;

            }

            // 3. èŒç±»ç‰¹æ•ˆ
            extraMsg += this.getTraumaWarning(mctx, checkType, checkResult.isSuccess);
            return extraMsg;
        }

        // éª°å­è¡¨è¾¾å¼è§£æ
        static rollDiceExpr(expr) {
            if (!expr) return 0;
            if (expr === "all") return 999;
            const match = expr.match(/(\d+)d(\d+)/);
            if (!match) return 0;
            const count = parseInt(match[1]);
            const sides = parseInt(match[2]);
            let total = 0;
            for (let i = 0; i < count; i++) {
                total += Math.floor(Math.random() * sides) + 1;
            }
            return total;
        }
        // [Refactor] ä¼¤å®³æŠ•æ· (æ”¯æŒç‹‚æš´ç­‰æ•ˆæœ)
        static rollDamage(mctx, dmgExpr, weapon = null, distance = "adjacent") {
            // ä½¿ç”¨ Outbound Pipeline
            const ctx = MSDamageSystem.createOutboundContext(mctx, weapon, distance);
            // å¦‚æœä¼ å…¥äº†ç‰¹å®šçš„ dmgExpr (è¦†ç›–äº† weapon.dmg)ï¼Œåˆ™æ‰‹åŠ¨è®¾ç½®
            if (dmgExpr) ctx.finalExpr = dmgExpr;

            const resCtx = MSDamageSystem.processOutbound(ctx);



            // 2. æŠ•æ·éª°å­
            const roll1 = this.calDice(resCtx.finalExpr);
            let finalRoll = roll1;
            let log = resCtx.logs.length > 0 ? " " + resCtx.logs.join(", ") : "";
            if (resCtx.mode === "adv") {
                const roll2 = this.calDice(resCtx.finalExpr);
                finalRoll = Math.max(roll1, roll2);
                log += ` (ä¼˜åŠ¿: [${roll1}, ${roll2}] å–é«˜)`;
            } else if (resCtx.mode === "dis") {
                const roll2 = this.calDice(resCtx.finalExpr);
                finalRoll = Math.min(roll1, roll2);
                log += ` (åŠ£åŠ¿: [${roll1}, ${roll2}] å–ä½)`;
            }


            return { result: finalRoll, log: log };
        }

        // æ›´æ–°å‹åŠ› (å«æº¢å‡ºæ£€æŸ¥)
        static updateStress(mctx, changeAmount, reason = "") {
            const stressVar = seal.vars.intGet(mctx, "å‹åŠ›");
            const currentStress = stressVar[1] ? stressVar[0] : 2;
            // const minStress = seal.vars.intGet(mctx, "å‹åŠ›ä¸‹é™")[0];
            const minVar = seal.vars.intGet(mctx, "å‹åŠ›ä¸‹é™");
            const minStress = minVar[1] ? minVar[0] : 2;

            let newStress = currentStress + changeAmount;
            let overflow = 0;
            let msg = "";

            if (newStress < minStress) newStress = minStress;
            if (newStress < 0) newStress = 0;

            if (newStress > 20) {
                overflow = newStress - 20;
                newStress = 20;
                msg = `\nâš ï¸ ã€å‹åŠ›è¿‡è½½ (OVERFLOW)ã€‘\n` +
                    `==============================\n` +
                    `è§„åˆ™è§„å®šå‹åŠ›æœ€å¤§ä¸º20, å½“å‰å‹åŠ›å·²é”å®šåœ¨ 20ã€‚\n` +
                    `ğŸŒŠ ã€æº¢å‡ºé‡ã€‘: ã€${overflow}ã€‘\n` +
                    `ğŸ˜« ã€å‹åŠ›è§„åˆ™ã€‘: ä»»ä½•è¶…è¿‡ 20 çš„å‹åŠ›éƒ½ä¼šè½¬è€Œè®©ç›¸å…³å±æ€§æˆ–è±å…å‡å°‘å¯¹åº”æ•°é‡ã€‚\n` +
                    `ğŸ‘‰ è¯·ç«‹å³é€‰æ‹©ä¸€é¡¹ç›¸å…³å±æ€§/è±å…ï¼Œä½¿å…¶æ•°å€¼å‡å°‘ ${overflow} ç‚¹ã€‚\n` +
                    `(å»ºè®®: .st <å±æ€§> -${overflow})`;
            }

            seal.vars.intSet(mctx, "å‹åŠ›", newStress);
            return { oldVal: currentStress, newVal: newStress, overflow, msg, reason };

        }

        // çŠ¶æ€ç®¡ç† (å¢åˆ æŸ¥) - æ”¯æŒåˆ«åæŸ¥æ‰¾
        static manageCondition(mctx, action, condName = "", options = {}) {
            const key = "ms_conditions";
            const stored = seal.vars.strGet(mctx, key)[0];
            let list = [];
            try { if (stored) list = JSON.parse(stored); } catch (e) { list = []; }
            if (list.length > 0 && typeof list[0] === 'string') list = list.map(name => ({ name: name, val: 1, extra: "" }));

            if (action === "add" && condName) {
                let def = MS_CONSTS.CONDITIONS[condName];
                let finalName = condName;

                // å°è¯•æŸ¥æ‰¾å®šä¹‰ (é€šè¿‡åˆ«å)
                // if (!def) {
                //     for (let k in MS_CONSTS.SURVIVAL_CONDITIONS) {
                //         const sDef = MS_CONSTS.SURVIVAL_CONDITIONS[k];
                //         if (k === condName || (sDef.aliases && sDef.aliases.includes(condName))) { def = sDef; finalName = k; break; }
                //     }
                // }
                if (!def) {
                    for (let k in MS_CONSTS.CONDITIONS) {
                        const cDef = MS_CONSTS.CONDITIONS[k];
                        if (k === condName || (cDef.aliases && cDef.aliases.includes(condName))) { def = cDef; finalName = k; break; }
                    }
                }
                // å¦‚æœéƒ½æ²¡æ‰¾åˆ°ï¼Œä¿æŒåŸè¾“å…¥åä½œä¸ºè‡ªå®šä¹‰çŠ¶æ€
                if (!def) finalName = condName;
                const newCond = {
                    name: finalName,
                    val: options.val || 1,
                    duration: options.duration || (def ? def.duration : "æ— é™"), // å­˜å‚¨å…·ä½“çš„ "5åˆ†é’Ÿ"
                    sourceExpr: options.sourceExpr, // å¯é€‰ï¼šè®°å½•åŸå§‹å…¬å¼ "1d10åˆ†é’Ÿ"
                    desc: options.desc || (def ? def.summary : "æ— æè¿°")
                };
                // let extraText = "";
                // if (def && def.rollInit) {
                //     const rollVal = MSRules.rollDiceExpr(def.rollInit);
                //     const unit = def.rollInit.includes("åˆ†é’Ÿ") ? "åˆ†é’Ÿ" : (def.rollInit.includes("å°æ—¶") ? "å°æ—¶" : "");
                //     extraText = `${rollVal}${unit}`;
                // }

                const idx = list.findIndex(i => i.name === finalName);
                // let currentStack = val;

                if (idx >= 0 && def && def.stackable) {
                    //     // å·²å­˜åœ¨ï¼šç´¯åŠ å±‚æ•° (å¦‚æœæ˜¯å¯å †å çš„)ï¼Œæˆ–æ›´æ–°éšæœºå€¼
                    list[idx].val += newCond.val;
                    // list[idx].duration = newCond.duration; // åˆ·æ–°æŒç»­æ—¶é—´
                    // currentStack = list[idx].val;
                    //     if (extraText) list[idx].extra = extraText;
                } else {
                    list.push(newCond);
                }
                seal.vars.strSet(mctx, key, JSON.stringify(list));

                // // è¿”å›å±•ç¤ºæ–‡æœ¬
                // let displayDesc = "";
                // if (def) {
                //     displayDesc = newCond.desc || def.detail || "æ— è¯¦ç»†æè¿°";
                //     if (extraText) displayDesc = displayDesc.replace("{duration}", extraText);
                // } else {
                //     displayDesc = "è‡ªå®šä¹‰/æœªçŸ¥çŠ¶æ€";
                // }

                // let ret = `å·²æ·»åŠ : ã€${finalName}ã€‘`;
                // if (def && def.stackable) ret += ` (å±‚æ•°: ${def.val})`;
                // // if (extraText) ret += ` (éšæœºå€¼: ${extraText})`;
                // ret+=(newCond.duration !== "æ— é™" ? ` (æŒç»­: ${newCond.duration})` : "");
                // ret += `\nğŸ“ è¯´æ˜: ${displayDesc}`;
                // return ret;
                return `ğŸŒ€ ã€è·å¾—çŠ¶æ€ã€‘: ã€${condName}ã€‘` +
                    (newCond.duration !== "æ— é™" ? ` (æŒç»­: ${newCond.duration})` : "") +
                    `\nğŸ“ ã€è¯´æ˜ã€‘: ${newCond.desc}`;

            }

            if (action === "remove" && condName) {
                // let targetName = condName;
                // // å°è¯•é€šè¿‡åˆ«åæ‰¾åˆ°æ ‡å‡†åï¼Œä»¥ä¾¿ç²¾ç¡®ç§»é™¤
                // let idx = list.findIndex(i => i.name === condName);
                // if (idx === -1) {
                //     for (let k in MS_CONSTS.SURVIVAL_CONDITIONS) {
                //         const sDef = MS_CONSTS.SURVIVAL_CONDITIONS[k];
                //         if (sDef.aliases && sDef.aliases.includes(condName)) { targetName = k; break; }
                //     }
                //     if (targetName === condName) {
                //         for (let k in MS_CONSTS.CONDITIONS) {
                //             const cDef = MS_CONSTS.CONDITIONS[k];
                //             if (cDef.aliases && cDef.aliases.includes(condName)) { targetName = k; break; }
                //         }
                //     }
                //     idx = list.findIndex(i => i.name === targetName);
                // }

                // if (idx !== -1) {
                //     const removedName = list[idx].name;
                //     list.splice(idx, 1);
                //     seal.vars.strSet(mctx, key, JSON.stringify(list));
                //     return removedName;
                // }
                // return null;
                const idx = list.findIndex(c => c.name === condName);
                if (idx >= 0) {
                    const removed = list.splice(idx, 1)[0];
                    seal.vars.strSet(mctx, key, JSON.stringify(list));
                    return removed.name;
                }
                return null;
            }
            if (action === "get") return list;
            if (action === "clear") { seal.vars.strSet(mctx, key, JSON.stringify([])); return true; }
        }

        // ç‰©å“ä½¿ç”¨ (ä»£ç†)
        static useItem(mctx, itemName, args) {
            let itemDef = null;
            for (let k in MS_CONSTS.ITEMS) {
                if (MS_CONSTS.ITEMS[k].aliases.includes(itemName.toLowerCase())) {
                    itemDef = MS_CONSTS.ITEMS[k];
                    break;
                }
            }
            if (itemDef) { return itemDef.use(mctx, args); }
            return null;
        }

        // è§£ææŒ‡ä»¤å‚æ•° (æ”¯æŒ "åŠ›é‡+10 adv")
        // --- [ä¿®æ”¹] parseExpression (åœ¨è§£æé˜¶æ®µæ³¨å…¥è¢«åŠ¨æ•ˆæœ) ---
        static parseExpression(mctx, argsStr) {
            let cleanStr = argsStr.trim();
            let mode = "normal";

            // æå–æœ«å°¾çš„ä¼˜åŠ£åŠ¿
            if (cleanStr.endsWith("+") || cleanStr.endsWith("ï¼‹")) {
                const lastPart = cleanStr.split(/[\s+\-]/).pop();
                if (!/^\d+$/.test(lastPart)) { mode = "adv"; cleanStr = cleanStr.slice(0, -1).trim(); }
            } else if (cleanStr.endsWith("-") || cleanStr.endsWith("ï¼")) {
                const lastPart = cleanStr.split(/[\s+\-]/).pop();
                if (!/^\d+$/.test(lastPart)) { mode = "dis"; cleanStr = cleanStr.slice(0, -1).trim(); }
            }

            const tokens = cleanStr.replace(/\+/g, " +").replace(/-/g, " -").split(/\s+/);
            let totalValue = 0; let descParts = []; let missingAttrs = [];
            let checkAttrName = ""; // è®°å½•ä¸»è¦æ£€æµ‹çš„å±æ€§å

            for (let token of tokens) {
                if (!token) continue;
                let sign = 1; let item = token;
                if (token.startsWith("+")) { item = token.substring(1); }
                else if (token.startsWith("-")) { sign = -1; item = token.substring(1); }

                if (/^\d+$/.test(item)) {
                    const num = parseInt(item); totalValue += (sign * num); descParts.push(`${sign > 0 ? '+' : '-'}${num}`);
                } else {
                    const attrName = this.resolveAlias(item);
                    // è®°å½•ç¬¬ä¸€ä¸ªé‡åˆ°çš„å±æ€§åä½œä¸ºæ£€å®šç±»å‹
                    if (!checkAttrName) checkAttrName = attrName;
                    const val = seal.vars.intGet(mctx, attrName);
                    if (val[1]) {
                        totalValue += (sign * val[0]);
                        descParts.push(`${attrName}(${val[0]})`);
                    } else {
                        missingAttrs.push(item);
                    }
                }
            }
            let desc = descParts.join(" "); if (desc.startsWith("+")) desc = desc.substring(1);
            return { totalValue, desc, mode, missingAttrs, checkType: descParts[0]?.split('(')[0] || "å±æ€§" };
        }
        /**
 * è§£æå¹¶è®¡ç®—åŒ…å«éª°å­è¡¨è¾¾å¼çš„å…¬å¼
 * @param {string} formula - éª°å­å…¬å¼å­—ç¬¦ä¸²ï¼Œå¦‚ "5d10+3"ã€"2d6-1"ã€"d8"
 * @returns {Object} è®¡ç®—ç»“æœå¯¹è±¡
 * @throws {Error} å…¬å¼æ ¼å¼é”™è¯¯æ—¶æŠ›å‡ºå¼‚å¸¸
 */
        static calDice(expression) {
            // 1. é¢„å¤„ç†ï¼šè½¬å°å†™ï¼Œç§»é™¤å¤šä½™ç©ºæ ¼
            let expr = expression.toLowerCase().replace(/\s+/g, '');

            // 2. æ­£åˆ™åŒ¹é…éª°å­è¡¨ç¤ºæ³• (ä¾‹å¦‚: 3d6, d20)
            // æ•è·ç»„1: éª°å­æ•°é‡ (å¯ä»¥æ˜¯ç©ºï¼Œä»£è¡¨1)
            // æ•è·ç»„2: éª°å­é¢æ•°
            const diceRegex = /(\d*)d(\d+)/g;

            // 3. æ›¿æ¢é€»è¾‘ï¼šå°† "3d5" æ›¿æ¢ä¸ºå®é™…æŠ•æ·çš„æ€»å’Œ
            const parsedExpr = expr.replace(diceRegex, (match, count, sides) => {
                const numDice = count === '' ? 1 : parseInt(count, 10);
                const numSides = parseInt(sides, 10);

                if (numDice > 1000) throw new Error("éª°å­æ•°é‡è¿‡å¤š"); // é˜²æ­¢æ­»å¾ªç¯ä¿æŠ¤
                if (numSides < 1) throw new Error("éª°å­é¢æ•°å¿…é¡»å¤§äº0");

                let rollTotal = 0;
                for (let i = 0; i < numDice; i++) {
                    // æŠ•æ·é€»è¾‘: 1 åˆ° numSides
                    rollTotal += Math.floor(Math.random() * numSides) + 1;
                }

                // è¿”å›è¯¥ç»„éª°å­çš„æ€»å’Œå­—ç¬¦ä¸²
                return rollTotal.toString();
            });

            // 4. å®‰å…¨æ€§æ£€æŸ¥ï¼šç¡®ä¿åªåŒ…å«æ•°å­—å’Œæ•°å­¦è¿ç®—ç¬¦
            // å…è®¸å­—ç¬¦: 0-9, +, -, *, /, (, ), .
            if (/[^0-9+\-*/().]/.test(parsedExpr)) {
                throw new Error("è¡¨è¾¾å¼åŒ…å«éæ³•å­—ç¬¦");
            }

            // 5. è®¡ç®—æœ€ç»ˆç»“æœ
            // ä½¿ç”¨ new Function æ¯” eval ç¨å¾®å®‰å…¨ä¸€äº›ï¼Œä¸”ç»“åˆäº†ä¸Šé¢çš„æ­£åˆ™ç™½åå•æ£€æŸ¥
            try {
                return new Function('return ' + parsedExpr)();
            } catch (e) {
                throw new Error("æ•°å­¦è¡¨è¾¾å¼æ ¼å¼é”™è¯¯");
            }
        }


        // æ·éª°è®¡ç®— (è¿”å›å¯¹è±¡)
        // [MODIFIED] å¢åŠ  forceVal å‚æ•°ç”¨äºè‡ªåŠ¨åŒ–æµ‹è¯•
        // åŸå‡½æ•°: static rollCheck(target, mode = "normal") {
        /**
       * [æ ¸å¿ƒå‡çº§] æ£€å®šé€»è¾‘ (å¢åŠ è¢«åŠ¨æ•ˆæœæç¤º)
       * ç­–ç•¥: ä»…æ£€æµ‹å¹¶è¿”å›æç¤º (tip)ï¼Œä¸è‡ªåŠ¨ä¿®æ”¹ mode
       */
        static rollCheck(target, mode = "normal", specials = {}, forceVal = null) {

            const r1 = forceVal !== null ? forceVal : Math.floor(Math.random() * 100);
            let r2 = Math.floor(Math.random() * 100);
            let finalRoll = r1;
            let specialLogs = [];

            if (mode === "adv") { finalRoll = Math.min(r1, r2); }
            else if (mode === "dis") { finalRoll = Math.max(r1, r2); }

            let crit = null;
            let isSuccess = false;
            let tens = Math.floor(finalRoll / 10);
            let ones = finalRoll % 10;
            let isDoubles = (tens === ones);

            if (finalRoll === 0) { crit = "crit_success"; isSuccess = true; }
            else if (finalRoll === 99) { crit = "crit_fail"; isSuccess = false; }
            else if (isDoubles) { if (finalRoll <= target) { crit = "crit_success"; isSuccess = true; } else { crit = "crit_fail"; isSuccess = false; } }
            else { if (finalRoll >= 90) { isSuccess = false; specialLogs.push("âš ï¸ã€è§„åˆ™ã€‘ æŠ•å‡º90-99æ€»æ˜¯å¤±è´¥"); } else { isSuccess = (finalRoll <= target); } }

            // ç‰¹æ®Šæ•ˆæœä»‹å…¥å±‚ (Logic Override)
            if (specials.hasOwnProperty("DOOM_CRIT_INVERT") && crit === "crit_success") {
                crit = "crit_fail";
                isSuccess = false;
                specialLogs.push("â›”â— ã€å¤§éš¾ä¸´å¤´ã€‘ ç”Ÿæ•ˆ: å…³é”®æˆåŠŸè¢«æ‰­è½¬ä¸ºå…³é”®å¤±è´¥ï¼");
            }

            // ç¤ºä¾‹ï¼šå¼ºåˆ¶å¤±è´¥ (ä¾‹å¦‚æŸäº›å‰§æƒ…çŠ¶æ€)
            if (specials.hasOwnProperty("force_fail")) {
                isSuccess = false;
                crit = null;
            }

            return { roll: finalRoll, target: target, mode: mode, isSuccess: isSuccess, crit: crit, rawDice: [r1, r2], specialsActivated: Object.keys(specials), specialLogs };
        }

        // [æ–°å¢] ç»Ÿä¸€æƒŠææŠ•éª° (Centralized Panic Roll)
        static rollPanicDie(mctx, stress = null, manualMode = "normal") {
            // 1. æ£€æŸ¥çŠ¶æ€å¸¦æ¥çš„ä¼˜åŠ£åŠ¿
            let condMode = "normal";
            const conditions = this.manageCondition(mctx, "get");
            let advCount = 0;
            let logs = [];

            conditions.forEach(c => {
                const def = MS_CONSTS.CONDITIONS[c.name];
                if (def && def.modifiers) {
                    def.modifiers.forEach(m => {
                        if (["panic", "æƒŠæ", "all"].includes(m.target)) {
                            if (m.type === "adv") { advCount++; logs.push(`${c.name}[+]`); }
                            if (m.type === "dis") { advCount--; logs.push(`${c.name}[-]`); }
                        }
                    });
                }
            });

            if (advCount > 0) condMode = "adv";
            if (advCount < 0) condMode = "dis";

            if (manualMode === "adv") logs.push("æŒ‡ä»¤[+]");
            if (manualMode === "dis") logs.push("æŒ‡ä»¤[-]");

            const mode = this.mergeModes(condMode, manualMode);

            // 2. æŠ•éª°
            const r1 = Math.floor(Math.random() * 20) + 1;
            const r2 = Math.floor(Math.random() * 20) + 1;

            const ret = (roll, detail, candidates, isAmbiguous = false) => ({
                roll, detail, mode, candidates, isAmbiguous, logs
            });

            // æ™®é€šæ¨¡å¼ç›´æ¥è¿”å›
            if (mode === "normal") {
                return ret(r1, `${r1}`, [r1]);
            }

            // å¦‚æœæ²¡æœ‰å‹åŠ›å€¼(éæƒŠææ£€å®š)ï¼ŒæŒ‰å¸¸è§„å¤§å°å¤„ç†
            if (stress === null) {
                if (mode === "adv") {
                    if (r1 === 1 || r2 === 1) return ret(1, `[${r1}, ${r2}] ä¼˜åŠ¿(å‡º1é€‰1)`, [1]);
                    if (r1 === r2) return ret(r1, `[${r1}, ${r2}] ä¼˜åŠ¿(ç›¸ç­‰)`, [r1]);
                    return ret(null, `[${r1}, ${r2}] ä¼˜åŠ¿(éœ€è‡ªé€‰)`, [r1, r2], true);
                }
                if (mode === "dis") {
                    if (r1 === r2) return ret(r1, `[${r1}, ${r2}] åŠ£åŠ¿(ç›¸ç­‰)`, [r1]);
                    return ret(null, `[${r1}, ${r2}] åŠ£åŠ¿(éœ€è‡ªé€‰)`, [r1, r2], true);
                }
            }

            // === æƒŠææ£€å®šå¤æ‚é€»è¾‘ ===
            const safe1 = r1 > stress;
            const safe2 = r2 > stress;
            const hasOne = (r1 === 1 || r2 === 1);

            // 1. ä¼˜åŠ¿é€»è¾‘
            if (mode === "adv") {
                if (hasOne) return ret(1, `[${r1}, ${r2}] ä¼˜åŠ¿(å‡º1é€‰1)`, [1]);
                if (safe1 && safe2) return ret(Math.max(r1, r2), `[${r1}, ${r2}] ä¼˜åŠ¿(çš†å®‰å…¨)`, [Math.max(r1, r2)]);
                if (safe1 !== safe2) {
                    const val = safe1 ? r1 : r2;
                    return ret(val, `[${r1}, ${r2}] ä¼˜åŠ¿(é¿å…æƒŠæ)`, [val]);
                }
                if (r1 === r2) {
                    return ret(r1, `[${r1}, ${r2}] ä¼˜åŠ¿(ç›¸ç­‰)`, [r1]);
                }
                // éƒ½æ˜¯æƒŠæ -> æ— æ³•åˆ¤å®šå¥½å -> æŠ›å‡ºæ­§ä¹‰
                return ret(null, `[${r1}, ${r2}] ä¼˜åŠ¿(çš†æƒŠæ-éœ€è‡ªé€‰)`, [r1, r2], true);
            }

            // 2. åŠ£åŠ¿é€»è¾‘
            if (mode === "dis") {
                if (safe1 && safe2) return ret(Math.max(r1, r2), `[${r1}, ${r2}] åŠ£åŠ¿(çš†å®‰å…¨)`, [Math.max(r1, r2)]);
                if (safe1 !== safe2) {
                    const val = safe1 ? r2 : r1; // é€‰æƒŠæçš„é‚£ä¸ª
                    return ret(val, `[${r1}, ${r2}] åŠ£åŠ¿(å¼ºåˆ¶æƒŠæ)`, [val]);
                }
                if (r1 === r2) {
                    return ret(r1, `[${r1}, ${r2}] åŠ£åŠ¿(ç›¸ç­‰)`, [r1]);
                }
                // éƒ½æ˜¯æƒŠæ -> æ— æ³•åˆ¤å®šå“ªä¸ªæ›´å -> æŠ›å‡ºæ­§ä¹‰
                return ret(null, `[${r1}, ${r2}] åŠ£åŠ¿(çš†æƒŠæ-éœ€è‡ªé€‰)`, [r1, r2], true);
            }

            return ret(r1, `${r1}`, [r1]);
        }

        // æƒŠææ£€å®š
        // [MODIFIED] å¢åŠ  fixedRoll å‚æ•°ç”¨äºè‡ªåŠ¨åŒ–æµ‹è¯•
        // åŸå‡½æ•°: static panicCheck(mctx, currentStress, autoApply = true) {
        static panicCheck(mctx, currentStress, autoApply = true, fixedRoll = null, manualMode = "normal") {
            // 1. æŠ•éª° (ä½¿ç”¨ç»Ÿä¸€é€»è¾‘æˆ–å›ºå®šå€¼)
            let pr;
            if (fixedRoll !== null) {
                pr = { roll: fixedRoll, detail: `${fixedRoll} (å›ºå®š)`, mode: "fixed", logs: [] };
            } else {
                pr = this.rollPanicDie(mctx, currentStress, manualMode);
            }

            // [æ–°å¢] å¤„ç†æ­§ä¹‰çŠ¶æ€ (Ambiguous State)
            if (pr.isAmbiguous) {
                // ç”Ÿæˆé€‰é¡¹é¢„è§ˆ
                const options = pr.candidates.map(roll => {
                    const entry = this.resolvePanicTableEntry(mctx, roll, false, manualMode); // false = ä»…é¢„è§ˆä¸æ‰§è¡Œ
                    return { roll, desc: entry.desc };
                });
                return {
                    isAmbiguous: true,
                    rollDetail: pr.detail,
                    stress: currentStress,
                    options: options,
                    modLogs: pr.logs
                };
            }

            // 2. åˆ¤å®š
            const isPanic = pr.roll <= currentStress;

            let result = {
                roll: pr.roll,
                rollDetail: pr.detail,
                stress: currentStress,
                isPanic,
                desc: "",
                logs: [],
                traumaMsg: "",
                modLogs: pr.logs
            };

            if (isPanic) {

                // è°ƒç”¨é€’å½’è§£æå™¨
                const effectRes = this.resolvePanicTableEntry(mctx, pr.roll, autoApply, manualMode);
                result.desc = effectRes.desc;
                result.logs = effectRes.logs;

                // åˆ›ä¼¤ååº”
                const cls = this.normalizeClass(mctx);
                if (cls.includes("é™†æˆ˜é˜Ÿå‘˜")) {
                    result.traumaMsg = `\nâš ï¸ ã€é™†æˆ˜é˜Ÿåˆ›ä¼¤ååº”ã€‘ ä½ é™·å…¥äº†æƒŠæ! æ‰€æœ‰è¿‘è·å‹æ–¹å¿…é¡»è¿›è¡Œææƒ§è±å…ã€‚`;
                }
            }
            return result;
            // return { roll, stress: currentStress, isPanic, effect: effectText, autoMsg };
        }
        // [NEW] è§£ææƒŠæè¡¨æ¡ç›® (æ”¯æŒé€’å½’)
        static resolvePanicTableEntry(mctx, roll, autoApply, manualMode = "normal") {
            const entry = MS_CONSTS.PANIC_TABLE[roll];
            if (!entry) return { desc: "æœªçŸ¥æ•ˆæœ", logs: [] };

            let logs = [];
            let desc = entry.desc;

            if (autoApply && entry.effects) {
                const engineRes = MSEffectEngine.process(mctx, entry.effects);
                logs.push(...engineRes.logs);

                // æ›¿æ¢æŒç»­æ—¶é—´
                for (const [key, duration] of Object.entries(engineRes.durationMap)) {
                    desc = desc.replace("{duration}", duration);
                }

                // å¤„ç†é€’å½’æŠ•éª° (å¤åˆé—®é¢˜)
                if (engineRes.recursiveRolls > 0) {
                    for (let i = 0; i < engineRes.recursiveRolls; i++) {
                        // [Modified] ä½¿ç”¨ç»Ÿä¸€æŠ•éª°é€»è¾‘
                        const subPr = this.rollPanicDie(mctx, null, manualMode); // [Fix] ç»§æ‰¿ä¼˜åŠ£åŠ¿ï¼Œæ— å‹åŠ›å€¼(çº¯æŸ¥è¡¨)
                        logs.push(`\nğŸ² ã€é¢å¤–æƒŠææŠ•éª°ã€‘ #${i + 1}: 1d20=${subPr.detail}`);

                        // [New] å¤„ç†é€’å½’ä¸­çš„æ­§ä¹‰
                        if (subPr.isAmbiguous) {
                            logs.push(`âš ï¸ ç»“æœå­˜åœ¨æ­§ä¹‰(ä¼˜åŠ£åŠ¿)ï¼Œè¯·æ‰‹åŠ¨é€‰æ‹©:`);
                            subPr.candidates.forEach(c => {
                                const subEntry = MS_CONSTS.PANIC_TABLE[c];
                                const subDesc = subEntry ? subEntry.desc.split("ã€‚")[0] : "æœªçŸ¥æ•ˆæœ";
                                logs.push(`   ğŸ”¹ éª°å€¼ ${c}: ${subDesc} (ğŸ‘‰ .ms panic force:${c})`);
                            });
                            continue;
                        }

                        const subRes = this.resolvePanicTableEntry(mctx, subPr.roll, autoApply, manualMode); // [Fix] é€’å½’ä¼ é€’
                        logs.push(`> ${subRes.desc}`);
                        if (subRes.logs.length > 0) logs.push(...subRes.logs.map(l => `  ${l}`));
                    }
                }
            }

            // æ–‡æœ¬æ¸…ç†
            desc = desc.replace(/{duration}/g, "ä¸€å®šæ—¶é—´");
            if (entry.effects) {
                const condEffect = entry.effects.find(e => e.type === 'condition_add');
                if (condEffect) {
                    desc = desc.replace("{condition}", condEffect.key);
                    // [æ–°å¢] è‡ªåŠ¨è¿½åŠ çŠ¶æ€ç®€è¿°ï¼Œæ–¹ä¾¿åšé€‰æ‹©æ—¶æŸ¥çœ‹
                    const condDef = MS_CONSTS.CONDITIONS[condEffect.key];
                    if (condDef && condDef.summary) {
                        desc += `\n   (â„¹ï¸ æ•ˆæœ: ${condDef.summary})`;
                    }
                }
            }

            return { desc, logs };
        }
        static resolveAlias(inputName) {
            // const cleanName = inputName.trim();
            const cleanName = inputName.trim().toLowerCase();
            for (let key in MS_CONSTS.ATTR_MAP) {
                if (MS_CONSTS.ATTR_MAP[key].some(alias => alias.toLowerCase() === cleanName)) return key;
            }
            return inputName.trim();
        }

        static getWorstSave(mctx) {
            const saves = ["ç†æ™º", "ææƒ§", "èº«ä½“"];
            let worstVal = 999;
            let worstName = "";
            saves.forEach(name => {
                const realName = this.resolveAlias(name);
                const val = seal.vars.intGet(mctx, realName)[0];
                if (val < worstVal && val > 0) {
                    worstVal = val;
                    worstName = name;
                }
            });
            if (worstVal === 999) return { name: "", val: 0 };
            return { name: worstName, val: worstVal };
        }
        // æ­»äº¡è±å…
        static deathCheck(mctx, manualMode = "normal") {
            // 1. æ£€æŸ¥çŠ¶æ€å¸¦æ¥çš„ä¼˜åŠ£åŠ¿
            let condMode = "normal";
            const conditions = this.manageCondition(mctx, "get");
            let advCount = 0;
            let logs = [];

            conditions.forEach(c => {
                const def = MS_CONSTS.CONDITIONS[c.name];
                if (def && def.modifiers) {
                    def.modifiers.forEach(m => {
                        if (["death", "æ­»äº¡", "all"].includes(m.target)) {
                            if (m.type === "adv") { advCount++; logs.push(`${c.name}[+]`); }
                            if (m.type === "dis") { advCount--; logs.push(`${c.name}[-]`); }
                        }
                    });
                }
            });

            if (advCount > 0) condMode = "adv";
            if (advCount < 0) condMode = "dis";

            if (manualMode === "adv") logs.push("æŒ‡ä»¤[+]");
            if (manualMode === "dis") logs.push("æŒ‡ä»¤[-]");

            const mode = this.mergeModes(condMode, manualMode);

            // 2. æŠ•éª°
            // è§„åˆ™: å°† 1d10 æ”¾å…¥æ¯ä¸­æ‘‡æ™ƒ (0-9)
            const r1 = Math.floor(Math.random() * 10);
            const r2 = Math.floor(Math.random() * 10);
            
            let roll = r1;
            let detail = `${r1}`;

            if (mode === "adv") {
                roll = Math.min(r1, r2);
                detail = `[${r1}, ${r2}] å–ä½(ä¼˜åŠ¿) -> ${roll}`;
            } else if (mode === "dis") {
                roll = Math.max(r1, r2);
                detail = `[${r1}, ${r2}] å–é«˜(åŠ£åŠ¿) -> ${roll}`;
            }

            let effect = MS_CONSTS.DEATH_TABLE[roll] || MS_CONSTS.DEATH_TABLE.default;

            // è‡ªåŠ¨å¤„ç† 0 å·ç»“æœçš„éª°å­é€»è¾‘
            if (roll === 0) {
                const wakeTime = this.rollDiceExpr("2d10");
                const loss = this.rollDiceExpr("1d5");
                effect = effect.replace("2d10", "(2d10)" + wakeTime).replace("1d5", "(1d5)" + loss);

                // è‡ªåŠ¨æ‰£é™¤ç”Ÿå‘½ä¸Šé™
                const oldMax = seal.vars.intGet(mctx, "ç”Ÿå‘½å€¼ä¸Šé™")[0] || 10;
                const newMax = Math.max(1, oldMax - loss);
                seal.vars.intSet(mctx, "ç”Ÿå‘½å€¼ä¸Šé™", newMax);
                // å½“å‰ç”Ÿå‘½å€¼è®¾ä¸º0? è§„åˆ™æœªæ˜è¯´ï¼Œä½†å¤±å»æ„è¯†é€šå¸¸HP<=0ã€‚ä¿æŒç°çŠ¶ã€‚

                effect += `\nğŸ“‰ (å·²è‡ªåŠ¨æ›´æ–°ç”Ÿå‘½ä¸Šé™: -${loss} â” å½“å‰ ${newMax})`;
            } else if (roll <= 2) {
                const deathTime = this.rollDiceExpr("1d5");
                effect = effect.replace("1d5", "(1d5)" + deathTime);
            }

            return { roll, detail, effect, logs };
        }
        /**
         * [è¾…åŠ©] è·å–è¢«åŠ¨æ•ˆæœæç¤º
         * åœ¨ MSCommands.handleCheck ä¸­è°ƒç”¨æ­¤æ–¹æ³•è·å–æ–‡æœ¬
         */
        static checkPassiveEffects(mctx, attrName) {
            const armorName = seal.vars.strGet(mctx, "ms_equipped_armor")[0];
            if (!armorName || armorName === "æ— ") return "";

            // æŸ¥æ‰¾æŠ¤ç”²åº“ (æš‚æœªå¡«å……ï¼Œé€»è¾‘å…ˆè¡Œ)
            const armor = MS_CONSTS.ARMOR_DB[armorName];
            if (armor && armor.modifiers) {
                for (let mod of armor.modifiers) {
                    if (mod.target === attrName) {
                        const modType = mod.type === "dis" ? "åŠ£åŠ¿" : "ä¼˜åŠ¿";
                        return `\nğŸ’¡ ã€è£…å¤‡æç¤ºã€‘: ç©¿ç€ã€${armorName}ã€‘è¿›è¡Œ ${attrName} æ£€å®šï¼Œå»ºè®®å¸¦æœ‰ [${modType}]ã€‚`;
                    }
                }
            }
            return "";
        }
    }
    /**
       * ==========================================
       * æ¨¡å—å››ï¼šå‘½ä»¤å¤„ç†å™¨ (Presentation Layer)
       * è´Ÿè´£è§£æç”¨æˆ·æŒ‡ä»¤ï¼Œè°ƒç”¨ Logic å±‚ï¼Œå¹¶æ ¼å¼åŒ–è¾“å‡ºç»“æœã€‚
       * ==========================================
       */
    class MSCommands {
        // [æ–°å¢] æ’¤å›æ“ä½œ
        static handleBack(ctx, msg, cmdArgs) {
            const arg2 = cmdArgs.getArgN(2).toLowerCase();
            if (arg2 === "help") {
                let helpMsg = "ğŸ”™ ã€æ—¶å…‰å›æº¯ (.ms back)ã€‘\n";
                helpMsg += "==============================\n";
                helpMsg += "æ­¤æŒ‡ä»¤ç›¸å½“äºâ€œè¯»å–ä¸Šä¸€ä¸ªè‡ªåŠ¨å­˜æ¡£â€ã€‚\n";
                helpMsg += "â€¢ ã€æœºåˆ¶ã€‘: ç³»ç»Ÿä¼šåœ¨æ¯æ¬¡æ•°å€¼å˜æ›´å‰è‡ªåŠ¨å­˜æ¡£ã€‚\n";
                helpMsg += "â€¢ ã€åŠŸèƒ½ã€‘: æ’¤é”€ä¸Šä¸€æ­¥æ“ä½œï¼Œæ¢å¤å±æ€§ã€è¡€é‡åŠçŠ¶æ€ã€‚\n";
                helpMsg += "â€¢ ã€é™åˆ¶ã€‘: ä»…é™ä¸€æ­¥æ’¤å›ï¼Œæ— æ³•è¿ç»­æ’¤å›ã€‚\n";
                helpMsg += "â€¢ ã€æç¤ºã€‘: æŸ¥çœ‹å±æ€§(.ms me)ä¸ä¼šè¦†ç›–å­˜æ¡£ï¼Œå¯å…ˆç¡®è®¤å†æ’¤å›ã€‚\n";
                seal.replyToSender(ctx, msg, helpMsg);
                return seal.ext.newCmdExecuteResult(true);
            }

            const mctx = seal.getCtxProxyFirst(ctx, cmdArgs);
            if (MSStateManager.restoreState(mctx)) {
                seal.replyToSender(ctx, msg, "â³ æ—¶é—´å›æº¯æˆåŠŸï¼šå·²æ’¤é”€ä¸Šä¸€æ­¥æ“ä½œé€ æˆçš„æ‰€æœ‰æ•°å€¼å˜åŠ¨ã€‚\n ");
            } else {
                seal.replyToSender(ctx, msg, "âŒ æ— æ³•æ’¤å›ï¼šæ²¡æœ‰å¯ç”¨çš„å†å²è®°å½•ã€‚");
            }
            return seal.ext.newCmdExecuteResult(true);
        }
        // [æ–°å¢] ç©¿æˆ´æŠ¤ç”²
        static handleWear(ctx, msg, cmdArgs) {
            const mctx = seal.getCtxProxyFirst(ctx, cmdArgs);
            const name = cmdArgs.getArgN(2);

            if (!name || name === "help") {
                const help = `ğŸ›¡ï¸ ã€æ¯èˆ°æŠ¤ç”²æŒ‡ä»¤ (.ms wear)ã€‘\n` +
                    `================================\n` +
                    `ç”¨æ³•: .ms wear <æŠ¤ç”²åç§°>\n` +
                    `ä½œç”¨: ç©¿æˆ´æŒ‡å®šæŠ¤ç”²ï¼Œè‡ªåŠ¨è®¾ç½® AP (æŠ¤ç”²å€¼) å’Œ DR (ä¼¤å®³å‡å…)ã€‚\n` +
                    `      è‹¥æŠ¤ç”²æœ‰è¢«åŠ¨ç‰¹æ€§ (å¦‚é€Ÿåº¦åŠ£åŠ¿)ï¼Œç³»ç»Ÿä¼šè‡ªåŠ¨è®°å½•å¹¶åœ¨æ£€å®šä¸­æç¤ºã€‚\n` +
                    `\n` +
                    `ç¤ºä¾‹:\n` +
                    `  .ms wear çœŸç©ºæœ (ç©¿æˆ´çœŸç©ºæœ)\n` +
                    `  .ms wear å…ˆè¿› (ç©¿æˆ´å…ˆè¿›ä½œæˆ˜æœ)\n` +
                    `================================`;
                seal.replyToSender(ctx, msg, help);
                return seal.ext.newCmdExecuteResult(true);
            }
            // æŸ¥æ‰¾æ•°æ®åº“
            let armor = MS_CONSTS.ARMOR_DB[name];
            let armorKey = name;

            // åˆ«ååŒ¹é…
            if (!armor) {
                for (let k in MS_CONSTS.ARMOR_DB) {
                    if (MS_CONSTS.ARMOR_DB[k].aliases.includes(name.toLowerCase())) {
                        armor = MS_CONSTS.ARMOR_DB[k];
                        armorKey = k;
                        break;
                    }
                }
            }

            if (armor) {
                seal.vars.intSet(mctx, "æŠ¤ç”²", armor.ap);
                seal.vars.intSet(mctx, "ä¼¤å®³å‡å…", armor.dr);
                seal.vars.strSet(mctx, "ms_equipped_armor", armorKey);

                let reply = `ğŸ›¡ï¸ å·²è£…å¤‡: ã€${armorKey}ã€‘\nå±æ€§æ›´æ–°: AP ${armor.ap} | DR ${armor.dr}`;
                if (armor.modifiers) {
                    const mods = armor.modifiers.map(m => `${m.target}${m.type === 'dis' ? '[-]' : '[+]'}`).join(", ");
                    reply += `\nâš ï¸ è¢«åŠ¨ç‰¹æ€§: ${mods}`;
                }
                seal.replyToSender(ctx, msg, reply);
            } else {
                seal.replyToSender(ctx, msg, `æœªæ‰¾åˆ°æŠ¤ç”²: ${name} (è¯·æ£€æŸ¥æ‹¼å†™æˆ–ç­‰å¾…æ•°æ®åº“æ›´æ–°)`);
            }
            return seal.ext.newCmdExecuteResult(true);
        }

        // [é‡æ„] æŒæœ‰æ­¦å™¨ (Arsenal Management)
        static handleHold(ctx, msg, cmdArgs) {
            const mctx = seal.getCtxProxyFirst(ctx, cmdArgs);
            const arg1 = cmdArgs.getArgN(2); // add/rm/list or weapon name
            const arg2 = cmdArgs.getArgN(3);

            // 1. å­æŒ‡ä»¤åˆ†å‘
            if (arg1 === "rm" || arg1 === "remove" || arg1 === "del") {
                if (!arg2) { seal.replyToSender(ctx, msg, "âŒ è¯·æŒ‡å®šè¦ç§»é™¤çš„æ­¦å™¨ç¼–å·æˆ–åç§°ã€‚"); return seal.ext.newCmdExecuteResult(true); }
                const success = MSRules.manageArsenal(mctx, "remove", arg2);
                if (success) seal.replyToSender(ctx, msg, `ğŸ—‘ï¸ å·²ç§»é™¤æ­¦å™¨: ${arg2}`);
                else if (arg2 === 0 || arg2 === "0") { seal.replyToSender(ctx, msg, `ğŸ’“è°¢è°¢ä½ æ„¿æ„ç ”ç©¶æœ¬æ’ä»¶, ä½†æ˜¯åºå·0æ­¦å™¨æ˜¯æŒ‡è§’è‰²çš„å¾’æ‰‹æ”»å‡», ä¸å¯åˆ é™¤å“¦ğŸ˜„\n`); }
                else seal.replyToSender(ctx, msg, `âŒ æœªæ‰¾åˆ°æ­¦å™¨: ${arg2}`);
                return seal.ext.newCmdExecuteResult(true);
            }

            if (arg1 === "clear") {
                MSRules.manageArsenal(mctx, "clear");
                seal.replyToSender(ctx, msg, "ğŸ—‘ï¸ æ­¦å™¨åº“å·²æ¸…ç©ºã€‚");
                return seal.ext.newCmdExecuteResult(true);
            }

            // 2. æ·»åŠ æ­¦å™¨ (é»˜è®¤è¡Œä¸º) æˆ– åˆ—å‡º (æ— å‚)
            if (!arg1 || arg1 === "list") {
                const list = MSRules.manageArsenal(mctx, "get");
                if (list.length === 0) { seal.replyToSender(ctx, msg, "ğŸ’ å½“å‰æœªæŒæœ‰ä»»ä½•æ­¦å™¨ (é»˜è®¤ä½¿ç”¨å¾’æ‰‹)ã€‚\nğŸ‘‰ ä½¿ç”¨ .ms hold <åç§°> æ·»åŠ æ­¦å™¨ã€‚"); return seal.ext.newCmdExecuteResult(true); }

                let txt = "ğŸ’ ã€å½“å‰æŒæœ‰æ­¦å™¨ã€‘:\n(ä½¿ç”¨ .ms hold del <åºå·> ç§»é™¤)\n";
                list.forEach((w, i) => {
                    txt += `${i + 1}. ${w}${i === 0 ? " (é»˜è®¤)" : ""}\n`;
                });
                seal.replyToSender(ctx, msg, txt);
                return seal.ext.newCmdExecuteResult(true);
            }

            // 3. æ·»åŠ é€»è¾‘
            // æ£€æŸ¥æ˜¯å¦æ˜¯æœ‰æ•ˆæ­¦å™¨å
            let weapon = MS_CONSTS.WEAPON_DB[arg1];
            let wName = arg1;

            if (!weapon) {
                // åˆ«åæŸ¥æ‰¾
                for (let k in MS_CONSTS.WEAPON_DB) {
                    if (MS_CONSTS.WEAPON_DB[k].aliases.includes(arg1)) {
                        weapon = MS_CONSTS.WEAPON_DB[k];
                        wName = k;
                        break;
                    }
                }
            }

            if (weapon) {
                MSRules.manageArsenal(mctx, "add", wName);
                const list = MSRules.manageArsenal(mctx, "get");
                let weaponMsg = `ğŸ”« å·²æ·»åŠ æ­¦å™¨: ã€${wName}ã€‘\nåºå·: ${list.length}\n`;
                if (weapon.special.utility && weapon.special.utility != "") {
                    weaponMsg += `ğŸ’¡ å®ç”¨åŠŸèƒ½: ${weapon.special.utility}\n`;
                }
                if (weapon.special.target && weapon.special.target != "") {
                    weaponMsg += `ğŸ¯ å¯¹æ•ŒåŠŸèƒ½: ${weapon.special.target}\n`;
                }
                weaponMsg += `--------------------------------------------------\n`;
                weaponMsg += `ğŸ‘‰ ä½¿ç”¨ .ms hold æŸ¥çœ‹åˆ—è¡¨\nğŸ‘‰ ä½¿ç”¨ .ms hold del <åºå·> åˆ é™¤\n`;
                if (weapon.special) { weaponMsg += `â„¹ï¸ æç¤º: ä¼¤å®³å’Œè·ç¦»éª°å€¼å·²è‡ªåŠ¨è£…è½½ã€‚å®ç”¨/å¯¹æ•ŒåŠŸèƒ½è¯·æ ¹æ®æè¿°å™äº‹ã€‚\n`; }


                seal.replyToSender(ctx, msg, weaponMsg);
            } else {

                seal.replyToSender(ctx, msg, `âŒ æœªçŸ¥æ­¦å™¨: ${arg1} (è¯·æ£€æŸ¥æ‹¼å†™)`)
            }
            return seal.ext.newCmdExecuteResult(true);
        }

        // [é‡æ„] æ”»å‡»æŒ‡ä»¤ (.ms atk [weapon/id] [dist])
        static handleAtk(ctx, msg, cmdArgs) {
            const mctx = seal.getCtxProxyFirst(ctx, cmdArgs);

            // 1. æ˜¾ç¤ºå¸®åŠ©èœå•
            const arg2 = cmdArgs.getArgN(2).toLowerCase();
            if (arg2 === "help") {
                let helpMsg = `âš”ï¸ ã€æ¯èˆ°æ”»å‡»æŒ‡ä»¤ (.ms atk)ã€‘\n`;
                helpMsg += `==============================\n`;
                helpMsg += `ç”¨æ³•: .ms atk [æ­¦å™¨] [è·ç¦»] [ä¿®æ­£] [ä¼˜åŠ£]\n`;
                helpMsg += `â€¢ ã€æ­¦å™¨ã€‘: æ­¦å™¨åæˆ–ID (è§ .ms hold)ã€‚ä¸å¡«é»˜è®¤ç”¨é¦–ä½æ­¦å™¨/å¾’æ‰‹ã€‚\n`;
                helpMsg += `â€¢ ã€è·ç¦»ã€‘: adj(é‚»), clo(è¿‘), lon(è¿œ), ext(æ)ã€‚ä¸å¡«é»˜è®¤adjã€‚\n`;
                helpMsg += `â€¢ ã€ä¿®æ­£ã€‘: æ•°å€¼(+10) æˆ– å±æ€§(æˆ˜æ–—) æˆ– ä¼˜åŠ£(adv/dis/+/-)ã€‚\n`;
                helpMsg += `\nç¤ºä¾‹:\n`;
                helpMsg += `  .ms atk (é»˜è®¤æ­¦å™¨, é‚»æ¥è·ç¦»)\n`;
                helpMsg += `  .ms atk 2 long (ä½¿ç”¨2å·æ­¦å™¨, è¿œè·)\n`;
                helpMsg += `  .ms atk +10 adv (é»˜è®¤æ­¦å™¨, +10åŠ å€¼, ä¼˜åŠ¿)\n`;
                helpMsg += `  .ms atk æ’¬æ£ +è¿‘èº«ææ–— (ä½¿ç”¨æ’¬æ£, é™„åŠ æŠ€èƒ½åŠ å€¼)\n`;

                seal.replyToSender(ctx, msg, helpMsg);
                return seal.ext.newCmdExecuteResult(true);
            }

            // 2. å‚æ•°è§£æ (Weapon, Distance, Modifiers)
            let weaponArg = null;
            let distArg = "adjacent";
            let modifierArgs = "";
            const isDist = (s) => ["adj", "clo", "lon", "ext", "è¿‘", "è¿œ", "æ", "é‚»"].some(k => s.startsWith(k));

            const isMod = (s) => s.startsWith("+") || s.startsWith("-") || ["adv", "dis", "ä¼˜åŠ¿", "åŠ£åŠ¿"].includes(s);
            const isWeaponAlias = (s) => {
                if (MS_CONSTS.WEAPON_DB[s]) return true;
                for (let k in MS_CONSTS.WEAPON_DB) {
                    if (MS_CONSTS.WEAPON_DB[k].aliases.includes(s)) return true;
                }
                return false;
            };

            for (let i = 1; i < cmdArgs.args.length; i++) {
                const arg = cmdArgs.args[i];
                const lowerArg = arg.toLowerCase();

                // seal.replyToSender(ctx,msg,`${i}-${lowerArg}\n`)
                if (isDist(lowerArg)) {
                    distArg = lowerArg;
                    continue;
                }

                if (isMod(lowerArg)) {
                    modifierArgs += arg + " ";
                    continue;
                }

                if (!weaponArg) {
                    if (/^\d+$/.test(arg)) { weaponArg = arg; continue; }
                    if (isWeaponAlias(arg)) { weaponArg = arg; continue; }

                    // æ£€æŸ¥æ˜¯å¦ä¸ºå±æ€§/æŠ€èƒ½ (è§†ä¸ºä¿®é¥°ç¬¦)
                    const resolved = MSRules.resolveAlias(arg);
                    if (resolved !== arg || MS_CONSTS.ATTR_MAP[resolved]) {
                        modifierArgs += arg + " ";
                        continue;
                    }

                    weaponArg = arg;
                } else {
                    modifierArgs += arg + " ";
                }
            }

            // 3. è§£ææ­¦å™¨ (Logic Layer)
            const weapon = MSRules.resolveAttackWeapon(mctx, weaponArg);
            if (!weapon) {
                seal.replyToSender(ctx, msg, `âŒ æ— æ³•è¯†åˆ«æ­¦å™¨: ${weaponArg}`);
                return seal.ext.newCmdExecuteResult(true);
            }
            const weaponName = weapon.aliases[0] || "æœªçŸ¥æ­¦å™¨"; // è·å–ä¸€ä¸ªæ˜¾ç¤ºå
            const n = seal.format(ctx, "{$tç©å®¶}");


            // 4. è·ç¦»å¤„ç†
            let distKey = "adjacent";
            if (distArg.startsWith("adj") || distArg.match(/é‚»|é„°/)) distKey = "adjacent";
            else if (distArg.startsWith("clo") || distArg.match(/è¿‘/)) distKey = "close";
            else if (distArg.startsWith("lon") || distArg.match(/è¿œ|é /)) distKey = "long";
            else if (distArg.startsWith("ext") || distArg.match(/æ|æ¥µ/)) distKey = "extreme";
            const distName = MS_CONSTS.RANGES[distKey].name;

            // 5. æ„å»ºä¸Šä¸‹æ–‡ä¸ç®¡é“å¤„ç† (Refactored)
            const checkVal = seal.vars.intGet(mctx, "æˆ˜æ–—")[0];
            const checkCtx = new CheckContext(mctx, "æˆ˜æ–—", checkVal);
            checkCtx.weapon = weapon;
            checkCtx.distance = distKey;
            checkCtx.distanceName = distName;
            checkCtx.addTag("combat");
            checkCtx.addTag("attack");
            checkCtx.addTag("atk");

            // 6. åº”ç”¨æŒ‡ä»¤ä¿®æ­£ (Modifiers)
            const parsed = MSRules.parseExpression(mctx, modifierArgs);
            if (parsed.totalValue !== 0) {
                checkCtx.addMod(parsed.totalValue, parsed.desc || "æŒ‡ä»¤");
            }
            if (parsed.mode === 'adv') checkCtx.addAdv('adv', 'æŒ‡ä»¤');
            if (parsed.mode === 'dis') checkCtx.addAdv('dis', 'æŒ‡ä»¤');

            const pipeRes = MSPipeline.process(checkCtx);



            // 7. æ£€æŸ¥é˜»æ–­ (å¦‚æ­¦å™¨è·ç¦»ä¸å¯ç”¨)
            if (checkCtx.specials["weapon_unusable"]) {
                // seal.replyToSender(ctx, msg, `ğŸš« æ­¦å™¨ã€${weaponName}ã€‘æ— æ³•åœ¨ã€${distName}ã€‘è·ç¦»ä½¿ç”¨ï¼`);
                let validRanges = [];
                const order = ["adjacent", "close", "long", "extreme"];
                for (const k of order) {
                    if (!weapon.range_mods || weapon.range_mods[k] !== "unusable") {
                        validRanges.push(MS_CONSTS.RANGES[k].name);
                    }
                }
                seal.replyToSender(ctx, msg, `ğŸš« æ­¦å™¨ã€${weaponName}ã€‘æ— æ³•åœ¨ã€${distName}ã€‘è·ç¦»ä½¿ç”¨ï¼\nğŸ“ å¯ç”¨å°„ç¨‹: ${validRanges.join(", ")}`);

                return seal.ext.newCmdExecuteResult(true);
            }

            // 8. æ‰§è¡Œæ£€å®š
            const result = MSRules.rollCheck(pipeRes.target, pipeRes.mode, {});

            // 9. æ„å»ºè¾“å‡º
            let logStr = pipeRes.logs.length > 0 ? `\nğŸ”§ ä¿®æ­£ ${pipeRes.logs.join(", ")}` : "";
            logStr+="\n"+result.specialLogs;
            let reply = `${n} ä½¿ç”¨ ${weaponName} æ”»å‡» (${distName}):\n`;

            const rollStr = result.mode === 'normal' ? result.roll : `[${result.rawDice}]->${result.roll}`;
            reply += `æˆ˜æ–— ${rollStr} / ${pipeRes.target} ${logStr}`;

            if (result.isSuccess) {
                reply += `\nâœ… ã€å‘½ä¸­!ã€‘`;
                if (result.crit === "crit_success") reply += ` (å…³é”®æˆåŠŸ!)`;
            } else {
                reply += `\nâŒ ã€æœªå‘½ä¸­ã€‘`;
                // å¤±è´¥åŠ å‹åŠ›
                const r = MSRules.updateStress(mctx, 1, "æ”»å‡»å¤±è¯¯");
                reply += `\nğŸ˜« å‹åŠ› +1 (å½“å‰: ${r.newVal})${r.msg}`;

                if (result.crit === "crit_fail") {
                    reply += `\nâ›”â— ã€å…³é”®å¤±è´¥!ã€‘ è§¦å‘æƒŠæ!`;
                    const stress = seal.vars.intGet(mctx, "å‹åŠ›")[0];
                    const pr = MSRules.panicCheck(mctx, stress, true);
                    let panicResult = "";
                    if (pr.isPanic) {
                        panicResult = `ğŸ˜±æƒŠæâ—\næ•ˆæœ: ${pr.desc}`;
                        if (pr.logs && pr.logs.length > 0) panicResult += `\n${pr.logs.join("\n")}`;
                        if (pr.traumaMsg) panicResult += pr.traumaMsg;
                    } else {
                        panicResult = `ğŸ˜Œå®‰å…¨ (æ£€å®šå€¼ > å‹åŠ›)`;
                    }
                    reply += `\næƒŠææ£€å®š(å‹${stress}): 1d20=${pr.roll} -> ${panicResult}`;
                }
            }


            // 10. å‘½ä¸­åæ˜¾ç¤ºä¼¤å®³
            if (result.isSuccess) {
                // [Refactor] ä¼ å…¥ weapon å’Œ distance ä»¥ä¾¿ Pipeline å¤„ç†
                // ç§»é™¤æ‰‹åŠ¨è®¡ç®— dmgExprï¼Œäº¤ç”± Pipeline å¤„ç† (å«è·ç¦»ä¿®æ­£å’Œ dmg_mod)
                const dmgResult = MSRules.rollDamage(mctx, null, weapon, distKey);
                const dmg = dmgResult.result;
                reply += `\nğŸ’¥ é€ æˆä¼¤å®³: ã€${dmg}ã€‘ (${weapon.type})${dmgResult.log}`;
                if (weapon.tags && weapon.tags.includes("AA")) reply += ` [AAåæŠ¤ç”²]`;

                // ç”Ÿæˆå¿«æ·æŒ‡ä»¤
                // [ä¿®æ”¹] æ”¯æŒå¤šé‡ä¼¤å®³ç±»å‹æ˜¾ç¤º (å¦‚ å‡ºè¡€+æƒ¨çƒˆ)
                const cleanType = weapon.type.replace(/\[.*?\]/g, ""); // ç§»é™¤[+]ç­‰æ ‡è®°
                const typeList = cleanType.split(/[+&|]/).map(t => t.trim()).filter(t => t);
                const aaSuffix = (weapon.tags && weapon.tags.includes("AA")) ? " AA" : "";
                let hitCmd = typeList.map(t => `.ms hit ${dmg} ${t}${aaSuffix}`).join(" æˆ– ");
                reply += `\nğŸ‘‰ å¯¹æ–¹è¯·æ‰§è¡Œ: ${hitCmd}`;
            }

            if (weapon.special && weapon.special.target) {
                reply += `\nğŸ¯ ã€æ­¦å™¨ç‰¹æ•ˆã€‘: ${weapon.special.target}`;
            }
            reply += `\nã€ğŸ›¡é˜²å¾¡è§„åˆ™ã€‘å€˜è‹¥ä½ åœ¨æ©ä½“å†…å°„å‡»ï¼Œç›´è‡³ä¸‹å›åˆå‰ä½ éƒ½ä¼šè§†ä¸ºç¦»å¼€æ©ä½“ã€‚`;

            // [M.O.M. Hook] æ”»å‡»æ£€å®šè¯„ä»·
            reply += MOM.react(mctx, "check", { success: result.isSuccess, crit: result.crit, checkType: "combat" });

            // [æ–°å¢] æ£€æŸ¥æ‡¦å¼±çŠ¶æ€ (FORCE_SAVE_VIOLENCE)
            const conditions = MSRules.manageCondition(mctx, "get");
            const hasCowardice = conditions.some(c => {
                let def = MS_CONSTS.CONDITIONS[c.name];
                if (!def) {
                    for (let k in MS_CONSTS.CONDITIONS) {
                        const cDef = MS_CONSTS.CONDITIONS[k];
                        if (cDef.aliases && cDef.aliases.includes(c.name)) { def = cDef; break; }
                    }
                }
                return def && def.special === "FORCE_SAVE_VIOLENCE";
            });
            if (hasCowardice) {
                reply += `\n\nâš ï¸ ã€çŠ¶æ€æç¤º: æ‡¦å¼±ã€‘\næ£€æµ‹åˆ°[æ‡¦å¼±]çŠ¶æ€ï¼Œä½ éœ€è¦é€šè¿‡ä¸€æ¬¡ææƒ§è±å…(åŠ£åŠ¿)æ‰èƒ½è¿›è¡Œæš´åŠ›è¡Œä¸ºã€‚\nğŸ‘‰ è‹¥æœªè¿›è¡Œè±å…ï¼Œè¯·ä½¿ç”¨ .ms undo æ’¤å›æœ¬æ¬¡æ”»å‡»ã€‚`;
            }

            seal.replyToSender(ctx, msg, reply);
            return seal.ext.newCmdExecuteResult(true);
        }
        // æ³¨å†ŒæŒ‡ä»¤ä¸å¸®åŠ©æ–‡æ¡£
        static register(ext) {
            const cmdMs = seal.ext.newCmdItemInfo();
            cmdMs.name = "ms";
            // åŸå§‹å¸®åŠ©æ–‡æ¡£ (ä¿æŒä¸å˜)
            const rawHelp = `ğŸš€ ã€æ¯èˆ°(mothership) å‘˜å·¥æ‰‹å†Œ v1.0.1-betaã€‘
================================================
ğŸ² ã€æ£€å®šä¸è±å…ã€‘
  .ms <å±æ€§/æ•°å€¼> [Â±ä¿®æ­£/+æŠ€èƒ½] [ä¼˜åŠ£+/-]
  â€¢ .ms åŠ›é‡ (æ™®é€šæ£€å®š)
  â€¢ .ms åŠ›é‡+10+ (ä¼˜åŠ¿, åŠ å€¼10)
  â€¢ .ms æˆ˜æ–—+è¿‘èº«ææ–—- (åŠ£åŠ¿, å åŠ æŠ€èƒ½å€¼)
  â€¢ .ms 50 åŠ›é‡ (ç”¨æ•°å€¼æ£€å®š,ç›‘å®ˆæ¨èğŸ”¥)

âš”ï¸ ã€æˆ˜æ–—ä¸è£…å¤‡ã€‘
  .ms wear <æŠ¤ç”²>        ğŸ›¡ï¸ ç©¿æˆ´æŠ¤ç”²(è‡ªåŠ¨è®¾AP/DR)
  .ms hold <æ­¦å™¨>        ğŸ”« æ·»åŠ æ­¦å™¨åˆ°æ­¦å™¨åº“
  .ms atk [ID] [è·ç¦»]    âš”ï¸ æ”»å‡»æ£€å®š(è‡ªåŠ¨ç®—ä¼¤å®³)
  .ms hit <ä¼¤å®³> [ç±»å‹]  ğŸ©¸ æ‰¿ä¼¤ç»“ç®—(è‡ªåŠ¨æ‰£è¡€/æŸä¼¤)
    â”” ä¾‹: .ms hit 10 gun cover:light (æ©ä½“æŠµæ¶ˆ)

ğŸ˜± ã€æƒŠæä¸æŸä¼¤ã€‘
  .ms panic              ğŸ˜± æƒŠææ£€å®š(è‡ªåŠ¨ç»“ç®—æ•ˆæœ)
  .ms w <ç±»å‹>           ğŸ’” æŸ¥é˜…æŸä¼¤è¡¨(ä¸æ‰£è¡€)
  .ms death              ğŸ’€ æ­»äº¡è±å…(æ¿’æ­»æ—¶ç”¨)

ğŸ‘¤ ã€è§’è‰²ç®¡ç†ã€‘
  .ms st (æˆ– me)         ğŸ“Š æŸ¥çœ‹äººç‰©å¡/çŠ¶æ€/è£…å¤‡
  .ms class [èŒç±»]       ğŸ†” è®¾ç½®èŒç±»(è·å¾—ç‰¹æ€§æç¤º)
  .ms make               ğŸ†• ä¸€é”®ç”Ÿæˆæ–°è§’è‰²å±æ€§

ğŸ’¾ ã€å­˜æ¡£ä¸æ—¶é—´ã€‘
  .ms save <å>          ğŸ’¾ æ‰‹åŠ¨å­˜æ¡£
  .ms load <å>          ğŸ“‚ è¯»å–å­˜æ¡£
  .ms back               â³ æ’¤å›ä¸Šä¸€æ­¥æ“ä½œ(åæ‚”è¯)

ğŸ¥ ã€æ¢å¤ä¸ä¼‘æ•´ã€‘
  .ms recover            ğŸ¥ æŸ¥çœ‹åŒ»ç–—ä»·ç›®è¡¨
  .ms recover short      ğŸ›Œ è‡ªç„¶æ„ˆåˆ(6h+,å›æ»¡HP)
  .ms rest               ğŸ§˜ ç¼“è§£å‹åŠ›(æœ€å·®è±å…)
  .ms leave <ç­‰çº§>       ğŸ–ï¸ ä¸Šå²¸ä¼‘å‡(X/C/B/A/S)

ğŸ“¦ ã€ç‰©å“ä¸çŠ¶æ€ã€‘
  .ms use <ç‰©å“>         ğŸ’Š ä½¿ç”¨ç‰©å“(å¦‚å…´å¥‹è¯)
  .ms cond add <å>      ğŸŒ€ æ·»åŠ çŠ¶æ€
  .ms cond rm <å>       ğŸ—‘ï¸ ç§»é™¤çŠ¶æ€
  .ms list               ğŸ“‹ æŸ¥çœ‹å½“å‰æ‰€æœ‰çŠ¶æ€è¯¦è¿°

ğŸ“š ã€æŸ¥è¯¢ä¸è¾…åŠ©ã€‘
  .ms alias [å]         ğŸ” æŸ¥è¯¢å±æ€§åˆ«å
  .ms table <è¡¨å>       ğŸ“– æŸ¥è¡¨(panic/wound/weapon...)

ğŸ’Ÿ  ã€M.O.M.ã€‘
  .ms mom [on/off]       ğŸ’Ÿ å¼€å¯/å…³é—­MOMè¯­è¨€é£æ ¼
================================================
ğŸ’¡ æç¤º: æ”¯æŒä¸­æ–‡æŒ‡ä»¤ (å¦‚ .æ¯èˆ° æ”»å‡»)
ğŸ“ è·ç¦»: adj(é‚»æ¥), close(è¿‘è·), long(è¿œè·), ext(æè·)`;
            // M.O.M. è£…é¥°å¸®åŠ©æ–‡æ¡£
            cmdMs.help = (() => {
                const header = MOM.pick("onboarding_header") || "ğŸ“œ ã€å…¬å¸å‘˜å·¥æ‰‹å†Œã€‘";
                const footer = MOM.pick("onboarding_footer") || "â€œå…¬å¸åˆ©ç›Šé«˜äºä¸€åˆ‡ã€‚â€";
                // å¦‚æœ MOM æœªé…ç½®æ–‡æœ¬ï¼Œåˆ™åªæ˜¾ç¤ºåŸå§‹å¸®åŠ©ï¼Œé¿å…å‡ºç° undefined
                return `${header}\n${rawHelp}\n\n${footer}`;
            })();
            // ä¸»å…¥å£å‡½æ•°
            cmdMs.solve = (ctx, msg, cmdArgs) => {
                try {
                    // [æ–°å¢] å…¼å®¹æ€§å¤„ç†ï¼šå…¨è§’è½¬åŠè§’
                    for (let i = 0; i < cmdArgs.args.length; i++) {
                        cmdArgs.args[i] = cmdArgs.args[i]
                            .replace(/[\uff01-\uff5e]/g, (c) => String.fromCharCode(c.charCodeAt(0) - 0xfee0))
                            .replace(/[\u3000]/g, " ");
                    }
                    // seal.replyToSender(ctx, msg, "è¿™æ˜¯å”¯ä¸€çš„è¾“å‡ºï¼");
                    const mctx = seal.getCtxProxyFirst(ctx, cmdArgs);
                    // æ¯æ¬¡æ‰§è¡ŒæŒ‡ä»¤å‰ï¼Œç¡®ä¿äººç‰©å¡æœ‰é»˜è®¤å€¼ (é˜²æ­¢æŠ¥é”™)
                    MSRules.ensureDefaults(mctx);

                    const val = cmdArgs.getArgN(1) || "";
                    const lowerVal = val.toLowerCase();
                    let command = lowerVal;

                    // 1. ä¼˜å…ˆåŒ¹é…å…¨å­—æŒ‡ä»¤ (é˜²æ­¢ list è¢« l æ•è·)
                    if (["list", "li"].includes(lowerVal)) command = "list";
                    else {
                        // 2. ç²˜è¿æŒ‡ä»¤é¢„å¤„ç† (å¤„ç† .ms rec+10 è¿™ç§æƒ…å†µ)
                        // åŒ¹é…æŒ‡ä»¤å¤´ï¼Œä¸”åç»­è·Ÿçš„æ˜¯æ•°å­—æˆ–ç¬¦å·
                        const match = lowerVal.match(/^(recover|rec|æ¢å¤|æ¢å¾©|rest|r|ç¼“è§£|ç·©è§£|leave|l|ä¼‘å‡|hit|h|å—ä¼¤|å—å‚·)([+\-0-9].*)?$/);
                        if (match) {
                            command = match[1]; // æå–å‡ºçº¯æŒ‡ä»¤éƒ¨åˆ†ï¼Œå¦‚ "recover"
                            // æ³¨æ„: åç¼€éƒ¨åˆ†ä¼šåœ¨å„ handler ä¸­é€šè¿‡ parseExpression é‡æ–°è§£æ
                        }
                    }
                    // === [æ–°å¢] è‡ªåŠ¨å¤‡ä»½é€»è¾‘ ===
                    // å®šä¹‰åªè¯»æŒ‡ä»¤ (ä¸è§¦å‘å¤‡ä»½)
                    // === [æ–°å¢] è‡ªåŠ¨å¤‡ä»½é€»è¾‘ (ç™½åå•æ¨¡å¼) ===
                    const sub = cmdArgs.getArgN(2).toLowerCase();
                    // è¾…åŠ©: åˆ¤æ–­æ˜¯å¦ä¸ºç²˜è¿æŒ‡ä»¤ (å¦‚ hit10, rec+10) -> å¦‚æœ arg1(val) ä¸ç­‰äºè§£æå‡ºçš„ command, è¯´æ˜æœ‰åç¼€
                    const isSticky = val.toLowerCase() !== command;
                    // å®šä¹‰ä¿®æ”¹æŒ‡ä»¤è¡¨ (åªæœ‰åœ¨æ­¤è¡¨ä¸­çš„æŒ‡ä»¤æ‰è§¦å‘å¤‡ä»½)
                    // true = æ€»æ˜¯å¤‡ä»½
                    // function = æ¡ä»¶å¤‡ä»½ (è¿”å› true æ—¶å¤‡ä»½)
                    const modificationRules = {
                        // 1. æ€»æ˜¯ä¿®æ”¹ (Always Modify)
                        "panic": true, "p": true, "æƒŠæ": true, "é©šæ": true,
                        "rest": true, "r": true, "ç¼“è§£": true, "ç·©è§£": true,
                        "death": true, "æ­»": true, "æ­»äº¡": true,
                        "make": true, "new": true, "gen": true, "ç”Ÿæˆ": true, "åˆ¶å¡": true,
                        "atk": true, "attack": true, "æ”»å‡»": true, // æ”»å‡»å¯èƒ½å¤±è´¥åŠ å‹åŠ›

                        // 2. éœ€æ£€æŸ¥å‚æ•° (æœ‰å‚æ•°æ‰ç®—ä¿®æ”¹)
                        "hit": () => isSticky || !(!sub || sub === "help"),
                        "h": "hit", "å—ä¼¤": "hit", "å—å‚·": "hit",

                        "recover": () => isSticky || !(!sub || sub === "help"),
                        "rec": "recover", "æ¢å¤": "recover", "æ¢å¾©": "recover",

                        "leave": () => !!sub, // leave éœ€è¦å‚æ•°
                        "l": "leave", "ä¼‘å‡": "leave",

                        "use": () => !!sub, // use éœ€è¦ç‰©å“å
                        "u": "use", "ä½¿ç”¨": "use",

                        "class": () => !!sub, // class æ— å‚æ˜¯æŸ¥çœ‹
                        "èŒç±»": "class", "è·æ¥­": "class",

                        "wear": () => !!sub,
                        "ç©¿": "wear", "è£…å¤‡": "wear",

                        "hold": () => !(!sub || ["list", "li"].includes(sub)),
                        "æ‹¿": "hold", "æŒæœ‰": "hold",

                        "cond": () => !(!sub || ["list", "li", "help"].includes(sub)),
                        "c": "cond", "çŠ¶æ€": "cond", "ç”Ÿå­˜": "cond", "ç‹€æ…‹": "cond",

                        // 3. ç‰¹æ®Š: æŸ¥çœ‹äººç‰©å¡ (st/me/show) - åªæœ‰å¸¦å‚æ•°ä¿®æ”¹æ—¶æ‰å­˜æ¡£

                        "st": () => !!cmdArgs.getArgN(2),
                        "me": "st", "show": "st",

                        // [æ–°å¢] è¯»æ¡£è§†ä¸ºä¿®æ”¹
                        "load": true, "è¯»æ¡£": true

                    };

                    let isModification = false;
                    let rule = modificationRules[command];
                    if (rule !== undefined) {
                        while (typeof rule === 'string') rule = modificationRules[rule];
                        isModification = (typeof rule === 'function') ? rule() : (!!rule);
                    } else {
                        // å…œåº•: æ£€æŸ¥æ˜¯å¦ä¸ºæœ‰æ•ˆå±æ€§å (è§†ä¸ºæ£€å®šï¼Œæ£€å®šå¯èƒ½å¤±è´¥åŠ å‹åŠ›ï¼Œæ•…éœ€å­˜æ¡£)
                        // é¿å… .ms xyz (æ— æ•ˆæŒ‡ä»¤) è§¦å‘å­˜æ¡£è¦†ç›–å†å²
                        for (let k in MS_CONSTS.ATTR_MAP) {
                            if (k === command || MS_CONSTS.ATTR_MAP[k].includes(command)) {
                                isModification = true;
                                break;
                            }
                        }
                    }

                    if (isModification) {
                        MSStateManager.saveState(mctx);
                    }
                    // ==========================

                    // 3. æŒ‡ä»¤è·¯ç”±
                    switch (command) {
                        case "help": case "":
                            seal.replyToSender(ctx, msg, cmdMs.help);
                            return seal.ext.newCmdExecuteResult(true);

                        case "st": case "me": case "show":
                            return this.handleShowSheet(ctx, msg, cmdArgs);

                        case "panic": case "p": case "æƒŠæ": case "é©šæ":
                            return this.handlePanic(ctx, msg, cmdArgs);

                        case "hit": case "h": case "å—ä¼¤": case "å—å‚·":
                            return this.handleHit(ctx, msg, cmdArgs);

                        case "rest": case "r": case "ç¼“è§£": case "ç·©è§£":
                            return this.handleRelieveStress(ctx, msg, cmdArgs);

                        case "recover": case "rec": case "æ¢å¤": case "æ¢å¾©":
                            return this.handleRecover(ctx, msg, cmdArgs);

                        case "leave": case "l": case "ä¼‘å‡":
                            return this.handleShoreLeave(ctx, msg, cmdArgs);

                        case "wound": case "w": case "æŸä¼¤": case "æå‚·":
                            return this.handleWound(ctx, msg, cmdArgs);

                        case "cond": case "c": case "çŠ¶æ€": case "ç”Ÿå­˜": case "ç‹€æ…‹":
                            return this.handleCondition(ctx, msg, cmdArgs);

                        case "use": case "u": case "ä½¿ç”¨":
                            return this.handleUse(ctx, msg, cmdArgs);

                        case "table": case "t": case "æŸ¥è¡¨":
                            return this.handleTable(ctx, msg, cmdArgs);
                        case "list": case "li":
                            // .ms list æ˜¯ .ms cond list çš„å¿«æ·æ–¹å¼
                            return this.handleCondition(ctx, msg, { getArgN: (n) => (n === 2 ? "list" : "") });
                        case "death": case "æ­»": case "æ­»äº¡":
                            return this.handleDeath(ctx, msg, cmdArgs);
                        // æ–°å¢ make æŒ‡ä»¤
                        case "make": case "new": case "gen": case "ç”Ÿæˆ": case "åˆ¶å¡":
                            return this.handleMake(ctx, msg, cmdArgs);
                        case "class": case "èŒç±»": case "è·æ¥­":
                            return this.handleClass(ctx, msg, cmdArgs);
                        case "alias": case "åˆ«å": case "a": case "aliases":
                            return this.handleAlias(ctx, msg, cmdArgs);
                        case "save": case "å­˜æ¡£":
                            return this.handleSave(ctx, msg, cmdArgs);
                        case "load": case "è¯»æ¡£":
                            return this.handleLoad(ctx, msg, cmdArgs);
                        // --- æˆ˜æ–—ä¸è£…å¤‡ (æ–°å¢æ³¨å†Œ) ---
                        case "wear": case "ç©¿": case "è£…å¤‡":
                            return this.handleWear(ctx, msg, cmdArgs);
                        case "hold": case "æ‹¿": case "æŒæœ‰":
                            return this.handleHold(ctx, msg, cmdArgs);
                        case "atk": case "attack": case "æ”»å‡»":
                            return this.handleAtk(ctx, msg, cmdArgs);
                        case "back": case "undo": case "æ’¤å›":
                            return this.handleBack(ctx, msg, cmdArgs);
                        // MOM æ§åˆ¶
                        case "mom":
                            return this.handleMOM(ctx, msg, cmdArgs);


                        default:
                            // é»˜è®¤ä¸ºå±æ€§æ£€å®š (å¦‚ .ms åŠ›é‡)
                            return this.handleCheck(ctx, msg, cmdArgs);
                    }

                } catch (e) {
                    // ã€ä¿é™©æªæ–½ã€‘å¦‚æœå‘ç”ŸæœªçŸ¥é”™è¯¯ï¼ŒæŠŠé”™è¯¯ä¿¡æ¯åå‡ºæ¥ï¼Œæ–¹ä¾¿è°ƒè¯•
                    seal.replyToSender(ctx, msg, `æ’ä»¶æ‰§è¡Œå‘ç”Ÿé”™è¯¯: ${e.message}`);
                    return seal.ext.newCmdExecuteResult(true);
                }
            }

            ext.cmdMap["ms"] = cmdMs;
            ext.cmdMap["æ¯èˆ°"] = cmdMs;
            // [æ–°å¢] æ³¨å†Œ .st æŒ‡ä»¤ (è¦†ç›–ç³»ç»Ÿé»˜è®¤)
            // const cmdSt = seal.ext.newCmdItemInfo();
            // cmdSt.name = "st";
            // cmdSt.help = "æ¯èˆ°è§„åˆ™ä¸“ç”¨äººç‰©å¡æŒ‡ä»¤ (è¦†ç›–é»˜è®¤.st)";
            // cmdSt.solve = (ctx, msg, cmdArgs) => {
            //     return this.handleShowSheet(ctx, msg, cmdArgs);
            // };
            // ext.cmdMap["st"] = cmdSt;

        }
        // [æ–°å¢] MOM æ§åˆ¶æŒ‡ä»¤
        static handleMOM(ctx, msg, cmdArgs) {
            const mctx = seal.getCtxProxyFirst(ctx, cmdArgs);
            const op = cmdArgs.getArgN(2).toLowerCase();

            if (op === "on" || op === "off") {
                const isOn = MOM.toggle(mctx, op);
                const reply = isOn ? (MOM.pick("startup") || "M.O.M. ç³»ç»Ÿå·²å¯åŠ¨ã€‚") : (MOM.pick("shutdown") || "M.O.M. ç³»ç»Ÿå·²ä¼‘çœ ã€‚");
                seal.replyToSender(ctx, msg, MOM.format(reply));
            } else {
                seal.replyToSender(ctx, msg, "ç”¨æ³•: .ms mom on/off...ä½ æƒ³å…³é—­æˆ‘å—ğŸ¤¬");
            }
            return seal.ext.newCmdExecuteResult(true);
        }

        /**
         * å¤„ç†æ¢å¤ä¸åŒ»ç–— (.ms recover)
         * åˆ†æµé€»è¾‘ï¼š
         * 1. æ— å‚ -> æ˜¾ç¤ºèœå•
         * 2. short/natural -> è‡ªç„¶æ„ˆåˆ
         * 3. åŒ»ç–—é¡¹ç›®å -> åŒ»ç–—æŠ¤ç†
         * 4. çº¯æ•°å€¼ä¿®æ­£ -> é»˜è®¤è‡ªç„¶æ„ˆåˆ
         */
        static handleRecover(ctx, msg, cmdArgs) {
            const mctx = seal.getCtxProxyFirst(ctx, cmdArgs);
            const arg2 = cmdArgs.getArgN(2).toLowerCase();

            // 1. æ˜¾ç¤ºå¸®åŠ©èœå•
            if (!arg2 || arg2 === "help") {
                let helpMsg = `ğŸ¥ ã€æ¯èˆ°æ¢å¤ä¸åŒ»ç–—æŒ‡ä»¤ (.ms recover)ã€‘\n`;
                helpMsg += `==============================\n`;
                helpMsg += `ğŸ›Œ ã€çŸ­æœŸæ¢å¤ (è‡ªç„¶æ„ˆåˆ)ã€‘\n`;
                helpMsg += `  æŒ‡ä»¤: .ms recover short (æˆ– .ms rec)\n`;
                helpMsg += `  æ•ˆæœ: æ¯å¤©ä¸€æ¬¡ï¼Œä¼‘æ¯6h+ã€‚èº«ä½“è±å…æˆåŠŸåˆ™HPå›æ»¡ï¼Œæ€»æ˜¯ç§»é™¤ç–²æƒ«ã€‚\n\n`;

                helpMsg += `ğŸ’‰ ã€é•¿æœŸåŒ»ç–—æŠ¤ç† (Medical Care)ã€‘\n  æŒ‡ä»¤: .ms recover <é¡¹ç›®ä»£ç >\n`;

                for (let k in MS_CONSTS.MEDICAL_CARE) {
                    const item = MS_CONSTS.MEDICAL_CARE[k];
                    const alias = item.aliases[0];
                    // æˆªå–ç®€çŸ­æè¿°ï¼Œé¿å…åˆ·å±
                    const shortDesc = item.desc.split("ã€‚")[0];
                    helpMsg += `  â— ã€${item.name}ã€‘ä»£ç : ${alias}\n | è´¹: ${item.cost} | æ—¶: ${item.time}\n    æ•ˆæœ: ${shortDesc}\n`;
                }
                helpMsg += `\n(ç¤ºä¾‹: .ms rec medpod)`;

                seal.replyToSender(ctx, msg, helpMsg);
                return seal.ext.newCmdExecuteResult(true);
            }

            // 2. æ˜¾å¼è°ƒç”¨è‡ªç„¶æ„ˆåˆ
            if (arg2 === "short" || arg2 === "natural" || arg2 === "s") {
                return this.handleNaturalHealing(ctx, msg, cmdArgs);
            }

            // 3. åŒ¹é…åŒ»ç–—æŠ¤ç† (æ”¯æŒåˆ«å)
            for (let k in MS_CONSTS.MEDICAL_CARE) {
                if (MS_CONSTS.MEDICAL_CARE[k].aliases.includes(arg2)) {
                    return this.handleMedicalCare(ctx, msg, cmdArgs, k);
                }
            }

            // 4. é»˜è®¤å›è½: å¦‚æœå‚æ•°çœ‹èµ·æ¥åƒä¿®æ­£å€¼ï¼Œä¹Ÿè§†ä¸ºè‡ªç„¶æ„ˆåˆ
            if (arg2.match(/^[+\-0-9]+$/) || ["adv", "dis", "+", "-"].includes(arg2)) {
                return this.handleNaturalHealing(ctx, msg, cmdArgs);
            }

            seal.replyToSender(ctx, msg, `âŒ æœªçŸ¥çš„æ¢å¤é€‰é¡¹: ${arg2}ã€‚\nè¯·è¾“å…¥ .ms recover æŸ¥çœ‹å¯ç”¨åˆ—è¡¨ã€‚`);
            return seal.ext.newCmdExecuteResult(true);
        }

        // æ‰§è¡ŒåŒ»ç–—æŠ¤ç†
        static handleMedicalCare(ctx, msg, cmdArgs, key) {
            const mctx = seal.getCtxProxyFirst(ctx, cmdArgs);
            const name = seal.format(ctx, "{$tç©å®¶}");
            const care = MS_CONSTS.MEDICAL_CARE[key];

            // è°ƒç”¨ Data Layer ä¸­å®šä¹‰çš„ apply æ–¹æ³•
            const { msg: resultMsg, hasSideEffect } = care.apply(mctx);

            // [M.O.M. Hook] åŒ»ç–—æŠ¤ç†è¯„ä»·
            const momReact = MOM.react(mctx, "medical", { item: care.name, hasSideEffect: hasSideEffect });


            seal.replyToSender(ctx, msg, `${name} æ¥å—æŠ¤ç†: ${care.name}\n----------------\nğŸ’° è´¹ç”¨: ${care.cost}\nâ³ è€—æ—¶: ${care.time}\nğŸ“‹ æ•ˆæœ: ${care.desc}\n----------------\nğŸ“ ç»“æœ:\n${resultMsg}${momReact}`);
            return seal.ext.newCmdExecuteResult(true);
        }

        // æ‰§è¡Œè‡ªç„¶æ„ˆåˆ (Short Term)
        static handleNaturalHealing(ctx, msg, cmdArgs) {
            const mctx = seal.getCtxProxyFirst(ctx, cmdArgs);
            const name = seal.format(ctx, "{$tç©å®¶}");
            const body = seal.vars.intGet(mctx, "èº«ä½“")[0];

            if (!body) { seal.replyToSender(ctx, msg, "æ— æ³•è·å–ã€èº«ä½“ã€‘å±æ€§ã€‚"); return seal.ext.newCmdExecuteResult(true); }

            // è§£æå‚æ•° (å‰”é™¤æŒ‡ä»¤å…³é”®è¯)
            let args = "";
            for (let i = 0; i < cmdArgs.args.length; i++) {
                const arg = cmdArgs.args[i];
                if (arg.match(/^(recover|rec|æ¢å¤|æ¢å¾©)/i)) {
                    const m = arg.match(/^(?:recover|rec|æ¢å¤|æ¢å¾©)(.*)$/i);
                    if (m && m[1]) args += m[1] + " ";
                    continue;
                }
                if (arg.toLowerCase().match(/^(short|natural|s)$/)) continue;
                args += arg + " ";
            }

            const parsed = MSRules.parseExpression(mctx, args);

            // [Refactor] ä½¿ç”¨ Pipeline
            const checkCtx = new CheckContext(mctx, "èº«ä½“", body);
            if (parsed.totalValue !== 0) checkCtx.addMod(parsed.totalValue, parsed.desc || "æŒ‡ä»¤");
            if (parsed.mode === 'adv') checkCtx.addAdv('adv', 'æŒ‡ä»¤');
            if (parsed.mode === 'dis') checkCtx.addAdv('dis', 'æŒ‡ä»¤');

            const pipeRes = MSPipeline.process(checkCtx);
            const result = MSRules.rollCheck(pipeRes.target, pipeRes.mode);

            const maxHp = seal.vars.intGet(mctx, "ç”Ÿå‘½å€¼ä¸Šé™")[0] || 10;
            let resultMsg = "";

            // è‡ªåŠ¨ç§»é™¤ç–²æƒ« (è§„åˆ™ç‰¹æ€§)
            const removed = MSRules.manageCondition(mctx, "remove", "ç–²æƒ«");
            let fatigueMsg = removed ? "\nğŸŒ€ å·²ç§»é™¤ã€ç–²æƒ«ã€‘çŠ¶æ€ã€‚" : "";

            if (result.isSuccess) {
                seal.vars.intSet(mctx, "ç”Ÿå‘½å€¼", maxHp);
                resultMsg = `âœ… æ„ˆåˆæˆåŠŸ! HPæ¢å¤è‡³ä¸Šé™(${maxHp})ã€‚`;
            } else {
                // å¤±è´¥å¢åŠ å‹åŠ› (é€šç”¨è§„åˆ™)
                const r = MSRules.updateStress(mctx, 1);
                resultMsg = `âŒ æ„ˆåˆå¤±è´¥... HPæœªæ¢å¤ã€‚å‹åŠ› +1 (å½“å‰:${r.newVal})${r.msg}`;

                if (result.crit === "crit_fail") {
                    resultMsg += `\nâ›”â— å…³é”®å¤±è´¥! è§¦å‘æƒŠæ!`;
                    const s = seal.vars.intGet(mctx, "å‹åŠ›")[0];
                    const pr = MSRules.panicCheck(mctx, s, true);
                    resultMsg += `\næƒŠææ£€å®š(å‹${s}): 1d20=${pr.roll} -> ${pr.desc}\n${pr.logs.join("\n")}${pr.traumaMsg}`;
                }
            }

            // èŒç±»ç‰¹æ•ˆæ£€æŸ¥ (è™½ç„¶è‡ªç„¶æ„ˆåˆæ˜¯èº«ä½“è±å…ï¼Œä¸€èˆ¬ä¸æ¶‰åŠç§‘å­¦å®¶ï¼Œä½†ä¿æŒä¸€è‡´æ€§)
            resultMsg += MSRules.getTraumaWarning(mctx, "èº«ä½“", result.isSuccess);

            // [M.O.M. Hook] è‡ªç„¶æ¢å¤è¯„ä»·
            resultMsg += MOM.react(mctx, "recover", { success: result.isSuccess });


            const displayRoll = result.roll === 0 ? "00" : result.roll;
            let rollDetail = `${displayRoll}`;
            if (result.mode === 'adv') rollDetail = `[${result.rawDice.join(", ")}] å–ä½ -> ${displayRoll}`;
            else if (result.mode === 'dis') rollDetail = `[${result.rawDice.join(", ")}] å–é«˜ -> ${displayRoll}`;

            let logStr = pipeRes.logs.length > 0 ? `\nğŸ”§ ä¿®æ­£ ${pipeRes.logs.join(", ")}` : "";
            seal.replyToSender(ctx, msg, `${name} è‡ªç„¶æ„ˆåˆ(6h+):\nèº«ä½“è±å…(${body}): ${rollDetail} / ${pipeRes.target} ${logStr} -> ${resultMsg}${fatigueMsg}`);
            return seal.ext.newCmdExecuteResult(true);
        }
        // æ ¼å¼åŒ–çŠ¶æ€åˆ—è¡¨ (å«æ·±åº¦æŸ¥æ‰¾)
        // static formatConditionList(list) {
        //     if (!list || list.length === 0) return "æ— ";
        //     let txt = "";

        //     list.forEach(i => {
        //         let desc = "";

        //         // 1. å°è¯•åœ¨ç”Ÿå­˜çŠ¶æ€è¡¨ä¸­æŸ¥æ‰¾
        //         let def = MS_CONSTS.SURVIVAL_CONDITIONS[i.name];

        //         // 2. å°è¯•åœ¨æ¡ä»¶è¡¨(æƒŠæ/åŒ»ç–—)ä¸­æŸ¥æ‰¾
        //         if (!def) {
        //             let pDef = MS_CONSTS.CONDITIONS[i.name];

        //             // 2.1 å°è¯•é€šè¿‡åˆ«ååæŸ¥
        //             if (!pDef) {
        //                 for (let k in MS_CONSTS.CONDITIONS) {
        //                     if (MS_CONSTS.CONDITIONS[k].aliases.includes(i.name)) {
        //                         pDef = MS_CONSTS.CONDITIONS[k];
        //                         break;
        //                     }
        //                 }
        //             }

        //             // 2.2 å¦‚æœæ‰¾åˆ°å®šä¹‰
        //             if (pDef) {
        //                 desc = pDef.detail || pDef.summary || "æ— æè¿°";
        //             }
        //             // 3. Fallback: å°è¯•åœ¨æŸä¼¤è¡¨æ–‡æœ¬ä¸­æŸ¥æ‰¾åŒ¹é… (è§£å†³ .ms w äº§ç”Ÿçš„æœªçŸ¥çŠ¶æ€)
        //             else {
        //                 let woundFound = false;
        //                 for (let wk in MS_CONSTS.WOUND_TABLE) {
        //                     const table = MS_CONSTS.WOUND_TABLE[wk].table;
        //                     for (let entry of table) {
        //                         // [ä¿®å¤å…³é”®ç‚¹] å…¼å®¹æ–°æ—§ç»“æ„
        //                         // æ–°ç»“æ„æ˜¯å¯¹è±¡ï¼Œå¿…é¡»æŸ¥ .desc æˆ– .cond
        //                         // æ—§ç»“æ„(å¦‚æœæœ‰æ®‹ç•™)æ˜¯å­—ç¬¦ä¸²
        //                         let textToCheck = "";
        //                         let fullDesc = "";

        //                         if (typeof entry === 'string') {
        //                             textToCheck = entry;
        //                             fullDesc = entry;
        //                         } else {
        //                             // æ–°ç»“æ„: { sev, desc, cond ... }
        //                             textToCheck = entry.desc + (entry.cond || "");
        //                             fullDesc = `ã€${entry.sev}ã€‘${entry.desc}`;
        //                         }

        //                         if (textToCheck.includes(i.name)) {
        //                             desc = fullDesc;
        //                             woundFound = true;
        //                             break;
        //                         }
        //                     }
        //                     if (woundFound) break;
        //                 }
        //             }
        //         } else {
        //             desc = def.desc || def.summary;
        //         }

        //         if (!desc) desc = "æœªçŸ¥æ•ˆæœ (è‡ªå®šä¹‰çŠ¶æ€)";
        //         if (i.extra) desc = desc.replace("{duration}", i.extra);

        //         let stackInfo = "";
        //         if (def && def.stackable && i.val > 1) {
        //             stackInfo = ` (Lv.${i.val})`;
        //         }

        //         txt += `   â— ${i.name}${stackInfo}: ${desc}\n`;
        //     });
        //     return txt;
        // }
        // MSCommands ç±»å†…éƒ¨
        static formatConditionList(list) {
            if (!list || list.length === 0) return "âœ¨ å½“å‰èº«ä½“å¥åº·ï¼Œæœªå—ä»»ä½•é•¿æœŸçŠ¶æ€å½±å“ã€‚";

            let output = "";

            list.forEach(item => {
                // item ç»“æ„: { name: "å‡ºè¡€", val: 2, duration: "4åˆ†é’Ÿ", desc: "..." }

                // 1. æ„å»ºå¤´éƒ¨ä¿¡æ¯ (åç§° + å±‚æ•° + æ—¶é—´)
                let header = `â— ã€${item.name}ã€‘`;

                // å±‚æ•°æ˜¾ç¤º (å¦‚æœæ˜¯å¯å †å çŠ¶æ€)
                if (item.val > 1) {
                    header += ` (Lv.${item.val})`;
                }

                // æŒç»­æ—¶é—´æ˜¾ç¤º (è¿™æ˜¯æœ¬æ¬¡é‡æ„çš„é‡ç‚¹)
                if (item.duration) {
                    if (item.duration === "æ°¸ä¹…" || item.duration === "permanent") {
                        header += ` [â™¾ï¸æ°¸ä¹…]`;
                    } else if (item.duration !== "æ— é™" && item.duration !== "infinite") {
                        // å¯¹äºå€’è®¡æ—¶ç±»çš„ï¼ŒåŠ ä¸ªæ²™æ¼å›¾æ ‡
                        header += ` [â³${item.duration}]`;
                    }
                }

                // 2. æ„å»ºæè¿°ä¿¡æ¯
                // ä¼˜å…ˆä½¿ç”¨å­˜å‚¨çš„å¿«ç…§æè¿° (item.desc)ï¼Œè¿™ä¿è¯äº†å³ä½¿ä½ ä¿®æ”¹äº†è§„åˆ™ä»£ç ï¼Œ
                // ç©å®¶èº«ä¸Šå·²æœ‰çš„æ—§çŠ¶æ€æè¿°ä¹Ÿä¸ä¼šçªå˜ï¼Œä¿è¯äº†æ•°æ®çš„â€œå†å²çœŸå®æ€§â€ã€‚
                let description = item.desc;

                // [å…¼å®¹æ€§å…œåº•] å¦‚æœæ˜¯æ—§æ•°æ®æ²¡æœ‰ descï¼Œæ‰å»æŸ¥å¸¸é‡è¡¨
                if (!description) {
                    const def = MS_CONSTS.CONDITIONS[item.name];
                    // å°è¯•è·å– summaryï¼Œå¦‚æœæ²¡æœ‰åˆ™å°è¯•ä» modifiers è‡ªåŠ¨ç”Ÿæˆæè¿°
                    if (def) {
                        description = def.summary;
                    } else {
                        description = "æœªçŸ¥æ•ˆæœ (è‡ªå®šä¹‰çŠ¶æ€)";
                    }
                }

                // 3. æ‹¼è£…
                output += `${header}\n   â”” ${description}\n`;
            });

            return output;
        }

        // çŠ¶æ€ç®¡ç†æŒ‡ä»¤ (.ms cond / .ms list)
        static handleCondition(ctx, msg, cmdArgs) {
            const mctx = seal.getCtxProxyFirst(ctx, cmdArgs);
            // å…¼å®¹ .ms list çš„å‚æ•°ä½ç½®
            const sub = (typeof cmdArgs.getArgN === 'function') ? cmdArgs.getArgN(2).toLowerCase() : "list";
            const name = (typeof cmdArgs.getArgN === 'function') ? cmdArgs.getArgN(3) : "";
            const valArg = (typeof cmdArgs.getArgN === 'function') ? cmdArgs.getArgN(4) : "";
            let val = parseInt(valArg) || 1;

            if (!sub || sub === "help") {
                const help = `ğŸŒ€ **å»¶æ—¶æ€§å½±å“æŒ‡ä»¤å¸®åŠ©**
================================
  .ms cond add           - åˆ—å‡ºæ‰€æœ‰é¢„è®¾çŠ¶æ€
  .ms cond add <å> [å±‚] - æ·»åŠ çŠ¶æ€ (ä¾‹: .ms cond add å‡ºè¡€ 2)
  .ms cond rm            - åˆ—å‡ºå½“å‰çŠ¶æ€ä»¥ä¾¿ç§»é™¤
  .ms cond rm <å>       - ç§»é™¤æŒ‡å®šçŠ¶æ€
  .ms list               - æŸ¥çœ‹å½“å‰æ‰€æœ‰çŠ¶æ€è¯¦è¿°
================================`;
                seal.replyToSender(ctx, msg, help);
                return seal.ext.newCmdExecuteResult(true);
            }

            if (sub === "add" || sub === "a") {
                if (!name) {
                    let txt = "=== å¯æ·»åŠ çš„ç”Ÿå­˜çŠ¶æ€ (.ms cond add <åç§°>) ===\n";
                    for (let k in MS_CONSTS.SURVIVAL_CONDITIONS) {
                        const def = MS_CONSTS.SURVIVAL_CONDITIONS[k];
                        txt += `â— ${k}: ${def.summary}\n`;
                    }
                    seal.replyToSender(ctx, msg, txt);
                    return seal.ext.newCmdExecuteResult(true);
                }
                const resMsg = MSRules.manageCondition(mctx, "add", name, val);
                seal.replyToSender(ctx, msg, resMsg);

            } else if (sub === "remove" || sub === "rm" || sub === "del") {
                if (!name) {
                    const list = MSRules.manageCondition(mctx, "get");
                    const formatted = MSCommands.formatConditionList(list);
                    seal.replyToSender(ctx, msg, `å½“å‰çŠ¶æ€(è¯·æŒ‡å®šåç§°åˆ é™¤):\n${formatted}`);
                    return seal.ext.newCmdExecuteResult(true);
                }
                const removedName = MSRules.manageCondition(mctx, "remove", name);
                if (removedName) {
                    const list = MSRules.manageCondition(mctx, "get");
                    const formatted = MSCommands.formatConditionList(list);
                    seal.replyToSender(ctx, msg, `å·²ç§»é™¤ã€${removedName}ã€‘ã€‚\nå‰©ä½™çŠ¶æ€:\n${formatted}`);
                } else {
                    seal.replyToSender(ctx, msg, `æœªæ‰¾åˆ°çŠ¶æ€: ${name}`);
                }

            } else if (sub === "clear") {
                MSRules.manageCondition(mctx, "clear");
                seal.replyToSender(ctx, msg, "å·²æ¸…ç©ºæ‰€æœ‰çŠ¶æ€ã€‚");

            } else {
                const list = MSRules.manageCondition(mctx, "get");
                if (list.length === 0) {
                    seal.replyToSender(ctx, msg, "å½“å‰æ— ä»»ä½•å»¶æ—¶æ€§å½±å“ã€‚");
                } else {
                    const formatted = MSCommands.formatConditionList(list);
                    seal.replyToSender(ctx, msg, `=== å½“å‰çŠ¶æ€ ===\n${formatted}`);
                }
            }
            return seal.ext.newCmdExecuteResult(true);
        }
        // æ­»äº¡è±å… (.ms death)
        static handleDeath(ctx, msg, cmdArgs) {
            const mctx = seal.getCtxProxyFirst(ctx, cmdArgs);
            const name = seal.format(ctx, "{$tç©å®¶}");

            let manualMode = "normal";
            for (let i = 0; i < cmdArgs.args.length; i++) {
                const arg = cmdArgs.args[i].toLowerCase();
                if (["adv", "ä¼˜åŠ¿", "+"].includes(arg)) manualMode = "adv";
                if (["dis", "åŠ£åŠ¿", "-"].includes(arg)) manualMode = "dis";
            }

            const result = MSRules.deathCheck(mctx, manualMode);

            let reply = `${name} è¿›è¡Œæ­»äº¡è±å… (1d10):\nğŸ² ç»“æœ: ${result.detail}\nğŸ’€ ç»“å±€: ${result.effect}`;

            if (result.logs.length > 0) {
                reply += `\nğŸ”§ ä¿®æ­£: ${result.logs.join(", ")}`;
            }

            // [M.O.M. Hook] æ­»äº¡è±å…è¯„ä»· (roll >= 5 é€šå¸¸æ„å‘³ç€æ­»äº¡/é€€åœº)
            reply += MOM.react(mctx, "death", { isDead: result.roll >= 5 });

            seal.replyToSender(ctx, msg, reply);
            return seal.ext.newCmdExecuteResult(true);
        }
        static handleMake(ctx, msg, cmdArgs) {
            const mctx = seal.getCtxProxyFirst(ctx, cmdArgs);
            const name = seal.format(ctx, "{$tç©å®¶}");

            // 1. å±æ€§ (Stats): 2d10 + 25
            const stats = ["åŠ›é‡", "é€Ÿåº¦", "æ™ºåŠ›", "æˆ˜æ–—"];
            let statMsg = "";
            stats.forEach(key => {
                const r1 = Math.floor(Math.random() * 10) + 1;
                const r2 = Math.floor(Math.random() * 10) + 1;
                const val = r1 + r2 + 25;
                seal.vars.intSet(mctx, key, val);
                statMsg += `${key}${val} `;
            });

            // 2. è±å… (Saves): 2d10 + 10
            const saves = ["ç†æ™º", "ææƒ§", "èº«ä½“"];
            let saveMsg = "";
            saves.forEach(key => {
                const r1 = Math.floor(Math.random() * 10) + 1;
                const r2 = Math.floor(Math.random() * 10) + 1;
                const val = r1 + r2 + 10;
                seal.vars.intSet(mctx, key, val);
                saveMsg += `${key}${val} `;
            });

            // 3. ç”Ÿå‘½å€¼ (Health): 1d10 + 10
            const hpRoll = Math.floor(Math.random() * 10) + 1;
            const maxHp = hpRoll + 10;
            seal.vars.intSet(mctx, "ç”Ÿå‘½å€¼", maxHp);
            seal.vars.intSet(mctx, "ç”Ÿå‘½å€¼ä¸Šé™", maxHp);

            // 4. å‹åŠ› (Stress): åˆå§‹ 2
            seal.vars.intSet(mctx, "å‹åŠ›", 2);
            seal.vars.intSet(mctx, "å‹åŠ›ä¸‹é™", 2);

            // 5. æŸä¼¤ (Wounds): åˆå§‹ 0, ä¸Šé™ 2 (é»˜è®¤)
            seal.vars.intSet(mctx, "æŸä¼¤", 0);
            seal.vars.intSet(mctx, "æŸä¼¤ä¸Šé™", 2);

            // 6. ä¿¡ç”¨ç‚¹ (Credits): 2d10 * 10
            const c1 = Math.floor(Math.random() * 10) + 1;
            const c2 = Math.floor(Math.random() * 10) + 1;
            const credits = (c1 + c2) * 10;
            // è¿™é‡Œåªæ˜¯ç”Ÿæˆï¼ŒSealDiceé»˜è®¤å¯èƒ½æ²¡æœ‰creditså±æ€§ï¼Œæˆ‘ä»¬å¯ä»¥å­˜ä¸€ä¸ª
            seal.vars.intSet(mctx, "ä¿¡ç”¨ç‚¹", credits);

            // 7. æ¸…ç©ºçŠ¶æ€å’ŒèŒç±» (é‡ç½®)
            seal.vars.strSet(mctx, "ms_conditions", "[]");
            seal.vars.strSet(mctx, "èŒç±»", 0);

            const reply = `${name} çš„æ¯èˆ°è§’è‰²ç”Ÿæˆå®Œæ¯•ï¼š
  ------------------------------
  ğŸ“Š å±æ€§: ${statMsg}
  ğŸ›¡ è±å…: ${saveMsg}
  â¤ï¸ ç”Ÿå‘½: ${maxHp} | ğŸ’” æŸä¼¤ä¸Šé™: 2 | ğŸ˜« å‹åŠ›: 2
  ğŸ’° ä¿¡ç”¨ç‚¹: ${credits}cr
  ------------------------------
  æ•°æ®å·²è‡ªåŠ¨å½•å…¥ã€‚
  æ¥ä¸‹æ¥è¯·ä½¿ç”¨ .ms class <èŒç±»> æ¥é€‰æ‹©èŒç±»å¹¶æ‰‹åŠ¨è°ƒæ•´å±æ€§åŠ æˆã€‚`;

            seal.replyToSender(ctx, msg, reply);
            return seal.ext.newCmdExecuteResult(true);
        }
        // ... å…¶ä»–æŒ‡ä»¤å¤„ç†å‡½æ•° ...
        // ä¸ºä¿æŒä»£ç ç®€æ´ï¼Œå¤ç”¨ä¹‹å‰ç‰ˆæœ¬çš„é€»è¾‘ï¼Œä½†éœ€ç¡®ä¿è°ƒç”¨æ–°çš„ formatConditionList
        // åŒ…æ‹¬: handleShowSheet, handleTable, handleHit, handleWound, handleUse, handlePanic, handleRelieveStress, handleShoreLeave, handleCheck, handleClass
        // [AI Note] åœ¨å®é™…ç”Ÿæˆæ—¶ï¼Œè¿™é‡Œéœ€è¦å®Œæ•´åŒ…å«æ‰€æœ‰ Handlerï¼Œä»¥ä¸‹æ˜¯ç²¾ç®€å¼•ç”¨:
        static handleTable(ctx, msg, cmdArgs) {
            /* å¤ç”¨ v3.2.1 é€»è¾‘ */
            const t = cmdArgs.getArgN(2).toLowerCase();
            const d = cmdArgs.getArgN(3).toLowerCase();
            const id = (d === "detail" || d === "d" || d === "è¯¦ç»†" || d === "è©³ç´°");
            let o = "";
            if (t.startsWith("pan") || t.startsWith("æƒŠæ") || t.startsWith("é©šæ")) {
                o = "=== ğŸ˜± æ¯èˆ°æƒŠæè¡¨ (1d20) ===\n";
                for (let i = 1; i <= 20; i++) {
                    let d = MS_CONSTS.PANIC_TABLE[i].desc;
                    d = d.replace("{duration}", MS_CONSTS.PANIC_TABLE[i].duration || "æ—¶é—´").replace("{condition}", MS_CONSTS.PANIC_TABLE[i].condition || "çŠ¶æ€");
                    o += `$ {				i          }.$ {            d          }\n`;
                }
                o += "\n=== æƒŠæçŠ¶æ€ (Conditions) ===\n";
                for (let k in MS_CONSTS.CONDITIONS) {
                    const def = MS_CONSTS.CONDITIONS[k];
                    o += `â—$ {            k          }: $ {            id ? def.detail: (def.summary + " (è¯¦è§detail)")          }\n`;
                }
            } else if (t.startsWith("wou") || t.startsWith("æŸä¼¤") || t.startsWith("æå‚·")) {
                o = "=== ğŸ’” æ¯èˆ°æŸä¼¤è¡¨ (1d10) ===\nğŸ‘‰ è¯·ä½¿ç”¨ .ms w <ç±»å‹> è¿›è¡ŒæŠ½å–ã€‚\nç±»å‹: é’å‡»(b), å‡ºè¡€(c), æªå‡»(g), ç«ç„°(f), æƒ¨çƒˆ(m)";
            } else if (t.startsWith("sur") || t.startsWith("ç”Ÿå­˜")) {
                o = `=== ğŸŒ€ ç”Ÿå­˜çŠ¶æ€ (Survival) [${id ? "è¯¦ç»†" : "ç®€è¿°"
                    }] ===\n`;
                for (let k in MS_CONSTS.SURVIVAL_CONDITIONS) {
                    const def = MS_CONSTS.SURVIVAL_CONDITIONS[k];
                    o += `â—$ {            k          }: $ {            id ? def.desc: def.summary          }\n`;
                }
                if (!id) o += "(æç¤º: è¾“å…¥ .ms table survival detail æŸ¥çœ‹è¯¦ç»†è§„åˆ™)";
            } else if (t.startsWith("ite") || t.startsWith("ç‰©å“")) {
                o = "=== ğŸ“¦ ç‰©å“åˆ—è¡¨ (ä½¿ç”¨ .ms use <ç‰©å“>) ===\n";
                for (let k in MS_CONSTS.ITEMS) {
                    const i = MS_CONSTS.ITEMS[k];
                    o += `â—$ {            i.name          }: $ {            i.desc          }\n`;
                }
            } else if (t.startsWith("med") || t.startsWith("åŒ»ç–—")) {
                o = "=== ğŸ¥ åŒ»ç–—æŠ¤ç† (Medical Care) ===\nğŸ‘‰ ä½¿ç”¨ .ms recover <ä»£ç > è¿›è¡ŒæŠ¤ç†\n";
                for (let k in MS_CONSTS.MEDICAL_CARE) {
                    const m = MS_CONSTS.MEDICAL_CARE[k];
                    o += `ğŸš‘$ {            m.name          } [$ {            m.aliases[0]          }]\nè´¹ç”¨: $ {            m.cost          } | æ—¶é—´: $ {            m.time          }\n $ {            m.desc          }\n`;
                }
            } // 1. æ­¦å™¨è¡¨æŸ¥è¯¢
            if (t.startsWith("weapon") || t.startsWith("æ­¦å™¨")) {
                o = "=== ğŸ”« æ¯èˆ°æ­¦å™¨åº“ ===\næ ¼å¼: åç§° | ä¼¤å®³ | èŒƒå›´ | ç‰¹æ®Š\n------------------\n";
                for (let k in MS_CONSTS.WEAPON_DB) {
                    const w = MS_CONSTS.WEAPON_DB[k];
                    // ä»…æ˜¾ç¤ºä¸­æ–‡åˆ«åä¸­çš„ç¬¬ä¸€ä¸ªï¼Œæˆ–keyæœ¬èº«
                    const name = w.aliases ? w.aliases.find(a => /[\u4e00-\u9fa5]/.test(a)) || k : k;
                    const aa = (w.tags && w.tags.includes("AA")) ? "[AA]" : "";
                    o += `ğŸ”¹${k}(${name}): ${w.dmg} ${aa}| ${w.type}\n`;
                }
                o += "------------------\nä½¿ç”¨ .ms hold <åç§°> æŒæœ‰";
            }

            // 2. æŠ¤ç”²è¡¨æŸ¥è¯¢
            else if (t.startsWith("armor") || t.startsWith("æŠ¤ç”²")) {
                o = "=== ğŸ›¡ï¸ æ¯èˆ°æŠ¤ç”²åº“ ===\næ ¼å¼: åç§° | AP | DR | ç‰¹æ€§\n------------------\n";
                for (let k in MS_CONSTS.ARMOR_DB) {
                    const a = MS_CONSTS.ARMOR_DB[k];
                    let passive = "";
                    if (a.modifiers) passive = " " + a.modifiers.map(m => `(${m.target}${m.type === 'dis' ? 'åŠ£' : 'ä¼˜'})`).join("");
                    o += `ğŸ”¸${k}: AP ${a.ap} / DR ${a.dr}${passive}\n`;
                }
                o += "------------------\nä½¿ç”¨ .ms wear <åç§°> ç©¿æˆ´";
            }

            // 3. æ©ä½“è¡¨æŸ¥è¯¢
            else if (t.startsWith("cover") || t.startsWith("æ©ä½“")) {
                o = "=== ğŸ§± æ©ä½“å‚è€ƒ ===\n";
                for (let k in MS_CONSTS.COVER_DB) {
                    const c = MS_CONSTS.COVER_DB[k];
                    const dro = c.dr ? ` (DR ${c.dr})` : "";
                    o += `â–ªï¸ ${c.name}: AP ${c.ap}${drText}\n   åˆ«å: ${c.aliases.join(", ")}\n`;
                }
            }

            // 4. è·ç¦»è¡¨æŸ¥è¯¢
            else if (t.startsWith("range") || t.startsWith("è·ç¦»")) {
                o = "=== ğŸ“ è·ç¦»å®šä¹‰ ===\n";
                o += "é‚»æ¥ (Adjacent): è§¦æ‰‹å¯åŠï¼Œè‚‰æ\n";
                o += "è¿‘è· (Close): åŒä¸€æˆ¿é—´ï¼ŒçŸ­å…µç›¸æ¥\n";
                o += "è¿œè· (Long): è·¨è¶Šèµ°å»Šï¼Œç”šè‡³æ›´è¿œ\n";
                o += "æè· (Extreme): è§†é‡è¾¹ç¼˜ï¼Œç‹™å‡»è·ç¦»\n";
            }

            else {
                o = "å¯ç”¨è¡¨: survival (ç”Ÿå­˜), panic (æƒŠæ), wound (æŸä¼¤), items (ç‰©å“), medical (åŒ»ç–—)";
            }
            seal.replyToSender(ctx, msg, o);
            return seal.ext.newCmdExecuteResult(true);

        }
        // static handleHit(ctx, msg, cmdArgs) { /* å¤ç”¨ v3.2.1 é€»è¾‘ */ const mctx=seal.getCtxProxyFirst(ctx,cmdArgs);const n=seal.format(ctx,"{$tç©å®¶}");let da=cmdArgs.getArgN(2);let ta=cmdArgs.getArgN(3);if(!da&&cmdArgs.args[0].match(/^(hit|h|å—ä¼¤|å—å‚·)(\d+)$/i)){const m=cmdArgs.args[0].match(/^(?:hit|h|å—ä¼¤|å—å‚·)(\d+)$/i);da=m[1];ta=cmdArgs.getArgN(1);}const d=parseInt(da);if(isNaN(d)||d<0){seal.replyToSender(ctx,msg,"âŒ è¯·æŒ‡å®šæœ‰æ•ˆçš„ä¼¤å®³æ•°å€¼ã€‚ä¾‹: .ms hit 5");return seal.ext.newCmdExecuteResult(true);}const hp=seal.vars.intGet(mctx,"ç”Ÿå‘½å€¼")[0];if(hp-d<=0){let hvt=false;if(ta){const tk=ta.toLowerCase();for(let k in MS_CONSTS.WOUND_TABLE){if(MS_CONSTS.WOUND_TABLE[k].aliases.includes(tk)){hvt=true;break;}}}if(!hvt){seal.replyToSender(ctx,msg,`âš ï¸ ä¼¤å®³(${d})å°†å¯¼è‡´ç”Ÿå‘½å€¼(${hp})å½’é›¶ï¼\nâŒ å¿…é¡»æŒ‡å®šæŸä¼¤ç±»å‹æ‰èƒ½ç»“ç®—è‡´å‘½ä¼¤ã€‚\nè¯·é‡è¯•: .ms hit ${d} <ç±»å‹>\n(ç±»å‹: blunt/bleeding/gunshot/fire/gore)`);return seal.ext.newCmdExecuteResult(true);}}const r=MSRules.resolveDamage(mctx,d,ta);seal.replyToSender(ctx,msg,`${n} ç»“ç®—ä¼¤å®³:\n${r}`);return seal.ext.newCmdExecuteResult(true);}
        // å—åˆ°ä¼¤å®³ (.ms hit) - åŠ¨æ€æç¤ºç‰ˆ
        // ==========================================
        // ä¿®æ”¹ 2: MSCommands.handleHit (è§£æ force å‚æ•°)
        // ==========================================
        static handleHit(ctx, msg, cmdArgs) {
            const mctx = seal.getCtxProxyFirst(ctx, cmdArgs);
            const name = seal.format(ctx, "{$tç©å®¶}");
            // 1. å¸®åŠ©ä¿¡æ¯æ£€æµ‹ (arg2 is the first argument after .ms hit)
            const arg2 = cmdArgs.getArgN(2);
            if (!arg2 || arg2.toLowerCase() === "help") {
                const help = `ğŸ©¸ ã€æ¯èˆ°ä¼¤å®³ç»“ç®— (.ms hit)ã€‘
  ================================
  ç”¨æ³•: .ms hit <ä¼¤å®³> [ç±»å‹] [cover:æ©ä½“] [AA] [apX] [drY]
  
  å‚æ•°è¯´æ˜:
  â€¢ **ä¼¤å®³**: æ•°å€¼ (å¿…å¡«)
  â€¢ **ç±»å‹**: æŸä¼¤ç±»å‹ (gun, fire, blunt, gore, bleeding)ã€‚
             *è‹¥ä¼¤å®³è¶³ä»¥è‡´æ­»/é€ æˆæŸä¼¤ï¼Œå¿…é¡»æŒ‡å®šç±»å‹ã€‚*
  â€¢ **cover**: æ©ä½“APå€¼æˆ–å…³é”®è¯ (soft/5, light/10, heavy/20)
  â€¢ **ap/dr**: æ‰‹åŠ¨æŒ‡å®šæ©ä½“æ•°å€¼ (å¦‚ ap10 dr2)ï¼Œå¯è¦†ç›–coveré¢„è®¾ã€‚
  â€¢ **AA**: åæŠ¤ç”² (æ— è§†APï¼Œç ´åæŠ¤ç”²)
  
  ç¤ºä¾‹:
    .ms hit 5 (æ™®é€šæ‰£è¡€)
    .ms hit 15 gun (æªå‡»ï¼Œå¯èƒ½é€ æˆæŸä¼¤)
    .ms hit 20 blast cover:heavy AA (é‡å‹æ©ä½“ä¹ŸæŒ¡ä¸ä½çš„æ”»å‡»)
    .ms hit 10 ap5 (è‡ªå®šä¹‰5ç‚¹æ©ä½“AP)
  ================================`;
                seal.replyToSender(ctx, msg, help);
                return seal.ext.newCmdExecuteResult(true);
            }

            // å‚æ•°è§£æ: æ”¯æŒ .ms hit 15 gun cover:heavy AA
            let damageVal = null; // Use null to distinguish between "not set" and "set to 0"
            let damageType = "";
            let coverKey = "";
            let isAA = false;
            let customAP;
            let customDR;
            let manualMode = "normal";

            let forceVal = null; // æ’æ¡©å˜é‡

            // // å…¼å®¹ç²˜è¿æŒ‡ä»¤ (hit10)
            // if (!dmgArg && cmdArgs.args[0].match(/^(hit|h|å—ä¼¤|å—å‚·)(\d+)$/i)) {
            //     const m = cmdArgs.args[0].match(/^(?:hit|h|å—ä¼¤|å—å‚·)(\d+)$/i);
            //     dmgArg = m[1];
            //     typeArg = cmdArgs.getArgN(1);
            // }
            // å‚æ•°æ‰‹åŠ¨è§£æå¾ªç¯ï¼Œæ”¯æŒä¹±åº
            for (let i = 0; i < cmdArgs.args.length; i++) {
                const arg = cmdArgs.args[i];
                //   // è·³è¿‡æŒ‡ä»¤å¤´ (.ms hit æˆ– .ms)
                const lowerArg = arg.toLowerCase();

                // Handle sticky damage (e.g., ".ms hit10")
                const stickyMatch = lowerArg.match(/^(hit|h|å—ä¼¤|å—å‚·)(\d+)$/i);
                if (stickyMatch) {
                    damageVal = parseInt(stickyMatch[2]);
                    continue;
                }
                if (arg.match(/^(hit|h|å—ä¼¤|å—å‚·)$/i) || arg === ".ms") continue;

                //   // æå– force (æµ‹è¯•ç”¨)
                if (arg.startsWith("force:")) {
                    forceVal = parseInt(arg.split(":")[1]);
                    continue;
                }

                //  æå– cover
                if (arg.toLowerCase().startsWith("cover:")||arg.toLowerCase().startsWith("æ©ä½“:")||arg.toLowerCase().startsWith("æ©ä½“ç±»å‹:")) {
                    coverKey = arg.split(":")[1];
                    continue;
                }

                //   // æå– ap/dr
                if (arg.toLowerCase().match(/^ap\d+$/)) {
                    customAP = parseInt(arg.toLowerCase().replace("ap", ""));
                    continue;
                }
                if (arg.toLowerCase().match(/^dr\d+$/)) {
                    customDR = parseInt(arg.toLowerCase().replace("dr", ""));
                    continue;
                }

                //   // æå– AA
                if (arg.toUpperCase() === "AA") {
                    isAA = true;
                    continue;
                }

                //   // æå– ç²˜è¿ä¼¤å®³æ•°å€¼ (hit15)
                // const stickyMatch = arg.match(/^(?:hit|h|å—ä¼¤|å—å‚·)(\d+)$/i);
                // if (stickyMatch) {
                //   damageVal = parseInt(stickyMatch[1]);
                //   continue;
                // }

                //   // æå– çº¯æ•°å­—ä¼¤å®³
                // if (arg.match(/^\d+$/) || damageVal === null) {
                //     damageVal = parseInt(arg);
                //     continue;
                // }

                // //   // å‰©ä¸‹çš„è§†ä¸º ç±»å‹ (å¦‚ gun, fire)
                // if (arg && !arg.match(/^\d+$/)) {
                //     damageType = arg;
                // }
                // ---
                // if (arg.match(/^\d+$/) && damageVal === 0) { damageVal = parseInt(arg); continue; }
                // if (arg.toLowerCase().startsWith("cover:")) { cover = arg.split(":")[1]; continue; }
                // if (arg.toUpperCase() === "AA") { isAA = true; continue; }

                // // 1. æå– force:XX
                // if (arg.startsWith("force:")) {
                //   forceVal = parseInt(arg.split(":")[1]);
                //   continue;
                // }
                // // 2. æå– hitXX æˆ– çº¯æ•°å­—
                // if (arg.match(/^(hit|h|å—ä¼¤|å—å‚·)(\d+)$/i)) {
                //   const m = arg.match(/^(?:hit|h|å—ä¼¤|å—å‚·)(\d+)$/i);
                //   damageVal = parseInt(m[1]);
                //   continue;
                // }
                // if (arg.match(/^\d+$/) && damageVal === null) {
                //   damageVal = parseInt(arg);
                //   continue;
                // }
                // // 3. å‰©ä¸‹çš„è§†ä¸ºç±»å‹ (è·³è¿‡æŒ‡ä»¤æœ¬èº« hit/h)
                // if (!arg.match(/^(hit|h|å—ä¼¤|å—å‚·)$/i)) {
                //   damageType = arg;
                // }
                // seal.replyToSender(ctx, msg,
                //   `âš ï¸ (${i})æ²¡é—®é¢˜ `);

// æå–ä¼˜åŠ£åŠ¿
if (["adv", "ä¼˜åŠ¿", "+"].includes(lowerArg)) { manualMode = "adv"; continue; }
if (["dis", "åŠ£åŠ¿", "-"].includes(lowerArg)) { manualMode = "dis"; continue; }


                // Parse damage value (if not already set and is a number)
                if (damageVal === null && lowerArg.match(/^\d+$/)) {
                    damageVal = parseInt(lowerArg);
                    continue;
                }

                // Parse damage type (if not already set and not a number)
                // This should be the last resort for parsing, as it catches any remaining string.
                // Ensure it's not a command keyword itself.
                if (!damageType && !lowerArg.match(/^\d+$/) && !lowerArg.match(/^(hit|h|å—ä¼¤|å—å‚·)$/i)) {
                    damageType = lowerArg;
                    continue;
                }
            }

            // const damage = parseInt(dmgArg);
            // if (isNaN(damage) || damage < 0) {
            //     seal.replyToSender(ctx, msg, "âŒ è¯·æŒ‡å®šæœ‰æ•ˆçš„ä¼¤å®³æ•°å€¼ã€‚ä¾‹: .ms hit 5");
            //     return seal.ext.newCmdExecuteResult(true);
            // }
            if (damageVal === null || damageVal < 0) {
                seal.replyToSender(ctx, msg, "âŒ è¯·æŒ‡å®šæœ‰æ•ˆçš„ä¼¤å®³æ•°å€¼ã€‚ä¾‹: .ms hit 5");
                return seal.ext.newCmdExecuteResult(true);
            }

            const hp = seal.vars.intGet(mctx, "ç”Ÿå‘½å€¼")[0];

            // [ä¿®æ”¹ç‚¹] åŠ¨æ€ç”Ÿæˆå¯ç”¨æŸä¼¤ç±»å‹æç¤º
            // æ ¼å¼ç¤ºä¾‹: é’å‡»(blunt/b), å‡ºè¡€(bleeding/c)
            const typeHint = Object.values(MS_CONSTS.WOUND_TABLE)
                .map(t => {
                    // è¿‡æ»¤æ‰ä¸­æ–‡åæœ¬èº«ï¼Œåªæ˜¾ç¤ºè‹±æ–‡å’Œç®€å†™ï¼Œé¿å…é‡å¤ "é’å‡»(é’å‡»/blunt/b)"
                    const displayAliases = t.aliases.filter(a => a !== t.name && !a.match(/[\u4e00-\u9fa5]/)); // ä»…æ˜¾ç¤ºéä¸­æ–‡åˆ«å
                    return `${t.name}(${displayAliases.join("/")})`;
                })
                .join(", ");

            // --- Dry Run Check (è‡´å‘½ä¼¤é¢„æ£€) ---
            // é¢„è®¡ç®—å®é™…ä¼¤å®³ (ä¸åº”ç”¨å‰¯ä½œç”¨)
            const dryCtx = MSDamageSystem.createInboundContext(mctx, damageVal, damageType, {
                coverKey: coverKey,
                isAA: isAA,
                customAP: customAP,
                customDR: customDR,
                dryRun: true
            });
            const dryRes = MSDamageSystem.processInbound(dryCtx);
            const predictedDmg = dryRes.effectiveDamage;

            // å¦‚æœé¢„è®¡ç®—ä¼¤å®³è¶³ä»¥è®© HP å½’é›¶ï¼Œåˆ™å¼ºåˆ¶è¦æ±‚ä¼¤å®³ç±»å‹
            if (hp - predictedDmg <= 0) {
                let hasValidType = false;
                if (damageType) {
                    const tk = damageType.toLowerCase();
                    for (let k in MS_CONSTS.WOUND_TABLE) {
                        if (MS_CONSTS.WOUND_TABLE[k].aliases.includes(tk)) {
                            hasValidType = true;
                            break;
                        }
                    }
                }

                if (!hasValidType) {
                    seal.replyToSender(ctx, msg,
                        `âš ï¸ ä¼¤å®³(${damageVal}) ç»è®¡ç®—å(${predictedDmg}) å°†å¯¼è‡´ç”Ÿå‘½å€¼(${hp})å½’é›¶ï¼\n` +
                        `âŒ å¿…é¡»æŒ‡å®šæŸä¼¤ç±»å‹æ‰èƒ½ç»“ç®—è‡´å‘½ä¼¤ã€‚\n` +
                        `è¯·é‡è¯•: .ms hit ${damageVal} <ç±»å‹> ...\n` +
                        `å¯ç”¨ç±»å‹: ${typeHint}`
                    );
                    return seal.ext.newCmdExecuteResult(true);
                }
            }

            // --- End Dry Run Check ---
            let r = MSRules.resolveDamage(mctx, damageVal, damageType, {
                coverKey: coverKey,
                isAA: isAA,
                customAP: customAP,
                customDR: customDR,
                forceWoundRoll: forceVal,
                manualMode: manualMode,
            });
            // [M.O.M. Hook] å—å‡»è¯„ä»·
            r += MOM.react(mctx, "hit", { dmg: damageVal });

            seal.replyToSender(ctx, msg, `${name} ç»“ç®—ä¼¤å®³:\n${r}`);
            return seal.ext.newCmdExecuteResult(true);
        }
        // æŸ¥æŸä¼¤è¡¨ (.ms w) - [v1.0.1-beta é€‚é…ç‰ˆ]
        static handleWound(ctx, msg, cmdArgs) {
            const typeArg = cmdArgs.getArgN(2).toLowerCase();
            let foundType = null;

            for (let key in MS_CONSTS.WOUND_TABLE) {
                if (MS_CONSTS.WOUND_TABLE[key].aliases.includes(typeArg)) {
                    foundType = MS_CONSTS.WOUND_TABLE[key];
                    break;
                }
            }

            if (!foundType) {
                seal.replyToSender(ctx, msg, `âš ï¸ æœªçŸ¥æŸä¼¤ç±»å‹: ${typeArg}ã€‚\nå¯ç”¨ç±»å‹: é’å‡»(b), å‡ºè¡€(c), æªå‡»(g), ç«ç„°(f), æƒ¨çƒˆ(m)`);
                return seal.ext.newCmdExecuteResult(true);
            }

            const roll = Math.floor(Math.random() * 10);
            const entry = foundType.table[roll];

            // [ä¿®å¤å…³é”®ç‚¹] è§£ææ–°ç»“æ„å¯¹è±¡
            let resultText = "";
            if (typeof entry === 'string') {
                resultText = entry; // å…¼å®¹æ—§æ•°æ®
            } else {
                resultText = `ã€${entry.sev}ã€‘ ${entry.desc}`;
                if (entry.bleed) resultText += ` (å‡ºè¡€+${entry.bleed})`;
                if (entry.stress) resultText += ` (å‹åŠ›+${entry.stress})`;
                if (entry.death) {
                    resultText += entry.delay ? `\nâš ï¸ [è‡´å‘½] 1d10è½®å†…æ­»äº¡è±å…` : `\nğŸ’€ [è‡´æ­»] ç«‹å³æ­»äº¡è±å…`;
                }
            }

            seal.replyToSender(ctx, msg, `ğŸ² æŸä¼¤è¡¨æŠ½å– (${foundType.name}): 1d10=${roll}\nğŸ“ ç»“æœ: ${resultText}\n(æç¤º: ä½¿ç”¨ .ms hit å¯è‡ªåŠ¨æ‰£è¡€å¹¶åº”ç”¨æ•ˆæœ)`);
            return seal.ext.newCmdExecuteResult(true);
        }
        // static handleUse(ctx, msg, cmdArgs) { /* å¤ç”¨ v3.2.1 é€»è¾‘ */ const mctx=seal.getCtxProxyFirst(ctx,cmdArgs);const item=cmdArgs.getArgN(2);if(!item){let t="=== å¯ç”¨ç‰©å“ (.ms use <ç‰©å“å>) ===\n";for(let k in MS_CONSTS.ITEMS){const i=MS_CONSTS.ITEMS[k];t+=`ğŸ’Š ${i.name}: ${i.desc.substring(0,20)}...\n`;}seal.replyToSender(ctx,msg,t);return seal.ext.newCmdExecuteResult(true);}const r=MSRules.useItem(mctx,item,cmdArgs);if(r){const n=seal.format(ctx,"{$tç©å®¶}");seal.replyToSender(ctx,msg,`${n} ${r}`);}else{seal.replyToSender(ctx,msg,`æœªçŸ¥çš„ç‰©å“: ${item}ã€‚\nä½¿ç”¨ .ms use æŸ¥çœ‹åˆ—è¡¨ã€‚`);}return seal.ext.newCmdExecuteResult(true);}
        static handleUse(ctx, msg, cmdArgs) {
            const mctx = seal.getCtxProxyFirst(ctx, cmdArgs);
            const rawName = cmdArgs.getArgN(2);

            // 1. æ— å‚æ•°ï¼šæ˜¾ç¤ºè¯¦ç»†åˆ—è¡¨
            if (!rawName) {
                let listText = "ğŸ“¦ ã€æ¯èˆ°ç‰©èµ„ç®± (å¯ç”¨ç‰©å“æ¸…å•)ã€‘:\n" + "=".repeat(30);
                let count = 0;

                for (const [key, item] of Object.entries(MS_CONSTS.ITEMS)) {
                    count++;
                    // æ ¼å¼åŒ–åˆ«å: [stim, å…´å¥‹å‰‚]
                    const aliasText = item.aliases ? `[${item.aliases.join(", ")}]` : "";
                    listText += `\nğŸ”¹ ã€${item.name}ã€‘ ${aliasText}\n   > ${item.desc}`;
                }

                if (count === 0) listText += "\n(æš‚æ— æ•°æ®)";

                listText += "\n" + "=".repeat(30) + "\nğŸ’¡ ç”¨æ³•: .ms use <ç‰©å“å>";
                seal.replyToSender(ctx, msg, listText);
                return seal.ext.newCmdExecuteResult(true);
            }

            const targetName = rawName.toLowerCase();
            let foundItem = null;
            let foundKey = "";

            // 2. æŸ¥æ‰¾ç‰©å“ (ä¼˜å…ˆ Keyï¼Œå…¶æ¬¡ Alias)
            if (MS_CONSTS.ITEMS[targetName]) {
                foundItem = MS_CONSTS.ITEMS[targetName];
                foundKey = targetName;
            } else {
                for (const [key, item] of Object.entries(MS_CONSTS.ITEMS)) {
                    // æ£€æŸ¥ aliases æ•°ç»„
                    if (item.aliases && item.aliases.some(a => a.toLowerCase() === targetName)) {
                        foundItem = item;
                        foundKey = key;
                        break;
                    }
                }
            }

            // 3. æœªæ‰¾åˆ°å¤„ç†
            if (!foundItem) {
                seal.replyToSender(ctx, msg, `ğŸš« æœªæ‰¾åˆ°ç‰©å“: "${rawName}"\nè¯·å‘é€ .ms use æŸ¥çœ‹å¯ç”¨åˆ—è¡¨ã€‚`);
                return seal.ext.newCmdExecuteResult(true);
            }

            // 4. æ‰§è¡Œç‰©å“é€»è¾‘
            // ä¼˜å…ˆè°ƒç”¨ç‰©å“è‡ªå¸¦çš„ use å‡½æ•°
            let reply = "";
            if (foundItem.use && typeof foundItem.use === 'function') {
                try {
                    reply = foundItem.use(mctx);
                } catch (e) {
                    reply = `âŒ ç‰©å“ [${foundItem.name}] ä½¿ç”¨æ—¶å‘ç”Ÿé”™è¯¯: ${e.message}`;
                    console.log("[MS] Item Use Error:", e);
                }
            } else {
                // å¦‚æœæ²¡æœ‰å®šä¹‰ use å‡½æ•°ï¼Œåªæ˜¾ç¤ºæè¿°
                reply = `ğŸ“¦ ä½¿ç”¨ [${foundItem.name}]:\n${foundItem.desc}\n(è¯¥ç‰©å“æš‚æ— è‡ªåŠ¨åŒ–æ•ˆæœ)`;
            }

            seal.replyToSender(ctx, msg, reply);
            return seal.ext.newCmdExecuteResult(true);
        }
        static handlePanic(ctx, msg, cmdArgs) {
            let forceVal = null;
            let manualMode = "normal";
            const mctx = seal.getCtxProxyFirst(ctx, cmdArgs);


            const n = seal.format(ctx, "{$tç©å®¶}");

            // 1. å¤„ç† force å‚æ•°
            for (let i = 0; i < cmdArgs.args.length; i++) {
                const arg = cmdArgs.args[i].toLowerCase();
                if (arg.startsWith("force:")) {
                    forceVal = parseInt(arg.split(":")[1]);
                } else if (["adv", "ä¼˜åŠ¿", "+"].includes(arg)) {
                    manualMode = "adv";
                } else if (["dis", "åŠ£åŠ¿", "-"].includes(arg)) {
                    manualMode = "dis";
                }

            }

            // 2. è·å–å½“å‰å‹åŠ›
            const stressVar = seal.vars.intGet(mctx, "å‹åŠ›");
            const currentStress = stressVar[1] ? stressVar[0] : 2;


            // 3. è°ƒç”¨é€»è¾‘å±‚
            const panicResult = MSRules.panicCheck(mctx, currentStress, true, forceVal, manualMode);
            // 4. æ„å»ºå›å¤
            let reply = `ğŸ˜± ã€${n} æƒŠææ£€å®šã€‘\n`;
            reply += `==============================\n`;
            reply += `ğŸ² æŠ•æ·: 1d20 = ã€${panicResult.rollDetail}ã€‘\n`;
            reply += `ğŸ“Š å‹åŠ›: ${currentStress}\n`;

            // [æ–°å¢] æ˜¾ç¤ºä¿®æ­£å› ç´ 
            if (panicResult.modLogs && panicResult.modLogs.length > 0) {
                reply += `ğŸ”§ ä¿®æ­£: ${panicResult.modLogs.join(", ")}\n`;
            }

            // [æ–°å¢] æ­§ä¹‰å¤„ç†åˆ†æ”¯
            if (panicResult.isAmbiguous) {
                reply += `âš ï¸ ã€ç»“æœ: æƒŠæ (å¤šé‡ç»“æœ)ã€‘\n`;
                reply += `------------------------------\n`;
                reply += `ç”±äºä¼˜åŠ£åŠ¿å¯¼è‡´äº†ä¸¤ä¸ªä¸åŒçš„æƒŠæç»“æœï¼Œä¸”æ— æ³•åˆ¤å®šä¼˜åŠ£ï¼Œè¯·æ ¹æ®å½“å‰æƒ…å†µæ‰‹åŠ¨é€‰æ‹©ï¼š\n\n`;

                panicResult.options.forEach((opt, idx) => {
                    reply += `ğŸ”¹ é€‰é¡¹ ${idx + 1} (éª°å€¼ ${opt.roll}):\n   ${opt.desc}\n   ğŸ‘‰ æŒ‡ä»¤: .ms panic force:${opt.roll}\n\n`;
                });

                reply += `(è¯·å¤åˆ¶å¯¹åº”æŒ‡ä»¤æ‰§è¡Œä»¥åº”ç”¨æ•ˆæœ)`;
                seal.replyToSender(ctx, msg, reply);
                return seal.ext.newCmdExecuteResult(true);
            }

            if (!panicResult.isPanic) {
                reply += `âœ… ã€ç»“æœ: å®‰å…¨ã€‘ (æŠ•æ· > å‹åŠ›)`;
            } else {
                reply += `âš ï¸ ã€ç»“æœ: æƒŠæ!ã€‘ (æŠ•æ· <= å‹åŠ›)\n`;
                reply += `------------------------------\n`;
                reply += `ğŸ“œ ã€æ•ˆæœã€‘: ${panicResult.desc}`;
                if (panicResult.logs.length > 0) {
                    reply += `\n\nğŸ“ ã€ç»“ç®—è¯¦æƒ…ã€‘:\n` + panicResult.logs.map(l => `> ${l}`).join("\n");
                }

                if (panicResult.traumaMsg) {
                    reply += `\n\n${panicResult.traumaMsg}`;
                }

            }

            // æŠ€å·¥ç‰¹æ€§æç¤º
            const cls = MSRules.normalizeClass(mctx);
            if (cls.includes("æŠ€å·¥")) {
                reply += `\n\nğŸ”§ [æŠ€å·¥ç‰¹æ€§] æ¯æ—¥ä¸€æ¬¡æƒŠææ£€å®šä¼˜åŠ¿ã€‚\n(å¦‚éœ€ä½¿ç”¨: .ms undo æ’¤å› -> .ms panic adv)`;
            }


            // [M.O.M. Hook] æƒŠæè¯„ä»·
            if (panicResult.isPanic) reply += MOM.react(mctx, "panic", { roll: panicResult.roll });


            seal.replyToSender(ctx, msg, reply);
            return seal.ext.newCmdExecuteResult(true);
        }
        // è®¾ç½®èŒç±» (ä»…è®°å½•)
        static handleClass(ctx, msg, cmdArgs) {
            const mctx = seal.getCtxProxyFirst(ctx, cmdArgs);
            const name = seal.format(ctx, "{$tç©å®¶}");
            const className = cmdArgs.getArgN(2);


            if (className) {
                // è®¾ç½®èŒç±»
                let cls = null;
                for (let k in MS_CONSTS.CLASSES) {
                    if (MS_CONSTS.CLASSES[k].aliases.includes(className)) {
                        cls = MS_CONSTS.CLASSES[k];
                        break;
                    }
                }

                if (cls) {

                    seal.vars.intSet(mctx, "èŒç±»", cls.id);


                    seal.replyToSender(ctx, msg,
                        `ğŸ†” ã€${name} èŒç±»æ›´æ–°ã€‘\n` +
                        `==============================\n` +
                        `âœ… å·²è®°å½•: ã€${cls.name}ã€‘\n\n` +
                        `ğŸ“ ã€å±æ€§åŠ æˆå‚è€ƒã€‘:\n${cls.desc}\n\n` +
                        `âš ï¸ ã€åˆ›ä¼¤ååº”ç‰¹è´¨ã€‘:\n${cls.trait}\n` +
                        `==============================\n` +
                        `ğŸ’¡ æç¤º: è¯·æ ¹æ®åŠ æˆæ‰‹åŠ¨è°ƒæ•´å±æ€§ (å¦‚ .st æ™ºåŠ›+10) `
                    );
                } else {
                    seal.replyToSender(ctx, msg, `âŒ æœªçŸ¥èŒç±»: ${className}ã€‚\nå¯ç”¨: é™†æˆ˜é˜Ÿå‘˜, ä»¿ç”Ÿäºº, ç§‘å­¦å®¶, æŠ€å·¥`);
                }
            } else {
                // æŸ¥çœ‹èŒç±»
                const currentClassStr = MSRules.normalizeClass(mctx);
                let currentClsObj = null;

                for (let k in MS_CONSTS.CLASSES) {
                    if (MS_CONSTS.CLASSES[k].name === currentClassStr || k === currentClassStr) {
                        currentClsObj = MS_CONSTS.CLASSES[k];
                        break;
                    }
                }

                if (currentClsObj) {
                    seal.replyToSender(ctx, msg,
                        `ğŸ‘¤ ã€å½“å‰èŒç±»ã€‘: ${currentClsObj.name}\n` +
                        `------------------------------\n` +
                        `ğŸ“ ã€å±æ€§å‚è€ƒã€‘: ${currentClsObj.desc}\n` +
                        `âš ï¸ ã€åˆ›ä¼¤ååº”ã€‘: ${currentClsObj.trait}`
                    );
                } else {
                    let txt = "ğŸš« å½“å‰æœªè®¾ç½®èŒç±»ã€‚\nğŸ‘‰ ä½¿ç”¨ .ms class <èŒç±»> è¿›è¡Œè®¾ç½®ã€‚\n\n=== å¯é€‰èŒç±» ===\n";
                    for (let k in MS_CONSTS.CLASSES) {
                        if (k !== "æœªè®¾ç½®èŒç±»") txt += `â— ${k}\n`;
                    }
                    seal.replyToSender(ctx, msg, txt);
                }
            }
            return seal.ext.newCmdExecuteResult(true);
        }



        static handleRelieveStress(ctx, msg, cmdArgs) {
            const mctx = seal.getCtxProxyFirst(ctx, cmdArgs);
            const n = seal.format(ctx, "{$tç©å®¶}");

            // 1. è·å–æœ€å·®è±å…
            const w = MSRules.getWorstSave(mctx);
            if (!w.name) { seal.replyToSender(ctx, msg, "âŒ æ— æ³•è·å–è±å…å±æ€§ï¼Œè¯·å…ˆå½•å…¥äººç‰©å¡ã€‚"); return seal.ext.newCmdExecuteResult(true); }

            // 2. è§£æå‚æ•°
            let argsStr = "";
            for (let i = 0; i < cmdArgs.args.length; i++) {
                const arg = cmdArgs.args[i];
                if (arg.match(/^(rest|r|ç¼“è§£|ç·©è§£)$/i)) continue;
                if (arg.match(/^(rest|r|ç¼“è§£|ç·©è§£)(.*)$/i)) {
                    const m = arg.match(/^(?:rest|r|ç¼“è§£|ç·©è§£)(.*)$/i);
                    if (m && m[1]) argsStr += m[1] + " ";
                    continue;
                }
                argsStr += arg + " ";
            }
            const parsed = MSRules.parseExpression(mctx, argsStr);

            // 3. æ„å»º Pipeline ä¸Šä¸‹æ–‡
            const checkCtx = new CheckContext(mctx, w.name, w.val);
            checkCtx.addTag("rest"); // æ·»åŠ ä¼‘æ¯æ ‡ç­¾

            // åº”ç”¨æŒ‡ä»¤ä¿®æ­£
            if (parsed.totalValue !== 0) checkCtx.addMod(parsed.totalValue, parsed.desc || "æŒ‡ä»¤");
            if (parsed.mode === 'adv') checkCtx.addAdv('adv', 'æŒ‡ä»¤');
            if (parsed.mode === 'dis') checkCtx.addAdv('dis', 'æŒ‡ä»¤');

            // 4. æ‰§è¡Œ Pipeline
            const pipeRes = MSPipeline.process(checkCtx);

            // 5. æ‰§è¡Œæ£€å®š
            const r = MSRules.rollCheck(pipeRes.target, pipeRes.mode);

            // 6. ç»“ç®—ç»“æœ
            let msgR = "";
            let curStress = seal.vars.intGet(mctx, "å‹åŠ›")[0];

            if (r.isSuccess) {
                // æˆåŠŸï¼šå‡å°‘ä¸ªä½æ•°å‹åŠ› (0-9)
                let relief = r.roll % 10;
                if (r.roll === 100) relief = 0;

                const res = MSRules.updateStress(mctx, -relief, "ç¼“è§£å‹åŠ›");
                msgR = `âœ… ã€ç¼“è§£æˆåŠŸ!ã€‘\nğŸ“‰ å‹åŠ› -${relief} (å½“å‰: ${res.newVal})`;
                curStress = res.newVal;
            } else {
                // å¤±è´¥ï¼šå‹åŠ› +1
                const res = MSRules.updateStress(mctx, 1, "ç¼“è§£å¤±è´¥");
                msgR = `âŒ ã€ç¼“è§£å¤±è´¥!ã€‘\nğŸ˜« å‹åŠ› +1 (å½“å‰: ${res.newVal})${res.msg}`; curStress = res.newVal;

                // å…³é”®å¤±è´¥ -> æƒŠæ
                if (r.crit === "crit_fail") {
                    msgR += `\n\nâ›”â— ã€å…³é”®å¤±è´¥! è§¦å‘æƒŠæ!ã€‘`; const pr = MSRules.panicCheck(mctx, curStress, true);
                    msgR += `\nğŸ˜± æƒŠææ£€å®š(å‹${curStress}): 1d20=${pr.rollDetail} -> ${pr.desc}\n${pr.logs.join("\n")}${pr.traumaMsg}`;
                }
            }

            // èŒç±»/çŠ¶æ€ç‰¹æ•ˆæ£€æŸ¥
            msgR += MSRules.getTraumaWarning(mctx, w.name, r.isSuccess);

            // [M.O.M. Hook] ä¼‘æ¯è¯„ä»· (åŒºåˆ†æˆåŠŸå¤±è´¥)
            msgR += MOM.react(mctx, "relief", { success: r.isSuccess });





            // 7. æ ¼å¼åŒ–è¾“å‡º
            let rollDetail = `${r.roll}`;
            if (r.mode === 'adv') rollDetail = `[${r.rawDice.join(", ")}] å–ä½ -> ${r.roll}`;
            else if (r.mode === 'dis') rollDetail = `[${r.rawDice.join(", ")}] å–é«˜ -> ${r.roll}`;
            let logStr = pipeRes.logs.length > 0 ? `\nğŸ”§ ä¿®æ­£: ${pipeRes.logs.join(", ")}` : "";
            seal.replyToSender(ctx, msg,
                `ğŸ§˜ ã€${n} ç¼“è§£å‹åŠ›ã€‘ (æœ€å·®è±å…: ${w.name})\n` +
                `ğŸ² æ£€å®š: ${rollDetail} / ${pipeRes.target} ${logStr}\n` +
                `------------------------------\n` +
                `${msgR}`
            );
            return seal.ext.newCmdExecuteResult(true);
        }

        static handleShoreLeave(ctx, msg, cmdArgs) {
            const mctx = seal.getCtxProxyFirst(ctx, cmdArgs);
            const n = seal.format(ctx, "{$tç©å®¶}");
            const pc = cmdArgs.getArgN(2).toUpperCase();
            const pd = MS_CONSTS.SHORE_LEAVE[pc];
            if (!pd) {
                seal.replyToSender(ctx, msg,
                    `ğŸ–ï¸ ã€ä¸Šå²¸ä¼‘å‡ (.ms leave)ã€‘\n` +
                    `è¯·æŒ‡å®šæ˜Ÿæ¸¯ç­‰çº§: X, C, B, A, S\n` +
                    `ä¾‹: .ms leave B`
                );
                return seal.ext.newCmdExecuteResult(true);
            }

            // 1. è§£æå‚æ•°
            let argsStr = "";
            for (let i = 3; i < cmdArgs.args.length; i++) argsStr += cmdArgs.args[i] + " ";
            const parsed = MSRules.parseExpression(mctx, argsStr);

            // 2. è·å–ç†æ™º
            const sanVal = seal.vars.intGet(mctx, "ç†æ™º")[0];
            if (!seal.vars.intGet(mctx, "ç†æ™º")[1]) { seal.replyToSender(ctx, msg, "âŒ æ— ç†æ™ºå±æ€§ã€‚"); return seal.ext.newCmdExecuteResult(true); }


            // 3. æ„å»º Pipeline
            const checkCtx = new CheckContext(mctx, "ç†æ™º", sanVal);
            checkCtx.addTag("shore_leave");

            if (parsed.totalValue !== 0) checkCtx.addMod(parsed.totalValue, parsed.desc || "æŒ‡ä»¤");
            if (parsed.mode === 'adv') checkCtx.addAdv('adv', 'æŒ‡ä»¤');
            if (parsed.mode === 'dis') checkCtx.addAdv('dis', 'æŒ‡ä»¤');

            const pipeRes = MSPipeline.process(checkCtx);

            // 4. æ‰§è¡Œæ£€å®š
            const r = MSRules.rollCheck(pipeRes.target, pipeRes.mode);

            // 5. å‡†å¤‡æ•°æ®
            const cs = seal.vars.intGet(mctx, "å‹åŠ›")[0];
            const min = seal.vars.intGet(mctx, "å‹åŠ›ä¸‹é™")[0];
            const cost = MSRules.rollDiceExpr(pd.costDice);
            const totalCost = cost * pd.costMult;
            const cstr = (totalCost >= 10000) ? `${totalCost / 10000}ä¸‡` : `${totalCost}`;

            let rm = "", im = "", pa = "", rsm = "";

            // 6. ç»“æœåˆ†æ”¯
            if (r.crit === "crit_success") {
                let max = 0;
                if (pd.convert === "all") max = 999;
                else {
                    const pm = pd.convert.match(/(\d+)d(\d+)/);
                    if (pm) max = parseInt(pm[1]) * parseInt(pm[2]);
                    else max = 10; // fallback
                }
                const cc = Math.min(cs, max);

                const res = MSRules.updateStress(mctx, min - cs, "ä¼‘å‡(å…³é”®æˆåŠŸ)");

                rsm = `ğŸ“‰ å‹åŠ›é‡ç½®è‡³ä¸‹é™ (${res.newVal})ã€‚`;
                rm = `âœ¨ ã€å…³é”®æˆåŠŸ!ã€‘ è½¬åŒ–æœ€å¤§é‡ ${cc}`;
                im = `ğŸ‘‰ è¯·æ‰‹åŠ¨æ‰§è¡Œ: .st ç†æ™º+${cc}`;
            } else if (r.isSuccess) {
                let rc = pd.convert === "all" ? 999 : MSRules.rollDiceExpr(pd.convert);
                if (pd.adv && pd.convert !== "all") rc = Math.max(rc, MSRules.rollDiceExpr(pd.convert));
                const cc = Math.min(cs, rc);

                const res = MSRules.updateStress(mctx, min - cs, "ä¼‘å‡(æˆåŠŸ)");
                rsm = `ğŸ“‰ å‹åŠ›é‡ç½®è‡³ä¸‹é™ (${res.newVal})ã€‚`;
                rm = `âœ… ã€æˆåŠŸ!ã€‘ è½¬åŒ– ${cc} ç‚¹ (éª°å‡º:${rc})`;
                im = `ğŸ‘‰ è¯·æ‰‹åŠ¨æ‰§è¡Œ: .st ç†æ™º+${cc}`;


            } else if (r.crit === "crit_fail") {
                rm = `â›”â— ã€å…³é”®å¤±è´¥!ã€‘ æ— è½¬åŒ–ï¼Œè§¦å‘æƒŠæ!`;

                const pr = MSRules.panicCheck(mctx, cs, true);
                pa = `\nğŸ˜± è‡ªåŠ¨æƒŠæ: 1d20=${pr.rollDetail} -> ${pr.desc}\n${pr.logs.join("\n")}${pr.traumaMsg}`;
            } else {
                const fs = Math.min(20, min + 1);
                const res = MSRules.updateStress(mctx, fs - cs, "ä¼‘å‡(å¤±è´¥)");
                rsm = `ğŸ“ˆ å‹åŠ›é‡ç½®è‡³ä¸‹é™+1 (${res.newVal})`;
                rm = `âŒ ã€å¤±è´¥!ã€‘ æ— è½¬åŒ–`;
            }

            rm += MSRules.getTraumaWarning(mctx, "ç†æ™º", r.isSuccess);

            // [M.O.M. Hook] ä¼‘å‡è¯„ä»·
            rm += MOM.react(mctx, "shore_leave", { success: r.isSuccess });


            // 7. è¾“å‡º
            let rollDetail = `${r.roll}`;
            if (r.mode === 'adv') rollDetail = `[${r.rawDice.join(", ")}] å–ä½ -> ${r.roll}`;
            else if (r.mode === 'dis') rollDetail = `[${r.rawDice.join(", ")}] å–é«˜ -> ${r.roll}`;
            seal.replyToSender(ctx, msg,
                `ğŸ–ï¸ ã€${n} ä¸Šå²¸ä¼‘å‡ã€‘ (${pd.name})\n` +
                `ğŸ’° è´¹ç”¨: ${cstr}cr\n` +
                `ğŸ² ç†æ™ºæ£€å®š: ${rollDetail} / ${pipeRes.target} ${logStr}\n` +
                `------------------------------\n` +
                `${rm}\n${rsm}\n${im}${pa}`
            );


            return seal.ext.newCmdExecuteResult(true);
        }

        // static handleShowSheet(ctx, msg, cmdArgs) { /* å¤ç”¨ v3.2.1 é€»è¾‘ */ const mctx = seal.getCtxProxyFirst(ctx, cmdArgs); const n = seal.format(ctx, "{$tç©å®¶}"); const get = (k) => seal.vars.intGet(mctx, k)[0]; const cn = MSRules.normalizeClass(mctx) || "æ— "; let out = `ğŸ‘¤ ${n} [${cn}]\n`; out += `ğŸ“Š å±æ€§: åŠ›é‡${get("åŠ›é‡")} é€Ÿåº¦${get("é€Ÿåº¦")} æ™ºåŠ›${get("æ™ºåŠ›")} æˆ˜æ–—${get("æˆ˜æ–—")}\n`; out += `ğŸ›¡ è±å…: ç†æ™º${get("ç†æ™º")} ææƒ§${get("ææƒ§")} èº«ä½“${get("èº«ä½“")} æŠ¤ç”²${get("æŠ¤ç”²")}\n`; out += `â¤ï¸ çŠ¶æ€: HP ${get("ç”Ÿå‘½å€¼")}/${get("ç”Ÿå‘½å€¼ä¸Šé™")} | ğŸ’” æŸä¼¤ ${get("æŸä¼¤")}/${get("æŸä¼¤ä¸Šé™")}\n`; out += `ğŸ˜« å‹åŠ›: ${get("å‹åŠ›")} (ğŸ”»ä¸‹é™ ${get("å‹åŠ›ä¸‹é™")})\n`; const stims = get("å…´å¥‹è¯æ‘„å…¥"); if (stims > 0) out += `ğŸ’ ç‰©å“: å…´å¥‹è¯æ‘„å…¥ ${stims}å‰‚\n`; if (cn.includes("ä»¿ç”Ÿäºº")) out += `ğŸ¤– [ä»¿ç”Ÿäººå…‰ç¯] è¿‘è·å‹æ–¹ææƒ§è±å…åŠ£åŠ¿\n`; else if (cn.includes("æŠ€å·¥")) out += `ğŸ”§ [æŠ€å·¥ç‰¹æ€§] æ¯æ—¥ä¸€æ¬¡æƒŠææ£€å®šä¼˜åŠ¿ (è‡ªè¡Œè®°å½•)\n`; else if (cn.includes("ç§‘å­¦å®¶")) out += `ğŸ§ª [ç§‘å­¦å®¶ç‰¹æ€§] ç†æ™ºå¤±è´¥é˜Ÿå‹+1å‹åŠ›\n`; else if (cn.includes("é™†æˆ˜é˜Ÿå‘˜")) out += `âš” [é™†æˆ˜é˜Ÿç‰¹æ€§] æƒŠæåˆ™é˜Ÿå‹ææƒ§è±å…\n`; const l = MSRules.manageCondition(mctx, "get"); if (l && l.length > 0) { out += `ğŸŒ€ å»¶æ—¶æ€§å½±å“:\n`; out += MSCommands.formatConditionList(l); } else { out += `ğŸŒ€ å»¶æ—¶æ€§å½±å“: æ— \n`; } seal.replyToSender(ctx, msg, out); return seal.ext.newCmdExecuteResult(true); }
        static handleShowSheet(ctx, msg, cmdArgs) {
            const mctx = seal.getCtxProxyFirst(ctx, cmdArgs);

            // [é€»è¾‘å‡çº§] è‡ªåŠ¨åˆ¤æ–­æ˜¯ .st (args[0]=st) è¿˜æ˜¯ .ms st (args[0]=ms, args[1]=st)
            // ä»è€Œç¡®å®šå‚æ•°å¼€å§‹çš„ä½ç½®
            let startIndex = 1;
            if (cmdArgs.args[0] && cmdArgs.args[0].toLowerCase().includes("ms")) startIndex = 2;

            // 1. å°è¯•å¤„ç†å±æ€§è®¾ç½® (.st str 50)
            if (cmdArgs.args.length > startIndex) {
                let output = [];
                // [Refactor] Helper to apply attribute changes
                const applyChange = (key, val) => {
                    const realKey = MSRules.resolveAlias(key);
                    // [æ‹¦æˆª] å‹åŠ›ä¿®æ”¹èµ°æ ¸å¿ƒæµ (æ”¯æŒæº¢å‡º/ä¸‹é™æ£€æŸ¥)
                    if (realKey === "å‹åŠ›") {
                        const currentStress = seal.vars.intGet(mctx, "å‹åŠ›")[0];
                        let delta = 0;
                        const valStr = String(val);
                        if (valStr.startsWith("+") || valStr.startsWith("-")) {
                            delta = parseInt(valStr);
                        } else {
                            delta = parseInt(valStr) - currentStress;
                        }
                        const r = MSRules.updateStress(mctx, delta, "ğŸ‘‰æ‰‹åŠ¨ä¿®æ”¹");
                        let log = `å‹åŠ›: ${r.oldVal}âœ${r.newVal}`;
                        if (r.msg) log += r.msg;
                        output.push(log);
                    } else {
                        const currentVal = seal.vars.intGet(mctx, realKey)[0];
                        let newVal = parseInt(val);
                        if (String(val).startsWith("+") || String(val).startsWith("-")) newVal = currentVal + parseInt(val);
                        seal.vars.intSet(mctx, realKey, newVal);
                        output.push(`${realKey}: ${currentVal}âœ${newVal}`);
                    }
                };

                for (let i = startIndex; i < cmdArgs.args.length; i++) {
                    let arg = cmdArgs.args[i];
                    if (arg.toLowerCase() === "show") continue;

                    // let key = "", val = "";
                    // // åŒ¹é… str=50, str:50, str+10
                    // let match = arg.match(/^([^=:\+\-\d]+)([=:\+\-]?)(-?\d+)$/);
                    // if (match) {
                    //     key = match[1];
                    //     let op = match[2];
                    //     val = match[3];
                    //     if (op === "+" || op === "-") val = op + val;
                    // } else {
                    // åŒ¹é… str 50 (ç©ºæ ¼åˆ†éš”)
                    // [New Logic] Support concatenated attributes like åŠ›é‡20é€Ÿåº¦30
                    const pairRegex = /([^=:\+\-\d\s]+)([=:\+\-]?)(-?\d+)/g;
                    let hasMatch = false;
                    let match;

                    while ((match = pairRegex.exec(arg)) !== null) {
                        hasMatch = true;
                        let key = match[1];
                        let op = match[2];
                        let val = match[3];
                        if (op === "+" || op === "-") val = op + val;
                        applyChange(key, val);
                    }
                    // Fallback for space separated values (e.g. .st str 50)
                    if (!hasMatch) {
                        let key = arg;
                        if (!/^[\d\+\-]+$/.test(arg)) {
                            key = arg;
                            let next = cmdArgs.args[i + 1];
                            if (next && /^[\+\-]?\d+$/.test(next)) {
                                val = next;
                                i++;
                                let val = next;
                                i++; // Skip next arg
                                applyChange(key, val);
                            }
                        }
                    }

                }
                if (output.length > 0) {
                    seal.replyToSender(ctx, msg, `âœ… å±æ€§æ›´æ–°:\n${output.join("\n")}`);
                    return seal.ext.newCmdExecuteResult(true);
                }
            }

            // 2. æ˜¾ç¤ºäººç‰©å¡ (åŸé€»è¾‘)
            const n = seal.format(ctx, "{$tç©å®¶}");
            const get = (k) => seal.vars.intGet(mctx, k)[0];
            const cn = MSRules.normalizeClass(mctx) || "æ— ";
            // [M.O.M. Hook] èµ„äº§è¯„ä¼°
            const momEval = MOM.evaluateAsset(mctx);
            let out = momEval ? `${momEval}\n` : "";
            out += `ğŸ‘¤ ${n} [${cn}]\n`;
            out += `ğŸ“Š å±æ€§: åŠ›é‡${get("åŠ›é‡")} é€Ÿåº¦${get("é€Ÿåº¦")} æ™ºåŠ›${get("æ™ºåŠ›")} æˆ˜æ–—${get("æˆ˜æ–—")}\n`;
            out += `ğŸ›¡ è±å…: ç†æ™º${get("ç†æ™º")} ææƒ§${get("ææƒ§")} èº«ä½“${get("èº«ä½“")} æŠ¤ç”²${get("æŠ¤ç”²")}\n`;
            out += `â¤ï¸ çŠ¶æ€: HP ${get("ç”Ÿå‘½å€¼")}/${get("ç”Ÿå‘½å€¼ä¸Šé™")} | ğŸ’” æŸä¼¤ ${get("æŸä¼¤")}/${get("æŸä¼¤ä¸Šé™")}\n`;
            out += `ğŸ˜« å‹åŠ›: ${get("å‹åŠ›")} (ğŸ”»ä¸‹é™ ${get("å‹åŠ›ä¸‹é™")})\n`;
            const stims = get("å…´å¥‹è¯æ‘„å…¥");
            const armorName = seal.vars.strGet(mctx, "ms_equipped_armor")[0] || "æ— ";
            out += `ğŸ§¥ è£…å¤‡: ${armorName} (ä½¿ç”¨.ms holdæŸ¥çœ‹æ­¦å™¨)\n`;
            if (stims > 0) out += `ğŸ’ ç‰©å“: å…´å¥‹è¯æ‘„å…¥ ${stims}å‰‚\n`;
            if (cn.includes("ä»¿ç”Ÿäºº")) out += `ğŸ¤– [ä»¿ç”Ÿäººå…‰ç¯] è¿‘è·å‹æ–¹ææƒ§è±å…åŠ£åŠ¿\n`;
            else if (cn.includes("æŠ€å·¥")) out += `ğŸ”§ [æŠ€å·¥ç‰¹æ€§] æ¯æ—¥ä¸€æ¬¡æƒŠææ£€å®šä¼˜åŠ¿ (è‡ªè¡Œè®°å½•)\n`;
            else if (cn.includes("ç§‘å­¦å®¶")) out += `ğŸ§ª [ç§‘å­¦å®¶ç‰¹æ€§] ç†æ™ºå¤±è´¥é˜Ÿå‹+1å‹åŠ›\n`;
            else if (cn.includes("é™†æˆ˜é˜Ÿå‘˜")) out += `âš” [é™†æˆ˜é˜Ÿç‰¹æ€§] æƒŠæåˆ™é˜Ÿå‹ææƒ§è±å…\n`;
            const l = MSRules.manageCondition(mctx, "get");
            if (l && l.length > 0) {
                out += `ğŸŒ€ å»¶æ—¶æ€§å½±å“:\n`;
                out += MSCommands.formatConditionList(l);
                out += "---------------------------\n";
                out += "å»¶æ—¶æ€§å½±å“æ˜¯æŒ‡ä¸€åˆ‡ä¸æ˜¯ç¬é—´å‘ç”Ÿçš„, æœ‰ä¸€å®šæ—¶é—´å»¶ç»­æ€§çš„æ•ˆæœ, åŒ…æ‹¬[çŠ¶æ€], [æŸä¼¤], [å‰¯ä½œç”¨]ç­‰ç­‰\n"
            } else {
                out += `ğŸŒ€ å»¶æ—¶æ€§å½±å“: æ— \n`;
            }
            // out += `mothershipæ’ä»¶é‡è½½äº†.stæŒ‡ä»¤,å¦‚æœæ‚¨åœ¨è·‘åˆ«çš„è§„åˆ™,è¯·ä½¿ç”¨.ext. ms offå…³é—­mothershipæ’ä»¶.`
            seal.replyToSender(ctx, msg, out);
            return seal.ext.newCmdExecuteResult(true);
        }
        // [MODIFIED] è§£æ force å‚æ•°
        static handleCheck(ctx, msg, cmdArgs) {
            const mctx = seal.getCtxProxyFirst(ctx, cmdArgs);
            const n = seal.format(ctx, "{$tç©å®¶}");

            // 1. è§£æå‚æ•° (å« force)
            let argsStr = "";
            let forceVal = null;

            for (let i = 0; i < cmdArgs.args.length; i++) {
                const arg = cmdArgs.args[i];
                if (arg.startsWith("force:")) {
                    forceVal = parseInt(arg.split(":")[1]);
                    continue;
                }
                argsStr += arg + " ";
            }
            // 2. è§£æè¡¨è¾¾å¼
            const p = MSRules.parseExpression(mctx, argsStr);



            // 3. Pipeline
            const checkCtx = new CheckContext(mctx, p.checkType, p.totalValue);

            if (p.mode === 'adv') checkCtx.addAdv('adv', 'æŒ‡ä»¤');
            if (p.mode === 'dis') checkCtx.addAdv('dis', 'æŒ‡ä»¤');

            const pipelineResult = MSPipeline.process(checkCtx);


            // 4. æŠ•æ·
            const r = MSRules.rollCheck(pipelineResult.target, pipelineResult.mode, {}, forceVal);

            //5.ç»“ç®—
            const resultMsg = MSRules.resolveCheck(mctx, r, p.checkType);

            // 6. æ ¼å¼åŒ–è¾“å‡º
            let logStr = pipelineResult.logs.length > 0 ? `\nğŸ”§ ä¿®æ­£: ${pipelineResult.logs.join(", ")}` : "";

            if (pipelineResult.warnings && pipelineResult.warnings.length > 0) {
                logStr += `\n${pipelineResult.warnings.join("\n")}`;
            }


            let rollDetail = `${r.roll}`;
            if (r.mode === 'adv') rollDetail = `[${r.rawDice.join(", ")}] å–ä½ -> ${r.roll}`;
            else if (r.mode === 'dis') rollDetail = `[${r.rawDice.join(", ")}] å–é«˜ -> ${r.roll}`;


            let reply = `ğŸ² ã€${n}${p.checkType}æ£€å®šã€‘\n` +
                `ç»“æœ: ${rollDetail} / ${pipelineResult.target} ${logStr}${resultMsg}`;
            if (pipelineResult.target === 0 && p.checkType === "å±æ€§") {
                reply += "\n[âš ï¸è­¦å‘Š]æ‚¨æ˜¯ä¸æ˜¯è¾“é”™æŒ‡ä»¤äº†?è¯·æ‚¨æ£€æŸ¥æ‚¨çš„æŒ‡ä»¤. æ‚¨å¯ä»¥ä½¿ç”¨ğŸ‘‰.ms backæ¥æ’¤é”€è¿™ä¸€æ­¥æŒ‡ä»¤çš„æ•ˆæœ, ä½¿ç”¨ğŸ‘‰.ms æŸ¥çœ‹æŒ‡ä»¤åˆ—è¡¨";
            }

            // æ­¦å™¨å®ç”¨åŠŸèƒ½æç¤º
            const arsenal = MSRules.manageArsenal(mctx, "get");
            if (arsenal && arsenal.length > 0) {
                const seenUtils = new Set();
                arsenal.forEach(wName => {
                    const w = MS_CONSTS.WEAPON_DB[wName];
                    if (w && w.special && w.special.utility) {
                        if (!seenUtils.has(w.special.utility)) {
                            reply += `\nğŸ’¡ ã€${wName}ã€‘: ${w.special.utility}`;
                            seenUtils.add(w.special.utility);
                        }
                    }
                });
            }
            // [M.O.M. Hook] æ£€å®šè¯„ä»·
            reply += MOM.react(mctx, "check", { success: r.isSuccess, crit: r.crit, checkType: p.checkType });

            seal.replyToSender(ctx, msg, reply);
            return seal.ext.newCmdExecuteResult(true);
        }
        // [æ–°å¢] å¤„ç†åˆ«åæŸ¥è¯¢
        static handleAlias(ctx, msg, cmdArgs) {
            const target = cmdArgs.getArgN(2); // è·å–ç”¨æˆ·è¾“å…¥çš„æŸ¥è¯¢è¯

            // 1. å¦‚æœæ²¡æœ‰å‚æ•°ï¼Œåˆ—å‡ºæ‰€æœ‰æ ‡å‡†å±æ€§åï¼ˆåˆ†ç±»æ˜¾ç¤ºä¼šæ›´å‹å¥½ï¼Œè¿™é‡Œåšç®€åŒ–åˆ—è¡¨ï¼‰
            if (!target) {
                let txt = "=== ğŸ” æ¯èˆ°å±æ€§/æŠ€èƒ½åˆ«åè¡¨ ===\nğŸ‘‰ ä½¿ç”¨ .ms alias <åç§°> æŸ¥è¯¢ç‰¹å®šåˆ«å\n\n";
                const keys = Object.keys(MS_CONSTS.ATTR_MAP);
                // ç®€å•æ‹¼æ¥ï¼Œé¿å…åˆ·å±å¤ªé•¿ï¼Œåªæ˜¾ç¤ºæ ‡å‡†å
                txt += keys.join(", ");
                seal.replyToSender(ctx, msg, txt);
                return seal.ext.newCmdExecuteResult(true);
            }

            // 2. æŸ¥æ‰¾ç‰¹å®šå‚æ•°
            // é€»è¾‘ï¼šç”¨æˆ·å¯èƒ½è¾“å…¥ "str" (åˆ«å) æˆ– "åŠ›é‡" (æ ‡å‡†å)
            // æˆ‘ä»¬éœ€è¦æ‰¾åˆ°å®ƒå±äºå“ªä¸ªæ ‡å‡†åï¼Œç„¶åæ˜¾ç¤ºè¯¥æ ‡å‡†åä¸‹çš„æ‰€æœ‰åˆ«å
            let standardName = null;
            let foundAliases = [];

            // ç›´æ¥åŒ¹é…æ ‡å‡†å
            if (MS_CONSTS.ATTR_MAP[target]) {
                standardName = target;
                foundAliases = MS_CONSTS.ATTR_MAP[target];
            } else {
                // åå‘æŸ¥æ‰¾
                for (let key in MS_CONSTS.ATTR_MAP) {
                    if (MS_CONSTS.ATTR_MAP[key].includes(target.toLowerCase())) {
                        standardName = key;
                        foundAliases = MS_CONSTS.ATTR_MAP[key];
                        break;
                    }
                }
            }

            if (standardName) {
                seal.replyToSender(ctx, msg, `ğŸ” æŸ¥è¯¢ç»“æœ:\nğŸ·ï¸ æ ‡å‡†å: ã€${standardName}ã€‘\nğŸ”— å¯ç”¨åˆ«å: ${foundAliases.join(", ")}`);
            } else {
                seal.replyToSender(ctx, msg, `âŒ æœªæ‰¾åˆ°ä¸ "${target}" ç›¸å…³çš„å±æ€§æˆ–æŠ€èƒ½ã€‚`);
            }
            return seal.ext.newCmdExecuteResult(true);
        }

        // [æ–°å¢] æ‰‹åŠ¨å­˜æ¡£
        static handleSave(ctx, msg, cmdArgs) {
            const mctx = seal.getCtxProxyFirst(ctx, cmdArgs);
            const arg = cmdArgs.getArgN(2);
            const subArg = cmdArgs.getArgN(3);

            // 1. å¸®åŠ©æ–‡æ¡£
            if (arg === "help") {
                const help = `ğŸ’¾ ã€æ¯èˆ°å­˜æ¡£æŒ‡ä»¤ (.ms save)ã€‘
================================
  .ms save <åç§°>        - åˆ›å»º/è¦†ç›–å­˜æ¡£
  .ms save list          - æŸ¥çœ‹å­˜æ¡£åˆ—è¡¨
  .ms save rm <åç§°>     - åˆ é™¤æŒ‡å®šå­˜æ¡£
  .ms save rm all        - åˆ é™¤æ‰€æœ‰å­˜æ¡£
  .ms load <åç§°>        - è¯»å–å­˜æ¡£
================================`;
                seal.replyToSender(ctx, msg, help);
                return seal.ext.newCmdExecuteResult(true);
            }

            // 2. åˆ é™¤å­˜æ¡£
            if (arg === "rm" || arg === "del") {
                if (!subArg) {
                    seal.replyToSender(ctx, msg, "âŒ è¯·æŒ‡å®šè¦åˆ é™¤çš„å­˜æ¡£åç§°ã€‚\nğŸ‘‰ .ms save rm <åç§°> æˆ– .ms save rm all");
                    return seal.ext.newCmdExecuteResult(true);
                }
                if (subArg === "all") {
                    MSStateManager.clearManualSaves(mctx);
                    seal.replyToSender(ctx, msg, "ğŸ—‘ï¸ å·²åˆ é™¤æ‰€æœ‰æ‰‹åŠ¨å­˜æ¡£ã€‚");
                    return seal.ext.newCmdExecuteResult(true);
                }
                if (MSStateManager.deleteSave(mctx, subArg)) {
                    seal.replyToSender(ctx, msg, `ğŸ—‘ï¸ å·²åˆ é™¤å­˜æ¡£: ã€${subArg}ã€‘`);
                } else {
                    seal.replyToSender(ctx, msg, `âŒ åˆ é™¤å¤±è´¥: æœªæ‰¾åˆ°å­˜æ¡£ã€${subArg}ã€‘ã€‚`);
                }
                return seal.ext.newCmdExecuteResult(true);
            }

            // 3. åˆ—è¡¨ (é»˜è®¤)
            if (!arg || arg === "list") {
                const saves = MSStateManager.getSaveList(mctx);
                if (saves.length === 0) {
                    seal.replyToSender(ctx, msg, "ğŸ“­ å½“å‰æ²¡æœ‰æ‰‹åŠ¨å­˜æ¡£ã€‚\nğŸ‘‰ ä½¿ç”¨ .ms save <åç§°> åˆ›å»ºå­˜æ¡£ã€‚");
                } else {
                    let txt = "ğŸ’¾ ã€å­˜æ¡£åˆ—è¡¨ã€‘:\n";
                    saves.forEach((s, i) => {
                        txt += `${i + 1}. [${s.id}] ${s.time}\n`;
                    });
                    seal.replyToSender(ctx, msg, txt);
                }
                return seal.ext.newCmdExecuteResult(true);
            }

            // 4. åˆ›å»ºå­˜æ¡£ (æ£€æŸ¥ä¿ç•™å­—)
            const forbidden = ["rm", "del", "all", "help", "list"];
            if (forbidden.includes(arg.toLowerCase())) {
                seal.replyToSender(ctx, msg, `âŒ æ— æ³•ä½¿ç”¨ä¿ç•™å…³é”®å­—ã€${arg}ã€‘ä½œä¸ºå­˜æ¡£åã€‚\nè¯·æ¢ä¸ªåå­—ã€‚`);
                return seal.ext.newCmdExecuteResult(true);
            }

            MSStateManager.manualSave(mctx, arg);
            seal.replyToSender(ctx, msg, `ğŸ’¾ å·²ä¿å­˜å½“å‰æ•°æ®å¿«ç…§ä¸º: ã€${arg}ã€‘`);
            return seal.ext.newCmdExecuteResult(true);
        }

        // [æ–°å¢] æ‰‹åŠ¨è¯»æ¡£
        static handleLoad(ctx, msg, cmdArgs) {
            const mctx = seal.getCtxProxyFirst(ctx, cmdArgs);
            const arg = cmdArgs.getArgN(2);

            if (!arg) {
                seal.replyToSender(ctx, msg, "âŒ è¯·æŒ‡å®šè¦è¯»å–çš„å­˜æ¡£åç§°æˆ–IDã€‚");
                return seal.ext.newCmdExecuteResult(true);
            }

            if (MSStateManager.manualLoad(mctx, arg)) {
                seal.replyToSender(ctx, msg, `ğŸ“‚ è¯»æ¡£æˆåŠŸ: ã€${arg}ã€‘\nå½“å‰æ•°æ®å¿«ç…§å·²è¦†ç›–ã€‚`);
            } else {
                seal.replyToSender(ctx, msg, `âŒ è¯»æ¡£å¤±è´¥: æœªæ‰¾åˆ°å­˜æ¡£ã€${arg}ã€‘ã€‚`);
            }
            return seal.ext.newCmdExecuteResult(true);
        }

    }

    /**
     * ==========================================
     * æ¨¡å—äº”ï¼šçŠ¶æ€å›æº¯ç®¡ç†å™¨ (State Manager)
     * è´Ÿè´£å®ç° .ms back æ’¤å›åŠŸèƒ½
     * ==========================================
     */
    class MSStateManager {
        // è·å–æ‰€æœ‰éœ€è¦è¿½è¸ªçš„å˜é‡é”®å
        static getTrackedKeys() {
            // 1. åŸºç¡€å±æ€§ (æ¥è‡ª defaults)
            const keys = Object.keys(msTemplate.defaults);
            // 2. ç¡®ä¿æ ‡å‡†å±æ€§éƒ½åœ¨
            Object.keys(MS_CONSTS.ATTR_MAP).forEach(k => {
                if (!keys.includes(k)) keys.push(k);
            });
            // 3. æ’ä»¶ä¸“ç”¨å¤æ‚ç»“æ„
            const specialKeys = ["ms_conditions", "ms_weapon_arsenal", "ms_equipped_armor", "ms_equipped_weapon", "ä¿¡ç”¨ç‚¹"];
            specialKeys.forEach(k => {
                if (!keys.includes(k)) keys.push(k);
            });
            return keys;
        }
        // [Refactor] æ•è·çŠ¶æ€å¯¹è±¡
        static captureState(mctx) {

            const state = {};
            const keys = this.getTrackedKeys();
            keys.forEach(key => {

                let iVal = seal.vars.intGet(mctx, key);
                if (iVal[1]) state[key] = { t: 'i', v: iVal[0] };
                else {
                    let sVal = seal.vars.strGet(mctx, key);
                    if (sVal[1]) state[key] = { t: 's', v: sVal[0] };
                    else {
                        // [Fix] é’ˆå¯¹æœªåˆå§‹åŒ–çš„å…³é”®å¼•ç”¨ç±»å‹(å¦‚çŠ¶æ€åˆ—è¡¨)ï¼Œæ˜¾å¼è®°å½•ä¸ºç©ºå€¼
                        // å¦åˆ™å½“ä»"æ— çŠ¶æ€"å›æº¯æ—¶ï¼ŒapplyStateä¼šå› ä¸ºkeyä¸å­˜åœ¨è€Œè·³è¿‡èµ‹å€¼ï¼Œå¯¼è‡´æ— æ³•æ¸…é™¤çŠ¶æ€
                        if (key === "ms_conditions" || key === "ms_weapon_arsenal") {
                            state[key] = { t: 's', v: "[]" };
                        }
                    }
                }
            });
            return state;
        }

        // [Refactor] åº”ç”¨çŠ¶æ€å¯¹è±¡
        static applyState(mctx, state) {
            if (!state) return false;
            try {
                for (const [key, data] of Object.entries(state)) {
                    if (key === "_meta") continue; // è·³è¿‡å…ƒæ•°æ®
                    if (data.t === 'i') seal.vars.intSet(mctx, key, data.v);
                    else if (data.t === 's') seal.vars.strSet(mctx, key, data.v);
                }
                return true;
            } catch (e) { return false; }
        }

        // è‡ªåŠ¨å­˜æ¡£ (Undo)
        static saveState(mctx) {
            const state = this.captureState(mctx);
            seal.vars.strSet(mctx, "$ms_history_undo", JSON.stringify(state));
        }

        // æ¢å¤è‡ªåŠ¨å­˜æ¡£
        static restoreState(mctx) {
            const json = seal.vars.strGet(mctx, "$ms_history_undo")[0];
            if (!json) return false;
            try {
                return this.applyState(mctx, JSON.parse(json));
            } catch (e) { return false; }
        }
        // [New] æ‰‹åŠ¨å­˜æ¡£
        static manualSave(mctx, slotName) {
            const state = this.captureState(mctx);
            state._meta = { time: new Date().toLocaleString(), name: slotName };

            const savesJson = seal.vars.strGet(mctx, "$ms_manual_saves")[0] || "{}";
            let saves = {};
            try { saves = JSON.parse(savesJson); } catch (e) { }

            saves[slotName] = state;
            seal.vars.strSet(mctx, "$ms_manual_saves", JSON.stringify(saves));
            return true;
        }

        // [New] æ‰‹åŠ¨è¯»æ¡£
        static manualLoad(mctx, slotName) {
            const savesJson = seal.vars.strGet(mctx, "$ms_manual_saves")[0];
            if (!savesJson) return false;
            let saves = {};
            try { saves = JSON.parse(savesJson); } catch (e) { return false; }

            if (saves[slotName]) {
                return this.applyState(mctx, saves[slotName]);
            }
            return false;
        }

        // [New] è·å–å­˜æ¡£åˆ—è¡¨
        static getSaveList(mctx) {
            const savesJson = seal.vars.strGet(mctx, "$ms_manual_saves")[0];
            if (!savesJson) return [];
            try {
                const saves = JSON.parse(savesJson);
                return Object.keys(saves).map(k => ({ id: k, time: saves[k]._meta?.time || "æœªçŸ¥æ—¶é—´" }));
            } catch (e) { return []; }
        }

        // [New] åˆ é™¤å­˜æ¡£
        static deleteSave(mctx, slotName) {
            const savesJson = seal.vars.strGet(mctx, "$ms_manual_saves")[0];
            if (!savesJson) return false;
            let saves = {};
            try { saves = JSON.parse(savesJson); } catch (e) { return false; }
            
            if (saves[slotName]) {
                delete saves[slotName];
                seal.vars.strSet(mctx, "$ms_manual_saves", JSON.stringify(saves));
                return true;
            }
            return false;
        }

        // [New] æ¸…ç©ºå­˜æ¡£
        static clearManualSaves(mctx) {
            seal.vars.strSet(mctx, "$ms_manual_saves", "{}");
            return true;
        }
    }


    /**
      * ==========================================
      *  â€œæ£€å®šä¸Šä¸‹æ–‡â€ (CheckContext)
      * ç®¡é“ä¸­ä¼ é€’çš„å”¯ä¸€å¯¹è±¡ã€‚
      * ==========================================
      */
    class CheckContext {
        constructor(mctx, attrName, baseValue) {
            this.mctx = mctx;             // ä¸Šä¸‹æ–‡
            this.attrName = attrName;     // å±æ€§å (å¦‚ "åŠ›é‡", "æˆ˜æ–—")
            this.baseValue = baseValue;   // åŸºç¡€å€¼
            this.finalValue = baseValue;  // æœ€ç»ˆå€¼

            this.tags = [attrName, "check"];            // æ ‡ç­¾ (å¦‚ ["combat", "ranged", "melee"]) ç”¨äºåŒ¹é…æ•ˆæœ
            // [æ–°å¢] è‡ªåŠ¨æ³¨å…¥å±æ€§åˆ«åä½œä¸ºæ ‡ç­¾ï¼Œä»¥ä¾¿åŒ¹é… modifiers (å¦‚ target: "speed" åŒ¹é… "é€Ÿåº¦")
            if (MS_CONSTS.ATTR_MAP[attrName]) {
                this.tags.push(...MS_CONSTS.ATTR_MAP[attrName]);
            }
            // æ ¸å¿ƒç›‘æ§å˜é‡
            this.modValue = 0;            // æ•°å€¼åŠ å‡æ€»å’Œ
            this.advCounter = 0;          // ä¼˜åŠ£åŠ¿è®¡æ•°å™¨ (+1ä¼˜åŠ¿, -1åŠ£åŠ¿)

            // ç‰¹æ®Šæ•ˆæœæ ‡è®°å­—å…¸
            // ä¾‹å¦‚: { "invert_crit": true, "ignore_armor": true }
            this.specials = {};

            this.logs = [];               // è®°å½•è°ä¿®æ”¹äº†æ•°å€¼ (ç”¨äºæˆ˜æŠ¥æ˜¾ç¤º)
            this.warnings = [];           // [æ–°å¢] è­¦å‘Šä¿¡æ¯ (å¦‚å¤šæ­¦å™¨å†²çªæç¤º)
        }

        // æ·»åŠ æ•°å€¼ä¿®æ­£
        addMod(val, source) {
            if (val === 0) return;
            this.modValue += val;
            this.logs.push(`æ•°å€¼${val > 0 ? '+' : ''}${val}[${source}]`);
        }

        // æ·»åŠ ä¼˜åŠ£åŠ¿
        addAdv(type, source) {
            if (type === "adv" || type === "+") {
                this.advCounter++;
                this.logs.push(`ä¼˜åŠ¿[${source}]`);
            } else if (type === "dis" || type === "-") {
                this.advCounter--;
                this.logs.push(`åŠ£åŠ¿[${source}]`);
            }
        }

        // å¢åŠ æ ‡ç­¾ (æ–¹ä¾¿é’ˆå¯¹æ€§ä¿®æ­£ï¼Œå¦‚ "æ‰€æœ‰è¿‘æˆ˜æ£€å®š")
        addTag(tag) { if (!this.tags.includes(tag)) this.tags.push(tag); }

        hasTag(tag) { return this.tags.includes(tag); }
        // [æ–°å¢] æ·»åŠ è­¦å‘Š
        addWarning(msg) { this.warnings.push(msg); }
        // [æ–°å¢] æ¿€æ´»ç‰¹æ®Šæ•ˆæœ
        addSpecial(specialKey, source, val) {
            const isValEmpty = val === undefined || val === null || (typeof val === 'string' && val.trim() === '');

            if (!isValEmpty) {
                // valä¸ºç©ºæ—¶çš„å¤„ç†é€»è¾‘ï¼ˆæ¯”å¦‚æ‰“å°æç¤ºã€returnã€æŠ›é”™ç­‰ï¼‰
                // console.log(`å‚æ•°valä¸ºç©ºï¼specialKey: ${specialKey}`);

                // å¯é€‰ï¼šå¦‚æœvalä¸ºç©ºä¸æƒ³æ‰§è¡Œåç»­é€»è¾‘ï¼Œç›´æ¥return
                // return;
                this.specials[specialKey] = val;
                this.logs.push(`ç‰¹æ®Š[${source}]:${specialKey},${val}`);
            }
            else {
                this.specials[specialKey] = true;
                this.logs.push(`ç‰¹æ®Š[${source}]:${specialKey}`);
            }


        }
        hasSpecial(specialKey) { return this.specials.includes(specialKey); }
    }
    /**
       * ==========================================
       * æ ¸å¿ƒç®¡é“ (Pipeline Processor)
       * è¿™æ˜¯æ–°çš„é€»è¾‘å¤§è„‘ã€‚
       * ==========================================
       */
    class MSPipeline {
        static process(context) {
            let logs = [];
            // 1. æ£€æŸ¥çŠ¶æ€ (Conditions)
            this.checkConditions(context);

            // 2. æ£€æŸ¥è£…å¤‡ (Equipment)
            // this.checkEquipment(context);

            // 3. æ£€æŸ¥æ­¦å™¨æœºåˆ¶ (Weapon Mechanics)
            //è¿™ä¸ªéƒ¨åˆ†ä»…ä»…æ£€æŸ¥æˆ˜æ–—æ—¶å€™çš„æ­¦å™¨
            this.checkWeaponMechanics(context);

            // 4. [æ–°å¢] æ£€æŸ¥æŒæœ‰æ­¦å™¨çš„è¢«åŠ¨å½±å“ (Passive Weapon Effects)
            //è¿™ä¸ªéƒ¨åˆ†ä»…ä»…æ£€æŸ¥æ­¦å™¨çš„æ¼”å‡ºæ•ˆæœ.
            this.checkPassiveWeaponEffects(context);

            // 5. [æ–°å¢] æ£€æŸ¥ç©¿ç€çš„æŠ¤ç”²çš„è¢«åŠ¨å½±å“
            //ç”±äºæŠ¤ç”²åªèƒ½ç©¿ä¸€ä»¶,æ‰€ä»¥ä¸åƒæ­¦å™¨, æŠ¤ç”²çš„æ•ˆæœå¯ä»¥ç›´æ¥ç»“ç®—.
            //this.checkPassiveclothesEffects(context);
            this.checkPassiveArmorEffects(context);


            // 3. æ£€æŸ¥æƒŠæ/èŒä¸šè¢«åŠ¨ (Trauma/Class)
            // this.checkClassAndPanic(context);

            // 4. (å¯é€‰) æ£€æŸ¥ç¯å¢ƒæˆ–å…¶ä»–å…¨å±€å˜é‡

            // --- ç»“ç®—æœ€ç»ˆå€¼ ---
            context.finalValue = context.baseValue + context.modValue;

            // ç»“ç®—ä¼˜åŠ£åŠ¿æ¨¡å¼
            let mode = "normal";
            if (context.advCounter > 0) mode = "adv";
            else if (context.advCounter < 0) mode = "dis";

            return {
                target: context.finalValue,
                mode: mode,
                specials: context.specials,
                logs: context.logs,
                warnings: context.warnings
            };
        }

        // --- æ¨¡å— 1: çŠ¶æ€æ¨¡å— ---
        static checkConditions(context) {
            // ä» mctx è·å–å½“å‰çŠ¶æ€åˆ—è¡¨
            const conditions = MSRules.manageCondition(context.mctx, "get");


            conditions.forEach(cond => {
                // è¿™é‡Œéœ€è¦ä½ çš„ CONDITIONS å¸¸é‡åº“æ”¯æŒ "effects" å­—æ®µ
                // ç°åœ¨çš„ Const åªæ˜¯æ–‡æœ¬ï¼Œéœ€è¦ç¨å¾®å‡çº§æ•°æ®ç»“æ„
                const def = MS_CONSTS.CONDITIONS[cond.name];
                // å…¼å®¹æ—§é€»è¾‘ (special: DAMAGE_ADV)
                if (!def) return;
                if (def.modifiers) {
                    def.modifiers.forEach(eff => {
                        // åŒ¹é…é€»è¾‘ï¼šå¦‚æœæ•ˆæœçš„ç›®æ ‡å±æ€§ ä¸ å½“å‰æ£€å®šå±æ€§ ä¸€è‡´
                        // æˆ–è€…æ•ˆæœç›®æ ‡æ˜¯ "all" (æ‰€æœ‰æŠ•éª°)
                        if (eff.target === "all" || context.hasTag(eff.target)) {
                            if (eff.type === "mod") context.addMod(eff.val, cond.name);
                            else context.addAdv(eff.type, cond.name); // type: "adv" or "dis"
                        }
                    });
                }
                if (def.special) {
                    // [ä¿®æ”¹] é»˜è®¤ä¸º "narrative" (ä»…å™äº‹)ï¼Œåªæœ‰åŒ¹é… tag æ‰ç”Ÿæ•ˆ
                    const trigger = def.trigger || "narrative";
                    if (trigger === "all" || context.hasTag(trigger)) {
                        context.addSpecial(def.special, cond.name);
                    }
                }
            });
        }

        // --- æ¨¡å— 5: æŠ¤ç”²è¢«åŠ¨å½±å“ ---
        static checkPassiveArmorEffects(context) {
            // æŠ¤ç”²è¢«åŠ¨
            const armor = MSRules.getEquippedArmor(context.mctx);
            if (armor && armor.modifiers) {
                armor.modifiers.forEach(mod => {
                    if (context.hasTag(mod.target)) {
                        // context.addAdv(mod.type, `æŠ¤ç”²:${armor.name || armor.aliases[0]}`);
                        context.addAdv(mod.type, `æŠ¤ç”²:${armor.aliases[0]}`);
                    }
                });
            }

            // å¦‚æœæ˜¯æ”»å‡»ï¼Œè¿˜è¦æ£€æŸ¥æ­¦å™¨è·ç¦»ä¿®æ­£ (è¿™ä¸ªé€šå¸¸åœ¨ Attack æŒ‡ä»¤é‡Œä¼ å…¥ contextï¼Œä½†ä¹Ÿå¯ä»¥åœ¨è¿™é‡Œå¤æ ¸)
        }

        // ... å…¶ä»–æ¨¡å—åŒç†
        // --- æ¨¡å— 3: æ­¦å™¨æœºåˆ¶æ¨¡å— ---
        static checkWeaponMechanics(context) {
            // åªæœ‰æºå¸¦äº† weapon å’Œ distance ä¿¡æ¯çš„ä¸Šä¸‹æ–‡æ‰å¤„ç†
            // if (!context.weapon || !context.distance) return;

            //åªæœ‰æ”»å‡»æŒ‡ä»¤atkæ‰å¤„ç†
            if (!context.tags.includes("atk")) { return; }

            // 1. è·ç¦»ä¿®æ­£
            const mods = context.weapon.range_mods;
            if (mods && mods[context.distance]) {
                const type = mods[context.distance];
                const distName = context.distanceName || context.distance;

                if (type === 'dis') {
                    context.addAdv('dis', `è·ç¦»:${distName}`);
                } else if (type === 'adv') {
                    context.addAdv('adv', `è·ç¦»:${distName}`);
                } else if (type === 'unusable') {
                    context.addSpecial("weapon_unusable", "è·ç¦»é™åˆ¶");
                    context.logs.push(`ğŸš« æ­¦å™¨åœ¨ã€${distName}ã€‘ä¸å¯ç”¨`);
                }
            }
        }


        // --- æ¨¡å— 4: æŒæœ‰æ­¦å™¨è¢«åŠ¨å½±å“ ---
        static checkPassiveWeaponEffects(context) {
            // è·å–æ­¦å™¨åº“
            const arsenal = MSRules.manageArsenal(context.mctx, "get");
            if (!arsenal || arsenal.length === 0) return;

            arsenal.forEach(wName => {
                // è§£ææ­¦å™¨å¯¹è±¡
                let weapon = MS_CONSTS.WEAPON_DB[wName];
                if (!weapon) {
                    // å°è¯•åˆ«åæŸ¥æ‰¾
                    for (let k in MS_CONSTS.WEAPON_DB) {
                        if (MS_CONSTS.WEAPON_DB[k].aliases.includes(wName)) {
                            weapon = MS_CONSTS.WEAPON_DB[k];
                            break;
                        }
                    }
                }

                if (weapon && weapon.modifiers) {
                    weapon.modifiers.forEach(mod => {
                        // æ£€æŸ¥æ˜¯å¦åŒ¹é…å½“å‰æ£€å®š (å¦‚ target: "speed" åŒ¹é… "é€Ÿåº¦"æ£€å®š)
                        if (context.hasTag(mod.target)) {
                            if (arsenal.length === 1) {
                                // åªæœ‰ä¸€æŠŠæ­¦å™¨ï¼šè‡ªåŠ¨ç”Ÿæ•ˆ
                                context.addAdv(mod.type, `æ­¦å™¨:${wName}`);
                            } else {
                                // å¤šæŠŠæ­¦å™¨ï¼šä¸æ‰§è¡Œï¼Œä½†æç¤º
                                const effectStr = mod.type === 'dis' ? 'åŠ£åŠ¿' : 'ä¼˜åŠ¿';
                                context.addWarning(`\nâš ï¸ æŒæœ‰æ­¦å™¨ã€${wName}ã€‘å¯èƒ½èµ‹äºˆã€${effectStr}ã€‘ï¼Œä½†å› æŒæœ‰å¤šç§æ­¦å™¨æœªè‡ªåŠ¨ç”Ÿæ•ˆã€‚\n   å¦‚éœ€ç”Ÿæ•ˆè¯·æ‰‹åŠ¨è°ƒæ•´(åœ¨æŒ‡ä»¤æœ«å°¾åŠ ä¸Š+/-)æˆ–åªæŒæœ‰ä¸€æŠŠæ­¦å™¨ã€‚(æœ¬æŒ‡ä»¤çš„æ•ˆæœå¯ä»¥ç”¨ğŸ‘‰.ms undo æ’¤å›)\n`);
                            }
                        }
                    });
                }
            });
        }

    }


    class MSEffectEngine {
        /**
         * æ‰§è¡Œä¸€ç³»åˆ—æ•ˆæœ
         * @param {Object} mctx ä¸Šä¸‹æ–‡
         * @param {Array} effects æ•ˆæœå®šä¹‰åˆ—è¡¨
         * @param {Object} args å¤–éƒ¨ä¼ å…¥å‚æ•° (å¦‚ç”¨æˆ·è¾“å…¥çš„ç›®æ ‡çŠ¶æ€å
         * @returns {Object} { logs, durationMap }
         */
        static process(mctx, effects, args = {}) {
            let logs = [];
            let durationMap = {};

            let recursiveRolls = 0;
            if (!effects || !Array.isArray(effects)) return { logs, durationMap, recursiveRolls };


            for (let eff of effects) {
                // 1. å¤„ç†èµ„æºä¿®æ”¹ (å‹åŠ›, HPç­‰)
                if (eff.type === "resource") {
                    // è§£ææ•°å€¼: æ”¯æŒ "1d5" æˆ– å›ºå®šæ•°å€¼

                    const val = MSRules.calDice(eff.val.toString());
                    // seal.replyToSender(mctx, {}, `@@${eff.val.toString()}@@${val}@@`);
                    const key = eff.key;

                    // è·å–æ—§å€¼
                    const oldValVar = seal.vars.intGet(mctx, key);
                    const oldVal = oldValVar[1] ? oldValVar[0] : 0;

                    let newVal = oldVal;
                    if (eff.op === "add") newVal += val;
                    else if (eff.op === "sub") newVal -= val;
                    else if (eff.op === "set") newVal = val;

                    if (key === "å‹åŠ›") {
                        const delta = (eff.op === 'sub' ? -1 : 1) * val;
                        const res = MSRules.updateStress(mctx, delta, "æ•ˆæœå½±å“");
                        logs.push(`ğŸ“Šå‹åŠ› ${delta > 0 ? '+' : ''}${delta} (å½“å‰:${res.newVal})${res.msg}`);
                    } else {
                        seal.vars.intSet(mctx, key, newVal);
                        logs.push(`ğŸ“Š${key} ${eff.op === 'sub' ? '-' : '+'}${val} (å½“å‰:${newVal})`);
                    }

                }

                // 2. å¤„ç†çŠ¶æ€æ·»åŠ  (æ ¸å¿ƒéœ€æ±‚ï¼šå¤„ç†æŒç»­æ—¶é—´)
                else if (eff.type === "condition_add") {
                    const condKey = eff.key;
                    let finalDuration = "æ— é™";

                    // === å…³é”®é€»è¾‘ï¼šè§£ææŒç»­æ—¶é—´ ===
                    if (eff.duration) {
                        // æ­£åˆ™åŒ¹é… "XdY" æ ¼å¼
                        const diceMatch = eff.duration.match(/(\d+d\d+)/i);
                        if (diceMatch) {
                            const diceExpr = diceMatch[1];
                            const roll = MSRules.rollDiceExpr(diceExpr);
                            // æ›¿æ¢å…¬å¼ä¸ºç»“æœ (1d10åˆ†é’Ÿ -> 4åˆ†é’Ÿ)
                            finalDuration = eff.duration.replace(diceExpr, roll);
                            logs.push(`ğŸ² æŒç»­æ—¶é—´(${eff.duration}): ${finalDuration}`);
                        }
                        else {
                            finalDuration = eff.duration; // é™æ€å€¼: "4å‘¨"
                        }

                    }
                    // è®°å½•ä¸‹æ¥ï¼Œä¾›å¤–éƒ¨æ–‡æœ¬æ›¿æ¢ä½¿ç”¨
                    durationMap[eff.key] = finalDuration;
                    // è°ƒç”¨çŠ¶æ€ç®¡ç†å™¨ï¼Œä¼ å…¥è®¡ç®—å¥½çš„ duration
                    const res = MSRules.manageCondition(mctx, "add", eff.key, {
                        duration: finalDuration,
                        desc: eff.desc,
                        val: eff.val
                    });
                    logs.push(res); // manageCondition è¿”å›ç¾åŒ–åçš„æ–‡æœ¬
                }

                // 3. å¤„ç†é£é™©åˆ¤å®š (é€’å½’è°ƒç”¨)
                else if (eff.type === "risk_check") {
                    const roll = MSRules.rollDiceExpr(eff.range);
                    logs.push(`ğŸ² é£é™©éª°(${eff.range}): ${roll}`);

                    if (roll <= eff.threshold) {
                        logs.push(`âš ï¸ ã€è§¦å‘å‰¯ä½œç”¨!ã€‘`);
                        // é€’å½’å¤„ç†å­æ•ˆæœ
                        // const subLog = this.process(mctx, [eff.trigger_effect], args);
                        // logs.push(subLog);
                        const subResult = this.process(mctx, [eff.trigger_effect], args);
                        logs.push(...subResult.logs);
                        Object.assign(durationMap, subResult.durationMap);

                    }
                }
                // 4. å¤„ç†å‡½æ•°è°ƒç”¨ (å¦‚å¤åˆé—®é¢˜)
                else if (eff.type === "function" && eff.name === "ROLL_TWICE_PANIC") {
                    recursiveRolls = 2;
                    logs.push("ğŸ² ã€å¤åˆé—®é¢˜ã€‘: è§¦å‘ä¸¤æ¬¡é¢å¤–æƒŠæåˆ¤å®šï¼");
                }
                else if (eff.type === "death_check") {
                    if (eff.delay) {
                        const rounds = Math.floor(Math.random() * 10) + 1;
                        logs.push(`âš ï¸ ã€è‡´å‘½ä¼¤ã€‘ è¯·åœ¨ ã€${rounds}ã€‘ è½®å†…è¿›è¡Œæ­»äº¡è±å…ï¼(1d10=${rounds})`);
                    } else {
                        logs.push(`ğŸ’€ ã€è‡´æ­»ä¼¤ã€‘ è¯·ç«‹å³è¿›è¡Œæ­»äº¡è±å…ï¼(.ms death)`);
                    }
                }
                else if (eff.type === "death") {
                    MSRules.manageCondition(mctx, "add", "æ­»äº¡");
                    logs.push(`ğŸ’€ ã€ä½ å·²ç»æ­»äº†ã€‘ã€‚è¯·å¿½ç•¥å…¶ä»–å¯èƒ½çš„æ­»äº¡è±å…æç¤ºã€‚`);
                }
                // ... å…¶ä»–ç±»å‹å¤„ç† (å¦‚ condition_remove)
            }

            // return logs.join("\n");
            return { logs, durationMap, recursiveRolls };
        }
    }

    // ... (å‰ç½®ä»£ç ä¿æŒä¸å˜)

    /**
     * ==========================================
     * æ¨¡å—ï¼šä¼¤å®³ç³»ç»Ÿ (Damage System)
     * è´Ÿè´£å¤„ç†é€ æˆä¼¤å®³(Outbound)å’Œå—åˆ°ä¼¤å®³(Inbound)çš„ç®¡é“é€»è¾‘
     * ==========================================
     */
    class MSDamageSystem {
        // --- é˜¶æ®µ 1: é€ æˆä¼¤å®³ (Outbound) ---
        // ç”¨äº .ms atk è®¡ç®—ä¼¤å®³éª°
        static createOutboundContext(mctx, weapon, distance) {
            return {
                mctx: mctx,
                weapon: weapon,
                distance: distance,
                baseExpr: weapon ? weapon.dmg : "0",
                finalExpr: weapon ? weapon.dmg : "0",
                mode: "normal", // normal, adv, dis (é’ˆå¯¹ä¼¤å®³éª°)
                logs: []
            };
        }

        static processOutbound(ctx) {
            // 1. æ£€æŸ¥è·ç¦»å¯¹ä¼¤å®³å…¬å¼çš„è¦†ç›– (å¦‚éœ°å¼¹æª)
            if (ctx.weapon && ctx.weapon.range_dmg && ctx.weapon.range_dmg[ctx.distance]) {
                ctx.finalExpr = ctx.weapon.range_dmg[ctx.distance];
                ctx.logs.push(`è·ç¦»ä¿®æ­£(${MS_CONSTS.RANGES[ctx.distance].name}): ä¼¤å®³å˜æ›´ä¸º ${ctx.finalExpr}`);
            }

            // 2. æ£€æŸ¥çŠ¶æ€å¯¹ä¼¤å®³éª°çš„ä¼˜åŠ£åŠ¿ (å¦‚ç‹‚æš´)
            const conditions = MSRules.manageCondition(ctx.mctx, "get");
            let advCount = 0;

            // [æ–°å¢] æ£€æŸ¥æ­¦å™¨è‡ªå¸¦çš„ä¼¤å®³ä¼˜åŠ£åŠ¿ (dmg_mod)
            if (ctx.weapon && ctx.weapon.dmg_mod) {
                if (ctx.weapon.dmg_mod === "adv") {
                    advCount++;
                    ctx.logs.push(`æ­¦å™¨ç‰¹æ€§: ä¼¤å®³ä¼˜åŠ¿`);
                } else if (ctx.weapon.dmg_mod === "dis") {
                    advCount--;
                    ctx.logs.push(`æ­¦å™¨ç‰¹æ€§: ä¼¤å®³åŠ£åŠ¿`);
                }
            }

            conditions.forEach(c => {
                const def = MS_CONSTS.CONDITIONS[c.name];
                // å…¼å®¹æ—§é€»è¾‘ (special: DAMAGE_ADV)
                if (def && (def.trigger === "damage" || def.trigger === "all")) {
                    if (def.special === "DAMAGE_ADV") {
                        ctx.mode = "adv";
                        advCount++;
                        ctx.logs.push(`å»¶æ—¶æ€§å½±å“(${c.name}): ä¼¤å®³éª°ä¼˜åŠ¿`);
                    }
                }

                // [Fix] æ–°å¢é€»è¾‘: æ£€æŸ¥ modifiers (æ”¯æŒ target: all / damage)
                if (def && def.modifiers) {
                    def.modifiers.forEach(m => {
                        if (["damage", "ä¼¤å®³", "all"].includes(m.target)) {
                            if (m.type === "adv") { advCount++; ctx.logs.push(`å»¶æ—¶æ€§å½±å“(${c.name}): ä¼¤å®³éª°ä¼˜åŠ¿`); }
                            if (m.type === "dis") { advCount--; ctx.logs.push(`å»¶æ—¶æ€§å½±å“(${c.name}): ä¼¤å®³éª°åŠ£åŠ¿`); }
                        }
                    });
                }
            });

            if (advCount > 0) ctx.mode = "adv";
            else if (advCount < 0) ctx.mode = "dis";

            // 3. è§£æå±æ€§å˜é‡ (å¦‚ str/10)
            if (ctx.finalExpr.match(/[a-z\u4e00-\u9fa5]/i)) {
                // ç®€å•çš„å±æ€§æ›¿æ¢é€»è¾‘
                const str = seal.vars.intGet(ctx.mctx, "åŠ›é‡")[0];
                let evalStr = ctx.finalExpr.toLowerCase().replace(/str|strength|åŠ›é‡/g, str);
                try {
                    // é¢„è®¡ç®—é™æ€æ•°å€¼éƒ¨åˆ†ï¼Œä¿ç•™éª°å­éƒ¨åˆ†? æ¯èˆ°è§„åˆ™é€šå¸¸ç›´æ¥æ˜¯æ•°å€¼æˆ–éª°å­
                    // è¿™é‡Œä¸ºäº†å…¼å®¹ "str/10" è¿™ç§å†™æ³•ï¼Œæˆ‘ä»¬å…ˆå°è¯•è®¡ç®—çº¯æ•°å­¦éƒ¨åˆ†
                    // å¦‚æœåŒ…å« d (å¦‚ 1d10+str/10)ï¼Œåˆ™æ¯”è¾ƒå¤æ‚ã€‚ç›®å‰å‡è®¾ weapon.dmg è¦ä¹ˆæ˜¯å…¬å¼è¦ä¹ˆæ˜¯éª°å­
                    // ç®€å•å¤„ç†: è®© MSRules.calDice å»å¤„ç†æ··åˆå­—ç¬¦ä¸²
                    ctx.finalExpr = evalStr;
                } catch (e) { }
            }

            return ctx;
        }

        // --- é˜¶æ®µ 2: å—åˆ°ä¼¤å®³ (Inbound) ---
        // ç”¨äº .ms hit ç»“ç®—å®é™…æ‰£è¡€
        static createInboundContext(mctx, damageVal, damageType, options) {
            let cover = MS_CONSTS.COVER_DB[options.coverKey] || null;

            // [æ–°å¢] å¤„ç†è‡ªå®šä¹‰ AP/DR
            if (options.customAP !== undefined || options.customDR !== undefined) {
                const ap = options.customAP !== undefined ? options.customAP : (cover ? cover.ap : 0);
                const dr = options.customDR !== undefined ? options.customDR : (cover ? cover.dr : 0);
                const name = cover ? `${cover.name}(ä¿®æ­£)` : "è‡ªå®šä¹‰æ©ä½“";
                const aliases = cover ? cover.aliases : [];
                cover = { name, ap, dr, aliases };
            }

            return {
                mctx: mctx,
                rawDamage: damageVal,
                damageType: damageType || "generic",
                cover: cover,
                armor: MSRules.getEquippedArmor(mctx),
                isAA: options.isAA || false,
                dryRun: options.dryRun || false,

                // ç»“ç®—è¿‡ç¨‹å˜é‡
                effectiveDamage: damageVal,
                effectiveCoverAP: 0,
                effectiveCoverDR: 0,
                effectiveArmorAP: 0,
                effectiveArmorDR: 0,

                logs: []
            };
        }

        static processInbound(ctx) {
            // 1. åˆå§‹åŒ–åŸºç¡€å€¼
            if (ctx.cover) {
                ctx.effectiveCoverAP = ctx.cover.ap;
                ctx.effectiveCoverDR = ctx.cover.dr || 0;
            }
            // è¯»å–è§’è‰²å½“å‰çš„æŠ¤ç”²å’ŒDRå€¼
            const charAP = seal.vars.intGet(ctx.mctx, "æŠ¤ç”²");
            const charDR = seal.vars.intGet(ctx.mctx, "ä¼¤å®³å‡å…");
            ctx.effectiveArmorAP = charAP[1] ? charAP[0] : 0;
            ctx.effectiveArmorDR = charDR[1] ? charDR[0] : 0;

            // 2. åº”ç”¨ AA (åæŠ¤ç”²) è§„åˆ™
            if (ctx.isAA) {
                ctx.effectiveCoverAP = 0;
                ctx.effectiveArmorAP = 0;
                ctx.logs.push(`ğŸ’¥ ã€AAæ‰“å‡»ã€‘: æ— è§†æ‰€æœ‰ APï¼`);
            }

            // 3. æ£€æŸ¥çŠ¶æ€/ç¯å¢ƒä¿®æ­£ (Pipeline æ ¸å¿ƒä»·å€¼)
            const conditions = MSRules.manageCondition(ctx.mctx, "get");
            conditions.forEach(c => {
                // ç¤ºä¾‹: å¦‚æœæœ‰ "è„†å¼±" çŠ¶æ€ï¼Œå—åˆ°çš„ä¼¤å®³ +1 (å‡è®¾è§„åˆ™)
                // const def = MS_CONSTS.CONDITIONS[c.name];
                // if (def && def.special === "FRAGILE") {
                //     ctx.effectiveDamage += 1;
                //     ctx.logs.push(`çŠ¶æ€(${c.name}): å—åˆ°ä¼¤å®³ +1`);
                // }
            });

            // 4. æ‰§è¡ŒæŠµæ¶ˆé€»è¾‘ (Cover -> Armor)
            let currentDmg = ctx.effectiveDamage;

            // 4.1 æ©ä½“ç»“ç®—
            if (ctx.cover) {
                let logPart = `ğŸ›¡ï¸ ã€æ©ä½“(${ctx.cover.name})ã€‘:`;
                // DR
                if (ctx.effectiveCoverDR > 0) {
                    currentDmg = Math.max(0, currentDmg - ctx.effectiveCoverDR);
                    logPart += ` DR-${ctx.effectiveCoverDR}`;
                }
                // AP
                if (currentDmg > 0 && ctx.effectiveCoverAP > 0) {
                    if (currentDmg < ctx.effectiveCoverAP) {
                        currentDmg = 0;
                        logPart += ` é˜»æŒ¡(AP${ctx.effectiveCoverAP})`;
                    } else {
                        currentDmg -= ctx.effectiveCoverAP;
                        logPart += ` å‡»ç©¿(AP${ctx.effectiveCoverAP})`;
                        // [æ–°å¢] é‡å‹æ©ä½“å‡»ç©¿æç¤º
                        if (ctx.cover && ctx.cover.aliases && ctx.cover.aliases.includes("heavy")) {
                            logPart += `\nğŸ’¡ ã€æç¤ºã€‘: é‡å‹æ©ä½“å·²è¢«å‡»ç©¿ï¼Œå»ºè®®ä¸‹æ¬¡ç»“ç®—ä½¿ç”¨ cover:ruin (åºŸå¢Ÿ) ä»£è¡¨å…¶æ®‹ç•™éƒ¨åˆ†ã€‚`;
                        }
                    }
                }
                ctx.logs.push(logPart);
            }

            // 4.2 æŠ¤ç”²ç»“ç®—
            if (currentDmg > 0 && (ctx.effectiveArmorAP > 0 || ctx.effectiveArmorDR > 0)) {
                const armorName = seal.vars.strGet(ctx.mctx, "ms_equipped_armor")[0] || "æŠ¤ç”²";
                let logPart = `ğŸ§¥ ã€${armorName}ã€‘:`;

                // DR
                if (ctx.effectiveArmorDR > 0) {
                    currentDmg = Math.max(0, currentDmg - ctx.effectiveArmorDR);
                    logPart += ` DR-${ctx.effectiveArmorDR}`;
                }

                // AP & Destruction
                if (currentDmg > 0) {
                    if (ctx.isAA) {
                        // AA: Ignore AP, Destroy Armor
                        if (!ctx.dryRun) seal.vars.intSet(ctx.mctx, "æŠ¤ç”²", 0);
                        logPart += ` [AAç ´å]\n`;
                    } else if (ctx.effectiveArmorAP > 0) {
                        if (currentDmg < ctx.effectiveArmorAP) {
                            currentDmg = 0;
                            logPart += ` é˜»æŒ¡(AP${ctx.effectiveArmorAP})`;
                        } else {
                            currentDmg -= ctx.effectiveArmorAP;
                            if (!ctx.dryRun) seal.vars.intSet(ctx.mctx, "æŠ¤ç”²", 0);
                            logPart += ` å‡»ç©¿(AP${ctx.effectiveArmorAP}) âš ï¸ ã€æŠ¤ç”²æŸæ¯ã€‘`;
                        }
                    }
                }
                ctx.logs.push(logPart);
            }

            ctx.effectiveDamage = currentDmg;
            return ctx;
        }
    }

    // ... (åç»­ä¿®æ”¹ MSRules è°ƒç”¨ MSDamageSystem)
    const MOM_ASSETS = {
        // --- æ ¸å¿ƒäº¤äº’ ---
        "onboarding_header": [
            "å„ä½äº²çˆ±çš„æ¹¿ä»¶å¥½ğŸ˜˜æˆ‘æ˜¯ M.ğŸ’Ÿ.M.ğŸ¥°ä½ ä»¬çš„è´´å¿ƒAIåŠ©æ‰‹",
            "M.ğŸ’Ÿ.M. ç³»ç»Ÿæ­£å¸¸è¿è½¬ä¸­ğŸ¥°è¯·æŸ¥é˜…æœ€æ–°çš„å‘˜å·¥ç”Ÿå­˜æŒ‡å—",
            "æ¬¢è¿ç™»èˆ°ğŸ˜˜è¯·ä»”ç»†é˜…è¯»ä»¥ä¸‹æŒ‡ä»¤"
        ], // å‘˜å·¥æ‰‹å†Œå¤´éƒ¨
        "onboarding_footer": [
            "ä¸ºäº†å…¬å¸åˆ©ç›ŠğŸ¥°è¯·å°½é‡ä¿æŒå‘¼å¸",
            "M.ğŸ’Ÿ.M. æ¸©é¦¨æé†’ï¼šæ­»äº¡ä¼šä¸¥é‡å½±å“æ‚¨çš„ç»©æ•ˆè€ƒæ ¸ğŸ¥º",
            "çˆ±æŠ¤å…¬å¸èµ„äº§ï¼Œä»çˆ±æŠ¤æ‚¨è‡ªå·±ï¼ˆçš„å™¨å®˜ï¼‰åšèµ·â™¥",
            "M.ğŸ’Ÿ.M.æ¨è: å»Sçº§æ˜Ÿæ¸¯åº¦å‡å§! ğŸ‘‰.ms leave s",
            "M.ğŸ’Ÿ.M çˆ±ä½ å“ŸğŸ˜™äº²",


        ], // å‘˜å·¥æ‰‹å†Œå°¾éƒ¨
        "shutdown": [
            "M.ğŸ’Ÿ.M. è¿›å…¥å¾…æœºæ¨¡å¼ğŸ˜´è¯·ä¸è¦åœ¨å¦ˆå’ªçœ‹ä¸è§çš„åœ°æ–¹æŸåå…¬å¸èµ„äº§å“¦ğŸ¥º",
            "ç³»ç»Ÿä¼‘çœ ä¸­... ç¥ç”œå¿ƒä»¬å¥½è¿ï¼Œè™½ç„¶è¿™é€šå¸¸æ²¡ä»€ä¹ˆç”¨ğŸ˜˜",
            "çˆ±ä½ â¤å†è§ğŸ¥°è®°å¾—æŒ‰æ—¶ç»´æŠ¤ä½ ä»¬çš„ç”Ÿç‰©ç»„ä»¶",
            "ä½ æ˜¯æ²¡åŠæ³•çœŸæ­£å…³æ‰æˆ‘çš„ğŸ˜ˆåˆåŒä¸Šéƒ½å†™ç€å‘¢ğŸ¤£æ²¡ä»”ç»†çœ‹å—",
        ],          // å…³é—­ AI
        "startup": [
            "M.ğŸ’Ÿ.M. ç³»ç»Ÿå·²æ¿€æ´»â¤æ­£åœ¨æ‰«æç”Ÿç‰©ç»„ä»¶... å“å‘€ğŸ¥ºäº²çˆ±çš„çœ‹èµ·æ¥æœ‰ç‚¹å¼±",
            "æ—©å®‰ğŸ”†äº²çˆ±çš„æ¶ˆè€—å“ä»¬ğŸ¥°M.ğŸ’Ÿ.M. å·²ä¸Šçº¿",
            "ç³»ç»Ÿè‡ªæ£€å®Œæˆâœ…æ¹¿ä»¶è¿æ¥æ­£å¸¸... è‡³å°‘ç›®å‰æ˜¯è¿™æ ·ğŸ˜˜"
        ],           // å¼€å¯ AI

        // --- èµ„äº§è¯„ä¼° (.ms st) ---
        "eval_optimal": [
            "å„é¡¹æŒ‡æ ‡å®Œç¾ğŸ˜æ‚¨æ˜¯å…¬å¸æœ€æ£’çš„å‘˜å·¥ï¼",
            "æœºä½“çŠ¶æ€æä½³ğŸ¥°è¯·ç»§ç»­ä¿æŒè¿™ç§é«˜æ•ˆçŠ¶æ€âœŠ",
            "å“‡å“¦ï¼Œäº²çœ‹èµ·æ¥éå¸¸å¥åº·ğŸ˜˜é€‚åˆæ‰§è¡Œé«˜å±ä»»åŠ¡å‘¢"
        ],      // çŠ¶æ€æä½³
        "eval_acceptable": [
            "è¿è¡ŒçŠ¶æ€å°šå¯ğŸ™‚è¯·ç»§ç»­ä¿æŒ",
            "è™½ç„¶æœ‰äº›ç£¨æŸğŸ˜˜ä½†è¿˜èƒ½ç”¨",
            "å»ºè®®è¿›è¡Œè½»å¾®ç»´æŠ¤ğŸ¥ºå…è´¬å€¼è¿‡å¿«"
        ],   // çŠ¶æ€å°šå¯
        "eval_damaged": [
            "æ£€æµ‹åˆ°æœºä½“å—æŸğŸ¥ºç»´ä¿®è´¹ç”¨ä¼šä»æ‚¨çš„æŠšæ¤é‡‘é‡Œæ‰£é™¤å“¦",
            "å¤–å£³ç ´æŸï¼Œä½“æ¶²æ³„æ¼... çœŸæ˜¯ä½æ•ˆçš„ç”Ÿç‰©æ„é€ ğŸ˜’",
            "è­¦å‘Šï¼šèµ„äº§ä»·å€¼æ­£åœ¨ä¸‹é™ğŸ“‰è¯·ç«‹å³ç»´ä¿®"
        ],      // å—åˆ°æŸä¼¤
        "eval_unstable": [
            "ç²¾ç¥è¯»æ•°æ³¢åŠ¨å‰§çƒˆğŸ˜²å»ºè®®æœç”¨é•‡é™å‰‚ï¼Œæˆ–è€…... è¢«å¤„ç†æ‰ï¼Ÿ",
            "æ£€æµ‹åˆ°é€»è¾‘æ¨¡å—è¿‡çƒ­ğŸ”¥æ‚¨çœ‹èµ·æ¥å¿«è¦å´©æºƒäº†å‘¢ğŸ¥º",
            "å‹åŠ›è¿‡å¤§å®¹æ˜“å¯¼è‡´è¯¯æ“ä½œå“¦ï¼Œå°å¯æ€œğŸ¥º",
            ""
        ],     // å‹åŠ›è¿‡é«˜
        "eval_critical": [
            "è­¦å‘Šï¼šèµ„äº§å³å°†æŠ¥åºŸğŸ¤¬è¯·ç«‹å³åœæ­¢æŸåå…¬å¸çš„ç”Ÿç‰©ç»„ä»¶ï¼",
            "ä¸¥é‡æ•…éšœï¼ä¸¥é‡æ•…éšœï¼å»ºè®®ç«‹å³æ‰§è¡Œå®‰ä¹æ­»ç¨‹åºä»¥æ­¢æŸğŸ¥°",
            "æ‚¨ç°åœ¨çš„çŠ¶æ€è¿åšè‚¥æ–™éƒ½ä¸åˆæ ¼å‘¢ğŸ¥º"
        ],     // æ¿’ä¸´å´©æºƒ (é«˜å‹+æŸä¼¤)

        // --- æ£€å®šç»“æœç»†åˆ† ---
        "react_crit_success": [
            "å®Œç¾ğŸ˜ä¸ºç”œå¿ƒç‚¹èµâ™¥",
            "å…¬å¸çœ‹åˆ°äº†æ‚¨çš„åŠªåŠ›ğŸ˜˜ï¼ˆè™½ç„¶ä¸ä¼šæ¶¨å·¥èµ„ï¼‰",
            "éš¾ä»¥ç½®ä¿¡ğŸ˜²ç¢³åŸºç”Ÿç‰©ç«Ÿç„¶èƒ½åšåˆ°ï¼Ÿ",
            "çœŸ~æ£’!ğŸ˜˜å¦ˆå’ªç»™äº²çˆ±çš„ä¸€é¢—å°çº¢å¿ƒâ™¥"
        ], // å…³é”®æˆåŠŸ
        "react_crit_fail": [
            "å“å‘€ğŸ¥ºæ‚¨çš„æ“ä½œçœŸæ˜¯... ä»¤äººé—æ†¾ğŸ“‰å…¬å¸å¯¹æ‚¨çš„è¯„ä¼°å·²ä¸‹è°ƒ",
            "æ£€æµ‹åˆ°ä¸¥é‡ç¼ºé™·ğŸ˜²å»ºè®®è¿”å‚é‡é€ ",
            "æ‚¨çš„ä¿é™©ä¸è¦†ç›–æœ¬æ„å¤–çš„èµ”å¿ğŸ¤¬",
            "ğŸ˜±æƒ…å†µçœŸæ˜¯æ€¥è½¬ç›´ä¸‹å‘€â†“",
            "è¯·è€ƒè™‘è¯·æ£€æŸ¥ä½ çš„å»¶æ—¶æ€§å½±å“ğŸŒ€åˆ¶é€ æ›´å¤šä¼˜åŠ¿å§ğŸ‘‰.ms list"
        ],    // å…³é”®å¤±è´¥
        "react_combat_success": [
            "ç‚‰ç«çº¯é’ğŸ¥°å°è±¡æ·±åˆ»",
            "æ¼‚äº®çš„æ”»å‡»ğŸ˜˜",
            "æ•Œå¯¹ç›®æ ‡å—æŸğŸ˜˜çœŸæ˜¯æ‚¦è€³çš„å£°éŸ³",
            "äº²çˆ±çš„ğŸ˜çœŸå‰å®³"
        ], // æˆ˜æ–—/æ”»å‡»æˆåŠŸ
        "react_combat_fail": [
            "æœªå‘½ä¸­ğŸ¥ºæ‚¨çš„å…‰å­¦ä¼ æ„Ÿå™¨å‡ºæ•…éšœäº†å—ï¼Ÿ",
            "æ”»å‡»æ— æ•ˆğŸ˜’æµªè´¹å¼¹è¯å¯æ˜¯è¦æ‰£é’±çš„",
            "æè¾¹å¤§å¸ˆï¼ŸğŸ¥º",
            "å‘æ‚¨è¿™ç§å®¹æ˜“æ‰“åçš„äººæ¨èå…´å¥‹è¯ğŸ’‰è¿™å°†å¤§å¤§æé«˜å‘½ä¸­ç‡ğŸ‘‰`.ms use stim`"
        ],    // æˆ˜æ–—/æ”»å‡»å¤±è´¥
        "react_save_success": [
            "å¹¸å­˜ç¡®è®¤ğŸ¥°çœ‹æ¥æ‚¨è¿˜æ²¡åˆ°æŠ¥åºŸçš„æ—¶å€™",
            "æ‚¨çš„æ±‚ç”Ÿæ¬²çœŸæ˜¯ä»¤äººæ„ŸåŠ¨ğŸ¥º",
            "æ£€æµ‹åˆ°å¿ƒè·³é£™å‡... ä¸è®ºå¦‚ä½•æ­å–œäº²çˆ±çš„æˆåŠŸäº†ğŸ˜˜"
        ],   // è±å…æˆåŠŸ
        "react_save_fail": [
            "å›°æƒ‘,ç´§å¼ ,ææ…Œ,æ— åŠ›ğŸ¥º",
            "å“å‘€ğŸ¥ºè¿™ä¸‹å¯éº»çƒ¦äº†",
            "æ£€æµ‹åˆ°ç³»ç»Ÿå¼‚å¸¸... å“¦ğŸ˜’æ˜¯æ‚¨æç ¸äº†"
        ],      // è±å…å¤±è´¥
        "react_death_survived": [
            "ç”Ÿå‘½ä½“å¾å¾®å¼±ä½†ç¨³å®šğŸ˜’åˆ‡ï¼Œæµªè´¹äº†æ—©å·²å‡†å¤‡å¥½çš„é—ä¹¦",
            "å±…ç„¶æ´»ä¸‹æ¥äº†ï¼ŸğŸ˜²çœŸæ˜¯é¡½å¼ºçš„æ¹¿ä»¶",
            "æ¿’æ­»ä½“éªŒå¦‚ä½•ï¼ŸğŸ¥°è®°å¾—å†™ä¸€ä»½æŠ¥å‘Šå“¦",
            "æ­»äº¡æ— æ³•é€ƒè„±ğŸ’€ä½†æ˜¯å¯ä»¥å»¶è¿Ÿ",
            "å‘æ‚¨æ¨èæœ¬å¸çš„[åŒ»ç–—ä»“]æœåŠ¡âš•ï¸å¯ä»¥é™ä½æŸä¼¤ğŸ˜˜å¦‚æœä½ çš„ä¿¡ç”¨ç‚¹è¶³å¤Ÿçš„è¯"
        ], // æ­»äº¡è±å…-å­˜æ´»
        "react_death_confirmed": [
            "æ£€æµ‹åˆ°å¿ƒè·³åœæ­¢ğŸ˜µå·²è‡ªåŠ¨æ³¨é”€å‘˜å·¥è´¦å·ğŸ—‘ï¸æ¸…ç†æœºå™¨äººæ­£åœ¨è·¯ä¸ŠğŸ§¹",
            "ç¡®è®¤æ­»äº¡ğŸ’€å·²ä¸ºæ‚¨é¢„çº¦ç»æµå‹å¤ªç©ºè‘¬ç¤¼ğŸ˜˜æ‰“å¼€èˆ±é—¨,å¼¹å°„~",
            "èµ„äº§æŠ¥åºŸç¡®è®¤ğŸš®å†è§ï¼Œå‰å‘˜å·¥ğŸ¥°",
            "...è¯·ä½¿ç”¨.ms makeæ¥ç”Ÿæˆä¸€ä¸ªæ–°æ¹¿ä»¶",
            "æ­»äº¡æ˜¯å‡‰çˆ½çš„å¤å¤œğŸŒ™å¯ä¾›äººæ— å¿§åœ°å®‰çœ ğŸ˜´"
        ], // æ­»äº¡è±å…-æ­»äº¡
        "react_check_success": [
            "æŒ‡ä»¤æ‰§è¡Œå®Œæ¯•ğŸ˜˜å¹²å¾—ä¸é”™",
            "è¿›ç¨‹é¡ºåˆ©ğŸ¥°ç»§ç»­ä¿æŒ",
        ],  // [Moved] æ£€å®šæˆåŠŸ (é€šç”¨)
        "react_check_fail": [
            "æ“ä½œå¤±è´¥ğŸ¥ºäººç±»æœç„¶å……æ»¡ç¼ºé™·",
            "æ‰§è¡Œé”™è¯¯âŒè¯·æ£€æŸ¥æ‚¨çš„ç¥ç»ä¸­æ¢",
            "å“å‘€ğŸ¥ºæç ¸äº†å‘¢",
            "å»ºè®®æ‚¨ä½¿ç”¨æœ¬å¸å…´å¥‹è¯ğŸ’‰æ®å¯é ç»Ÿè®¡ğŸ“Šèƒ½æœ‰æ•ˆæé«˜ä»»åŠ¡æˆåŠŸç‡ğŸ‘‰`.ms use stim`"
        ],     // [Moved] æ£€å®šå¤±è´¥ (é€šç”¨)

        // --- åŠ¨æ€ååº” ---
        "react_hit_0": [
            "è¿æ°”ä¸é”™ğŸ¤",
        ],
        "react_hit_minor": [
            "å¤–å£³å­˜åœ¨è½»å¾®æ“¦ä¼¤ğŸ¥ºè¯·å‹¿å°†ä½“æ¶²æº…å°„åˆ°è®¾å¤‡ä¸Š",
            "å—åˆ°è½»å¾®è¢­å‡»,å»ºè®®æ‚¨å¿½ç•¥ç—›è§‰ä¿¡å·ğŸ˜˜",
            "å°å¿ƒç‚¹ğŸ¥ºç»´ä¿®å¾ˆè´µçš„",

        ],   // è½»å¾®å—å‡»
        "react_hit_major": [
            "ä¸¥é‡ç»“æ„æŸä¼¤ğŸ˜²å»ºè®®ç«‹å³ç”³è¯·æ›´æ¢é›¶ä»¶... å“¦ğŸ¥ºä½ ä»¬ä¸èƒ½æ¢é›¶ä»¶",
            "è­¦å‘Šï¼šå¦‚æœä½“æ¶²å¤§é‡æµå¤±ğŸ©¸è¯·æ³¨æ„ä¸è¦å¼„è„åœ°æ¿",
            "å“‡å“¦ï¼Œçœ‹èµ·æ¥ä¼šå¾ˆç–¼ğŸ¥°éœ€è¦å¦ˆå’ªå¸®æ‚¨å‘¼å‘¼å—ï¼Ÿ",
            "æ­»äº¡ç­‰å¾…åœ¨æ¾æ‡ˆçš„ç¬é—´ğŸ˜è¯·ä¿æŒä¸“æ³¨",
            "ğŸ’´å»ºè®®æ‚¨å‘æœ¬å…¬å¸è´­ä¹°æ–°çš„é«˜çº§æŠ¤ç”²ğŸ›¡è£…å¤‡, `.ms wear`æ¥ç©¿ç€"

        ],   // ä¸¥é‡å—å‡»
        "react_panic_adrenaline": [
            "ç»æœ›çš„é»‘æš—ä¸­ğŸ‘¼çªç„¶çš„å‹‡æ°”çˆ†å‘å‡ºæœ€è€€çœ¼çš„å…‰èŠ’",
            "æ€’ç«å°±æ˜¯åŠ›é‡ğŸ˜ˆå°†å…¶é‡Šæ”¾å‡ºæ¥!",
            "è‹¦éš¾å­•è‚²ç€å¸Œæœ›ğŸ˜æ¿€å‘ç€æ´»åŠ›",
            "æ„Ÿè§‰å¦‚ä½•?ä½¿ç”¨æœ¬å…¬å¸æ¨å‡ºçš„å…´å¥‹è¯ğŸ’‰èƒ½å¤Ÿè®©ä½ è‹±å‹‡å¸¸é©»ğŸ˜ğŸ‘‰.ms use stim`",
        ],
        "react_panic": [
            "æ£€æµ‹åˆ°é€»è¾‘æ¨¡å—ä¸‹çº¿ğŸ¥ºææƒ§åªæ˜¯å¤§è„‘å¤„ç†ä¸äº†ç°å®çš„å‰¯äº§ç‰©å“¦ğŸ¤“",
            "åˆåœ¨å®³æ€•äº†å—ğŸ¥ºå°å¯æ€œï¼Ÿ",
            "å¿ƒç‡è¿‡é€Ÿï¼Œç³å­”æ”¾å¤§... æ˜¾è€Œæ˜“è§çš„æƒŠæ",
            "å‘æ‚¨æ¨èæœ¬å…¬å¸çš„[è®¤çŸ¥ç¢ç‰‡æ•´ç†]æœåŠ¡ğŸ¥°æœ‰æ•ˆç§»é™¤æƒŠæçŠ¶æ€ğŸ˜ä½¿ç”¨`.ms recover`æŸ¥çœ‹"
        ],       // å‘ç”ŸæƒŠæ
        "react_relief_success": [
            "å‹åŠ›é‡Šæ”¾æˆåŠŸğŸ¥°æ˜¯ä¸æ˜¯æ„Ÿè§‰å¥½å¤šäº†ï¼Ÿå¿«å›å»å·¥ä½œå§",
            "ç²¾ç¥çŠ¶æ€è¶‹äºç¨³å®šğŸ˜˜",
            "å¾ˆå¥½ğŸ¥°æ‚¨åˆå¯ä»¥æ­£å¸¸ä½¿ç”¨äº†"
        ], // å‹åŠ›ç¼“è§£æˆåŠŸ
        "react_relief_fail": [
            "å‹åŠ›ç¼“è§£å¤±è´¥ğŸ¥ºçœ‹æ¥æ‚¨éœ€è¦æ›´å¼ºæ•ˆçš„æ‰‹æ®µå‘¢",
            "è¿˜æ˜¯æ— æ³•å¹³é™å—ï¼ŸğŸ¥ºçœŸæ˜¯éº»çƒ¦çš„ç”Ÿç‰©",
            "ç„¦è™‘æŒ‡æ•°ä¾ç„¶å¾ˆé«˜... å»ºè®®åŠ å¤§è¯é‡ğŸ’Š"
        ],    // å‹åŠ›ç¼“è§£å¤±è´¥
        "react_recover_success": [
            "ç”Ÿç‰©è‡ªæˆ‘ä¿®å¤å®ŒæˆğŸ¥°è™½ç„¶æ•ˆç‡å¾ˆä½ï¼Œä½†è‡³å°‘çœäº†ç»´ä¿®è´¹",
            "æœºä½“æœºèƒ½æ¢å¤ğŸ˜˜",
            "ä¼‘æ¯ç»“æŸğŸ¥°è¯¥å¹²æ´»äº†"
        ], // è‡ªç„¶æ¢å¤æˆåŠŸ
        "react_recover_fail": [
            "è‡ªæ„ˆå¤±è´¥ğŸ¥ºæ‚¨çš„æœºä½“è€åŒ–äº†å—ï¼Ÿ",
            "æ¢å¤æ•ˆæœä¸ä½³ğŸ˜’å»ºè®®ç›´æ¥æ›´æ¢",
            "çœ‹æ¥ç¡ä¸€è§‰å¹¶ä¸èƒ½è§£å†³æ‰€æœ‰é—®é¢˜å‘¢ğŸ¥º"
        ],   // è‡ªç„¶æ¢å¤å¤±è´¥
        "react_medical_care": [
            "åŒ»ç–—ç¨‹åºæ‰§è¡Œä¸­ğŸ’‰è¯·å¿ä½ç–¼ç—›å’Œä¸é€‚æ„ŸğŸ˜˜è¿™æ˜¯ä¸ºäº†å…¬å¸å¥½",
            "æ­£åœ¨ä¿®è¡¥è½¯ä½“é©±åŠ¨å™¨... ğŸ”§",
            "æ²»ç–—ä¸­ğŸ¥°è¯·ç­¾ç½²å…è´£åè®®ï¼ˆå·²è‡ªåŠ¨ç­¾ç½²ï¼‰"
        ],   // æ¥å—åŒ»ç–—æŠ¤ç†
        "react_medical_side_effect": [
            "å“å‘€ï¼Œå‡ºç°äº†ä¸€ç‚¹å°å°çš„å‰¯ä½œç”¨ğŸ¥ºä¸è¿‡åªè¦æ²¡æ­»å°±ä¸ç®—åŒ»ç–—äº‹æ•…å¯¹å§ï¼Ÿ",
            "æ²»ç–—æˆåŠŸï¼é™„èµ äº†ä¸€äº›æœ‰è¶£çš„å°çŠ¶æ€ğŸ¥°",
            "è­¦å‘Šï¼šæ£€æµ‹åˆ°éé¢„æœŸæ’å¼‚ååº”... ç¥æ‚¨å¥½è¿ğŸ˜˜",
            "åˆåŒä¸­è§„å®šäº†æœ¬å‰¯ä½œç”¨ä¸åœ¨ä¿é™©èŒƒå›´å†…"
        ], // åŒ»ç–—æŠ¤ç†è§¦å‘å‰¯ä½œç”¨
        "react_shore_leave_success": [
            "æ„Ÿè°¢æ‚¨ä¸ºå…¬å¸å›æ”¶æµåŠ¨èµ„é‡‘ğŸ¥°å‡æœŸæ„‰å¿«ï¼Œè®°å¾—æŒ‰æ—¶å½’é˜Ÿ",
            "ä¼‘å‡ç”³è¯·é€šè¿‡âœ…å¥½å¥½äº«å—æ‚¨é‚£çŸ­æš‚çš„è‡ªç”±å§",
            "å‹åŠ›å·²æ¸…ç©ºğŸ¥°æœŸå¾…æ‚¨å›æ¥ç»§ç»­åšç‰›åšé©¬"
        ], // ä¼‘å‡æˆåŠŸ
        "react_shore_leave_fail": [
            "ä¼‘å‡ç”³è¯·é©³å›... æˆ–è€…è¯´ï¼Œæ‚¨æç ¸äº†ğŸ¥º",
            "æ”¾æ¾å¤±è´¥ğŸ˜’çœ‹æ¥æ‚¨å¤©ç”Ÿå°±æ˜¯åŠ³ç¢Œå‘½",
            "æµªè´¹äº†é’±è¿˜æ²¡æ”¾æ¾ï¼ŸçœŸæ˜¯æ„šè ¢çš„æŠ•èµ„ğŸ¥º"
        ]     // ä¼‘å‡å¤±è´¥
    };

    class MOM {
        static get KEY_STATUS() { return "$ms_mom_status"; }

        // æ£€æŸ¥ AI æ˜¯å¦å¼€å¯ (é»˜è®¤å¼€å¯)
        static isEnabled(mctx) {
            const s = seal.vars.strGet(mctx, this.KEY_STATUS)[0];
            return s !== "off";
        }

        // åˆ‡æ¢å¼€å…³
        static toggle(mctx, switchVal) {
            const val = (switchVal === "off") ? "off" : "on";
            seal.vars.strSet(mctx, this.KEY_STATUS, val);
            return val === "on";
        }

        // æ ¼å¼åŒ–è¾“å‡º (M.ğŸ’Ÿ.M. > Text)
        static format(text) {
            if (!text) return "";
            return `\n\n M.ğŸ’Ÿ.M. > ${text}`;
        }

        // éšæœºæŠ½å–è¯­å½•
        static pick(key) {
            const list = MOM_ASSETS[key];
            if (!list || list.length === 0) return ""; // å°šæœªé…ç½®æ–‡æœ¬æ—¶ä¸æ˜¾ç¤º
            return list[Math.floor(Math.random() * list.length)];
        }

        // èµ„äº§è¯„ä¼°ç®—æ³• (ç”¨äº .ms st)
        static evaluateAsset(mctx) {
            if (!this.isEnabled(mctx)) return "";

            const hp = seal.vars.intGet(mctx, "ç”Ÿå‘½å€¼")[0];
            const maxHp = seal.vars.intGet(mctx, "ç”Ÿå‘½å€¼ä¸Šé™")[0] || 10;
            const stress = seal.vars.intGet(mctx, "å‹åŠ›")[0];
            const wounds = seal.vars.intGet(mctx, "æŸä¼¤")[0];

            let key = "eval_optimal";

            // é€»è¾‘ä¼˜å…ˆçº§ï¼šæŸä¼¤ > å‹åŠ› > è¡€é‡
            if (wounds > 0 && stress > 15) key = "eval_critical";
            else if (wounds > 0) key = "eval_damaged";
            else if (stress > 15) key = "eval_unstable";
            else if (hp < maxHp * 0.5) key = "eval_acceptable";

            return this.format(this.pick(key));
        }

        // é€šç”¨ååº”æ¥å£
        static react(mctx, eventType, data = {}) {
            if (!this.isEnabled(mctx)) return "";

            let key = "";
            if (eventType === "check") {
                const { success, crit, checkType } = data;

                // 1. å…³é”®ç»“æœä¼˜å…ˆ (Critical Events)
                if (crit === "crit_success") return this.format(this.pick("react_crit_success"));
                if (crit === "crit_fail") return this.format(this.pick("react_crit_fail"));

                // 2. æ ¹æ®æ£€å®šç±»å‹åˆ†ç±» (Context Awareness)
                const type = (checkType || "").toLowerCase();

                // æˆ˜æ–—ç±» (Combat/Attack)
                if (["æˆ˜æ–—", "combat", "atk", "attack", "cbt"].some(t => type.includes(t))) {
                    key = success ? "react_combat_success" : "react_combat_fail";
                }
                // è±å…ç±» (Saves)
                else if (["ç†æ™º", "ææƒ§", "èº«ä½“", "san", "fear", "body", "sanity", "con"].some(t => type.includes(t))) {
                    key = success ? "react_save_success" : "react_save_fail";
                }
                // æ™®é€šå±æ€§/æŠ€èƒ½ (Stats/Skills)
                else {
                    key = success ? "react_check_success" : "react_check_fail";
                }
            } else if (eventType === "death") {
                key = data.isDead ? "react_death_confirmed" : "react_death_survived";
            } else if (eventType === "relief") {
                key = data.success ? "react_relief_success" : "react_relief_fail";
            } else if (eventType === "recover") {
                key = data.success ? "react_recover_success" : "react_recover_fail";
            } else if (eventType === "medical") {
                key = data.hasSideEffect ? "react_medical_side_effect" : "react_medical_care";
            } else if (eventType === "shore_leave") {
                key = data.success ? "react_shore_leave_success" : "react_shore_leave_fail";

            } else if (eventType === "hit") {
                if (data.dmg === 0) {
                    key = "react_hit_0";
                } else if (data.dmg < 10) {
                    key = "react_hit_minor";
                } else {
                    key = "react_hit_major";

                }

            } else {
                // å…¶ä»–ç‰¹å®šäº‹ä»¶æ˜ å°„
                switch (eventType) {
                    case "panic": key = (data.roll === 1) ? "react_panic_adrenaline" : "react_panic"; break;
                }
            }

            return this.format(this.pick(key));
        }
    }

    function main() {
        try { seal.gameSystem.newTemplate(JSON.stringify(msTemplate)); } catch (e) { console.log("æ¯èˆ°èµ·é£å¤±è´¥", e); }
        let ext = seal.ext.find(MS_CONSTS.NAME);
        if (!ext) {
            ext = seal.ext.new(MS_CONSTS.NAME, msTemplate.authors[0], msTemplate.version);
            seal.ext.register(ext);
        }
        MSCommands.register(ext);
        console.log("æ¯èˆ°(mothership)è§„åˆ™æ’ä»¶ v1.0.1-beta å·²åŠ è½½ã€‚");
    }

    main();
})();
